<!doctype html>
<html lang="en-us">
  <head>
    <title>Python开发【第七篇】：面向对象 // 蔡振威的博客</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.107.0">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.9e9c6027c30f5aa9423b581bd9cddd1ddc66088adb9c2604f89eb5828efea5a1.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python开发【第七篇】：面向对象"/>
<meta name="twitter:description" content="面向对象基础 基础内容介绍详见一下两篇博文：
面向对象初级篇 面向对象进阶篇 其他相关 一、isinstance(obj, cls)
检查是否obj是否是类 cls 的对象
class Foo(object): pass
obj = Foo()
isinstance(obj, Foo)
二、issubclass(sub, super)
检查sub类是否是 super 类的派生类
class Foo(object): pass
class Bar(Foo): pass
issubclass(Bar, Foo)
三、异常处理
1、异常基础
在编程过程中为了增加友好性，在程序出现bug时一般不会将错误信息显示给用户，而是现实一个提示的页面，通俗来说就是不让用户看见大黄页！！！
try: pass except Exception,ex: pass
需求：将用户输入的两个数字相加
while True: num1 = raw_input(&rsquo;num1:&rsquo;) num2 = raw_input(&rsquo;num2:&rsquo;) try: num1 = int(num1) num2 = int(num2) result = num1 &#43; num2 except Exception, e: print &lsquo;出现异常，信息如下：&rsquo; print e
View Code
2、异常种类"/>

    <meta property="og:title" content="Python开发【第七篇】：面向对象" />
<meta property="og:description" content="面向对象基础 基础内容介绍详见一下两篇博文：
面向对象初级篇 面向对象进阶篇 其他相关 一、isinstance(obj, cls)
检查是否obj是否是类 cls 的对象
class Foo(object): pass
obj = Foo()
isinstance(obj, Foo)
二、issubclass(sub, super)
检查sub类是否是 super 类的派生类
class Foo(object): pass
class Bar(Foo): pass
issubclass(Bar, Foo)
三、异常处理
1、异常基础
在编程过程中为了增加友好性，在程序出现bug时一般不会将错误信息显示给用户，而是现实一个提示的页面，通俗来说就是不让用户看见大黄页！！！
try: pass except Exception,ex: pass
需求：将用户输入的两个数字相加
while True: num1 = raw_input(&rsquo;num1:&rsquo;) num2 = raw_input(&rsquo;num2:&rsquo;) try: num1 = int(num1) num2 = int(num2) result = num1 &#43; num2 except Exception, e: print &lsquo;出现异常，信息如下：&rsquo; print e
View Code
2、异常种类" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://water711.github.io/posts/2017-04-11-python%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%83%E7%AF%87%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-04-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2017-04-11T00:00:00+00:00" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://water711.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <span class="app-header-title">蔡振威的博客</span>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Python开发【第七篇】：面向对象</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 11, 2017
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          5 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <h3 id="面向对象基础">面向对象基础</h3>
<p>基础内容介绍详见一下两篇博文：</p>
<ul>
<li><a href="http://www.cnblogs.com/wupeiqi/p/4493506.html">面向对象初级篇</a></li>
<li><a href="http://www.cnblogs.com/wupeiqi/p/4766801.html">面向对象进阶篇</a></li>
</ul>
<h3 id="其他相关">其他相关</h3>
<p><strong>一、isinstance(obj, cls)</strong></p>
<p> 检查是否obj是否是类 cls 的对象</p>
<p>class Foo(object):
pass</p>
<p>obj = Foo()</p>
<p>isinstance(obj, Foo)</p>
<p><strong>二、issubclass(sub, super)</strong></p>
<p>检查sub类是否是 super 类的派生类</p>
<p>class Foo(object):
pass</p>
<p>class Bar(Foo):
pass</p>
<p>issubclass(Bar, Foo)</p>
<p><strong>三、异常处理</strong></p>
<p><strong>1、异常基础</strong></p>
<p>在编程过程中为了增加友好性，在程序出现bug时一般不会将错误信息显示给用户，而是现实一个提示的页面，通俗来说就是不让用户看见大黄页！！！</p>
<p>try:
pass
except Exception,ex:
pass</p>
<p>需求：将用户输入的两个数字相加</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>while True:
num1 = raw_input(&rsquo;num1:&rsquo;)
num2 = raw_input(&rsquo;num2:&rsquo;) try:
num1 = int(num1)
num2 = int(num2)
result = num1 + num2 except Exception, e: print &lsquo;出现异常，信息如下：&rsquo;
print e</p>
<p>View Code</p>
<p><strong>2、异常种类</strong></p>
<p>python中的异常种类非常多，每个异常专门用于处理某一项异常！！！</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x
IOError 输入/输出异常；基本上是无法打开文件
ImportError 无法引入模块或包；基本上是路径问题或名称错误
IndentationError 语法错误（的子类） ；代码没有正确对齐
IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]
KeyError 试图访问字典里不存在的键
KeyboardInterrupt Ctrl+C被按下
NameError 使用一个还未被赋予对象的变量
SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）
TypeError 传入对象类型与要求的不符合
UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，
导致你以为正在访问它
ValueError 传入一个调用者不期望的值，即使值的类型是正确的</p>
<p>常用异常</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>ArithmeticError
AssertionError
AttributeError
BaseException
BufferError
BytesWarning
DeprecationWarning
EnvironmentError
EOFError
Exception
FloatingPointError
FutureWarning
GeneratorExit
ImportError
ImportWarning
IndentationError
IndexError
IOError
KeyboardInterrupt
KeyError
LookupError
MemoryError
NameError
NotImplementedError
OSError
OverflowError
PendingDeprecationWarning
ReferenceError
RuntimeError
RuntimeWarning
StandardError
StopIteration
SyntaxError
SyntaxWarning
SystemError
SystemExit
TabError
TypeError
UnboundLocalError
UnicodeDecodeError
UnicodeEncodeError
UnicodeError
UnicodeTranslateError
UnicodeWarning
UserWarning
ValueError
Warning
ZeroDivisionError</p>
<p>更多异常</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>dic = [&ldquo;wupeiqi&rdquo;, &lsquo;alex&rsquo;] try:
dic[10] except IndexError, e: print e</p>
<p>实例：IndexError</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>dic = {&lsquo;k1&rsquo;:&lsquo;v1&rsquo;} try:
dic[&lsquo;k20&rsquo;] except KeyError, e: print e</p>
<p>实例：KeyError</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>s1 = &lsquo;hello&rsquo;
try:
int(s1) except ValueError, e: print e</p>
<p>实例：ValueError</p>
<p>对于上述实例，异常类只能用来处理指定的异常情况，如果非指定异常则无法处理。</p>
<p># 未捕获到异常，程序直接报错</p>
<p>s1 = &lsquo;hello&rsquo;
try:
int(s1)
except IndexError,e:
print e</p>
<p>所以，写程序时需要考虑到try代码块中可能出现的任意异常，可以这样写：</p>
<p>s1 = &lsquo;hello&rsquo;
try:
int(s1)
except IndexError,e:
print e
except KeyError,e:
print e
except ValueError,e:
print e</p>
<p>万能异常 在python的异常中，有一个万能异常：Exception，他可以捕获任意异常，即：</p>
<p>s1 = &lsquo;hello&rsquo;
try:
int(s1)
except Exception,e:
print e</p>
<p>接下来你可能要问了，既然有这个万能异常，其他异常是不是就可以忽略了！</p>
<p>答：当然不是，对于特殊处理或提醒的异常需要先定义，最后定义Exception来确保程序正常运行。</p>
<p>s1 = &lsquo;hello&rsquo;
try:
int(s1)
except KeyError,e:
print &lsquo;键错误&rsquo;
except IndexError,e:
print &lsquo;索引错误&rsquo;
except Exception, e:
print &lsquo;错误&rsquo;</p>
<p><strong>3、异常其他结构</strong></p>
<p>try:
# 主代码块
pass
except KeyError,e:
# 异常时，执行该块
pass
else:
# 主代码块执行完，执行该块
pass
finally:
# 无论异常与否，最终执行该块
pass</p>
<p><strong>4、主动触发异常</strong></p>
<p>try:
raise Exception(&lsquo;错误了。。。&rsquo;)
except Exception,e:
print e</p>
<p><strong>5、自定义异常</strong></p>
<p>class WupeiqiException(Exception):</p>
<pre><code>def \_\_init\_\_(self, msg):
    self.message = msg

def \_\_str\_\_(self):
    return self.message
</code></pre>
<p>try:
raise WupeiqiException(&lsquo;我的异常&rsquo;)
except WupeiqiException,e:
print e</p>
<p><strong>6、断言</strong></p>
<p># assert 条件</p>
<p>assert 1 == 1</p>
<p>assert 1 == 2</p>
<p><strong>四、反射</strong></p>
<p>python中的反射功能是由以下四个内置函数提供：hasattr、getattr、setattr、delattr，改四个函数分别用于对对象内部执行：检查是否含有某成员、获取成员、设置成员、删除成员。</p>
<p>class Foo(object):</p>
<pre><code>def \_\_init\_\_(self):
    self.name = 'wupeiqi'

def func(self):
    return 'func'
</code></pre>
<p>obj = Foo()</p>
<h1 id="-检查是否含有成员">#### 检查是否含有成员</h1>
<p>hasattr(obj, &rsquo;name&rsquo;)
hasattr(obj, &lsquo;func&rsquo;)</p>
<h1 id="-获取成员">#### 获取成员</h1>
<p>getattr(obj, &rsquo;name&rsquo;)
getattr(obj, &lsquo;func&rsquo;)</p>
<h1 id="-设置成员">#### 设置成员</h1>
<p>setattr(obj, &lsquo;age&rsquo;, 18)
setattr(obj, &lsquo;show&rsquo;, lambda num: num + 1)</p>
<h1 id="-删除成员">#### 删除成员</h1>
<p>delattr(obj, &rsquo;name&rsquo;)
delattr(obj, &lsquo;func&rsquo;)</p>
<blockquote>
<p>详细解析：</p>
<p>当我们要访问一个对象的成员时，应该是这样操作：</p>
<p>class Foo(object):</p>
<pre><code>def \_\_init\_\_(self):
    self.name = 'alex'

def func(self):
    return 'func'
</code></pre>
<p>obj = Foo()</p>
<h1 id="访问字段">访问字段</h1>
<p>obj.name</p>
<h1 id="执行方法">执行方法</h1>
<p>obj.func()</p>
<p> <img src="http://hugo.caizhenwei.top//425762-20150907094454965-329821364.jpg" alt="">  </p>
<p>那么问题来了？</p>
<p>a、上述访问对象成员的 name 和 func 是什么？ </p>
<p><em>答：是变量名</em></p>
<p>b、obj.xxx 是什么意思？ </p>
<p><em>答：obj.xxx 表示去obj中或类中寻找变量名 xxx，并获取对应内存地址中的内容。</em></p>
<p>c、需求：请使用其他方式获取obj对象中的name变量指向内存中的值 “alex”</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>class Foo(object): def __init__(self):
self.name = &lsquo;alex&rsquo;</p>
<h1 id="不允许使用-objname">不允许使用 obj.name</h1>
<p>obj = Foo()</p>
<p>View Code</p>
<p><em>答：有两种方式，如下：</em></p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>class Foo(object): def __init__(self):
self.name = &lsquo;alex&rsquo;</p>
<pre><code>def func(self): return 'func'
</code></pre>
<h1 id="不允许使用-objname-1">不允许使用 obj.name</h1>
<p>obj = Foo() print obj.__dict__[&rsquo;name&rsquo;]</p>
<p>方式一</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>class Foo(object): def __init__(self):
self.name = &lsquo;alex&rsquo;</p>
<pre><code>def func(self): return 'func'
</code></pre>
<h1 id="不允许使用-objname-2">不允许使用 obj.name</h1>
<p>obj = Foo() print getattr(obj, &rsquo;name&rsquo;)</p>
<p>方式二</p>
<p>d、比较三种访问方式</p>
<ul>
<li>obj.name</li>
<li>obj.__dict__[&rsquo;name&rsquo;]</li>
<li>getattr(obj, &rsquo;name&rsquo;)</li>
</ul>
<p><em>答：第一种和其他种比，&hellip;</em><br>
<em>第二种和第三种比，&hellip;</em></p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>#!/usr/bin/env python #coding:utf-8
from wsgiref.simple_server import make_server class Handler(object): def index(self): return &lsquo;index&rsquo;</p>
<pre><code>def news(self): return 'news'
</code></pre>
<p>def RunServer(environ, start_response):
start_response(&lsquo;200 OK&rsquo;, [(&lsquo;Content-Type&rsquo;, &rsquo;text/html&rsquo;)])
url = environ[&lsquo;PATH_INFO&rsquo;]
temp = url.split(&rsquo;/&rsquo;)[1]
obj = Handler()
is_exist = hasattr(obj, temp) if is_exist:
func = getattr(obj, temp)
ret = func() return ret else: return &lsquo;404 not found&rsquo;</p>
<p>if __name__ == &lsquo;__main__&rsquo;:
httpd = make_server(&rsquo;&rsquo;, 8001, RunServer) print &ldquo;Serving HTTP on port 8000&hellip;&rdquo; httpd.serve_forever()</p>
<p>Web框架实例</p>
</blockquote>
<p>**结论：**反射是通过字符串的形式操作对象相关的成员。<strong>一切事物都是对象！！！</strong></p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>#!/usr/bin/env python # -*- coding:utf-8 -*-</p>
<p>import sys def s1(): print &lsquo;s1&rsquo;</p>
<p>def s2(): print &lsquo;s2&rsquo; this_module = sys.modules[__name__]</p>
<p>hasattr(this_module, &lsquo;s1&rsquo;)
getattr(this_module, &lsquo;s2&rsquo;)</p>
<p>反射当前模块成员</p>
<p><strong>类也是对象</strong></p>
<p>class Foo(object):</p>
<pre><code>staticField = &quot;old boy&quot;

def \_\_init\_\_(self):
    self.name = 'wupeiqi'

def func(self):
    return 'func'

@staticmethod
def bar():
    return 'bar'
</code></pre>
<p>print getattr(Foo, &lsquo;staticField&rsquo;)
print getattr(Foo, &lsquo;func&rsquo;)
print getattr(Foo, &lsquo;bar&rsquo;)</p>
<p><strong>模块也是对象</strong></p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>#!/usr/bin/env python # -*- coding:utf-8 -*-</p>
<p>def dev(): return &lsquo;dev&rsquo;</p>
<p>home.py</p>
<p>#!/usr/bin/env python</p>
<h1 id="---codingutf-8---">-*- coding:utf-8 -*-</h1>
<p>&quot;&quot;&quot;
程序目录：
home.py
index.py</p>
<p>当前文件：
index.py
&quot;&quot;&quot;</p>
<p>import home as obj</p>
<p>#obj.dev()</p>
<p>func = getattr(obj, &lsquo;dev&rsquo;)
func() </p>
<h3 id="设计模式">设计模式</h3>
<p><strong>一、单例模式</strong></p>
<p>单例，顾名思义单个实例。</p>
<blockquote>
<p>学习单例之前，首先来回顾下面向对象的内容：</p>
<p>python的面向对象由两个非常重要的两个“东西”组成：类、实例</p>
<p><strong>面向对象场景一：</strong></p>
<p>如：创建三个游戏人物，分别是：</p>
<ul>
<li>苍井井，女，18，初始战斗力1000</li>
<li>东尼木木，男，20，初始战斗力1800</li>
<li>波多多，女，19，初始战斗力2500</li>
</ul>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<h1 id="--定义类">#####################  定义类 </h1>
<p>class Person: def __init__(self, na, gen, age, fig):
self.name = na
self.gender = gen
self.age = age
self.fight =fig def grassland(self): &ldquo;&ldquo;&ldquo;注释：草丛战斗，消耗200战斗力&rdquo;&rdquo;&rdquo; self.fight = self.fight - 200</p>
<h1 id="--创建实例">#####################  创建实例 </h1>
<p>cang = Person(&lsquo;苍井井&rsquo;, &lsquo;女&rsquo;, 18, 1000)    # 创建苍井井角色
dong = Person(&lsquo;东尼木木&rsquo;, &lsquo;男&rsquo;, 20, 1800)  # 创建东尼木木角色
bo = Person(&lsquo;波多多&rsquo;, &lsquo;女&rsquo;, 19, 2500)      # 创建波多多角色</p>
<p>View Code</p>
<p><strong>面向对象场景二：</strong></p>
<p>如：创建对数据库操作的公共类</p>
<ul>
<li>增</li>
<li>删</li>
<li>改</li>
<li>查</li>
</ul>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<h1 id="-定义类">#### 定义类</h1>
<p>class DbHelper(object): def __init__(self):
self.hostname = &lsquo;1.1.1.1&rsquo; self.port = 3306 self.password = &lsquo;pwd&rsquo; self.username = &lsquo;root&rsquo;</p>
<pre><code>def fetch(self): # 连接数据库
    # 拼接sql语句
    # 操作
    pass

def create(self): # 连接数据库
    # 拼接sql语句
    # 操作
    pass

def remove(self): # 连接数据库
    # 拼接sql语句
    # 操作
    pass

def modify(self): # 连接数据库
    # 拼接sql语句
    # 操作
    pass
</code></pre>
<h1 id="-操作类">#### 操作类</h1>
<p>db = DbHelper()
db.create()</p>
<p>View Code</p>
</blockquote>
<p>**实例：**结合场景二实现Web应用程序</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>#!/usr/bin/env python #coding:utf-8
from wsgiref.simple_server import make_server class DbHelper(object): def __init__(self):
self.hostname = &lsquo;1.1.1.1&rsquo; self.port = 3306 self.password = &lsquo;pwd&rsquo; self.username = &lsquo;root&rsquo;</p>
<pre><code>def fetch(self): # 连接数据库
    # 拼接sql语句
    # 操作
    return 'fetch'

def create(self): # 连接数据库
    # 拼接sql语句
    # 操作
    return 'create'

def remove(self): # 连接数据库
    # 拼接sql语句
    # 操作
    return 'remove'

def modify(self): # 连接数据库
    # 拼接sql语句
    # 操作
    return 'modify'
</code></pre>
<p>class Handler(object): def index(self): # 创建对象
db = DbHelper()
db.fetch() return &lsquo;index&rsquo;</p>
<pre><code>def news(self): return 'news'
</code></pre>
<p>def RunServer(environ, start_response):
start_response(&lsquo;200 OK&rsquo;, [(&lsquo;Content-Type&rsquo;, &rsquo;text/html&rsquo;)])
url = environ[&lsquo;PATH_INFO&rsquo;]
temp = url.split(&rsquo;/&rsquo;)[1]
obj = Handler()
is_exist = hasattr(obj, temp) if is_exist:
func = getattr(obj, temp)
ret = func() return ret else: return &lsquo;404 not found&rsquo;</p>
<p>if __name__ == &lsquo;__main__&rsquo;:
httpd = make_server(&rsquo;&rsquo;, 8001, RunServer) print &ldquo;Serving HTTP on port 8001&hellip;&rdquo; httpd.serve_forever()</p>
<p>Web应用程序实例</p>
<p>对于上述实例，每个请求到来，都需要在内存里创建一个实例，再通过该实例执行指定的方法。</p>
<p>那么问题来了&hellip;如果并发量大的话，内存里就会存在非常多<strong>功能上一模一样的对象</strong>。存在这些对象肯定会消耗内存，对于这些功能相同的对象可以在内存中仅创建一个，需要时都去调用，也是极好的！！！</p>
<p><strong>铛铛 铛铛 铛铛铛铛铛</strong>，单例模式出马，单例模式用来保证内存中<strong>仅存在一个实例</strong>！！！</p>
<p>通过面向对象的特性，构造出单例模式：</p>
<p># ########### 单例类定义 ###########
class Foo(object):</p>
<pre><code>\_\_instance = None

@staticmethod
def singleton():
    if Foo.\_\_instance:
        return Foo.\_\_instance
    else:
        Foo.\_\_instance = Foo()
        return Foo.\_\_instance
</code></pre>
<h1 id="-获取实例">########### 获取实例</h1>
<p>obj = Foo.singleton()</p>
<p>对于Python单例模式，创建对象时不能再直接使用：obj = Foo()，而应该调用特殊的方法：obj = Foo.singleton() 。</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>#!/usr/bin/env python #coding:utf-8
from wsgiref.simple_server import make_server # ########### 单例类定义 ###########
class DbHelper(object): __instance = None def __init__(self):
self.hostname = &lsquo;1.1.1.1&rsquo; self.port = 3306 self.password = &lsquo;pwd&rsquo; self.username = &lsquo;root&rsquo; @staticmethod def singleton(): if DbHelper.__instance: return DbHelper.__instance
else:
DbHelper.__instance = DbHelper() return DbHelper.__instance</p>
<pre><code>def fetch(self): # 连接数据库
    # 拼接sql语句
    # 操作
    pass

def create(self): # 连接数据库
    # 拼接sql语句
    # 操作
    pass

def remove(self): # 连接数据库
    # 拼接sql语句
    # 操作
    pass

def modify(self): # 连接数据库
    # 拼接sql语句
    # 操作
    pass
</code></pre>
<p>class Handler(object): def index(self):
obj = DbHelper.singleton() print id(single)
obj.create() return &lsquo;index&rsquo;</p>
<pre><code>def news(self): return 'news'
</code></pre>
<p>def RunServer(environ, start_response):
start_response(&lsquo;200 OK&rsquo;, [(&lsquo;Content-Type&rsquo;, &rsquo;text/html&rsquo;)])
url = environ[&lsquo;PATH_INFO&rsquo;]
temp = url.split(&rsquo;/&rsquo;)[1]
obj = Handler()
is_exist = hasattr(obj, temp) if is_exist:
func = getattr(obj, temp)
ret = func() return ret else: return &lsquo;404 not found&rsquo;</p>
<p>if __name__ == &lsquo;__main__&rsquo;:
httpd = make_server(&rsquo;&rsquo;, 8001, RunServer) print &ldquo;Serving HTTP on port 8001&hellip;&rdquo; httpd.serve_forever()</p>
<p>Web应用实例-单例模式</p>
<p>总结：单利模式存在的目的是保证当前内存中仅存在单个实例，避免内存浪费！！！</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
