<!doctype html>
<html lang="en-us">
  <head>
    <title>Python开发【第四篇】：Python基础之函数 // 蔡振威的博客</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.107.0">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.9e9c6027c30f5aa9423b581bd9cddd1ddc66088adb9c2604f89eb5828efea5a1.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python开发【第四篇】：Python基础之函数"/>
<meta name="twitter:description" content="三元运算 三元运算（三目运算），是对简单的条件语句的缩写。
# 书写格式
result = 值1 if 条件 else 值2
如果条件成立，那么将 “值1” 赋值给result变量，否则，将“值2”赋值给result变量 基本数据类型补充 set
set集合，是一个无序且不重复的元素集合
class set(object): &quot;&quot;&quot; set() -&gt; new empty set object set(iterable) -&gt; new set object
Build an unordered collection of unique elements. &quot;&quot;&quot; def add(self, \*args, \*\*kwargs): # real signature unknown &quot;&quot;&quot; Add an element to a set，添加元素 This has no effect if the element is already present. &quot;&quot;&quot; pass def clear(self, \*args, \*\*kwargs): # real signature unknown &quot;&quot;&quot; Remove all elements from this set."/>

    <meta property="og:title" content="Python开发【第四篇】：Python基础之函数" />
<meta property="og:description" content="三元运算 三元运算（三目运算），是对简单的条件语句的缩写。
# 书写格式
result = 值1 if 条件 else 值2
如果条件成立，那么将 “值1” 赋值给result变量，否则，将“值2”赋值给result变量 基本数据类型补充 set
set集合，是一个无序且不重复的元素集合
class set(object): &quot;&quot;&quot; set() -&gt; new empty set object set(iterable) -&gt; new set object
Build an unordered collection of unique elements. &quot;&quot;&quot; def add(self, \*args, \*\*kwargs): # real signature unknown &quot;&quot;&quot; Add an element to a set，添加元素 This has no effect if the element is already present. &quot;&quot;&quot; pass def clear(self, \*args, \*\*kwargs): # real signature unknown &quot;&quot;&quot; Remove all elements from this set." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://water711.github.io/posts/2017-04-11-python%E5%BC%80%E5%8F%91%E7%AC%AC%E5%9B%9B%E7%AF%87python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-04-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2017-04-11T00:00:00+00:00" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://water711.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <span class="app-header-title">蔡振威的博客</span>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Python开发【第四篇】：Python基础之函数</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 11, 2017
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          11 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <h3 id="三元运算">三元运算</h3>
<p>三元运算（三目运算），是对简单的条件语句的缩写。</p>
<p># 书写格式</p>
<p>result = 值1 if 条件 else 值2</p>
<h1 id="如果条件成立那么将-值1-赋值给result变量否则将值2赋值给result变量">如果条件成立，那么将 “值1” 赋值给result变量，否则，将“值2”赋值给result变量</h1>
<h3 id="基本数据类型补充">基本数据类型补充</h3>
<p><strong>set</strong></p>
<p>set集合，是一个无序且不重复的元素集合</p>
<p>class set(object):
&quot;&quot;&quot;
set() -&gt; new empty set object
set(iterable) -&gt; new set object</p>
<pre><code>Build an unordered collection of unique elements.
&quot;&quot;&quot;
def add(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot;
    Add an element to a set，添加元素
    
    This has no effect if the element is already present.
    &quot;&quot;&quot;
    pass

def clear(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot; Remove all elements from this set. 清除内容&quot;&quot;&quot;
    pass

def copy(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot; Return a shallow copy of a set. 浅拷贝  &quot;&quot;&quot;
    pass

def difference(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot;
    Return the difference of two or more sets as a new set. A中存在，B中不存在
    
    (i.e. all elements that are in this set but not the others.)
    &quot;&quot;&quot;
    pass

def difference\_update(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot; Remove all elements of another set from this set.  从当前集合中删除和B中相同的元素&quot;&quot;&quot;
    pass

def discard(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot;
    Remove an element from a set if it is a member.
    
    If the element is not a member, do nothing. 移除指定元素，不存在不保错
    &quot;&quot;&quot;
    pass

def intersection(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot;
    Return the intersection of two sets as a new set. 交集
    
    (i.e. all elements that are in both sets.)
    &quot;&quot;&quot;
    pass

def intersection\_update(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot; Update a set with the intersection of itself and another.  取交集并更更新到A中 &quot;&quot;&quot;
    pass

def isdisjoint(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot; Return True if two sets have a null intersection.  如果没有交集，返回True，否则返回False&quot;&quot;&quot;
    pass

def issubset(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot; Report whether another set contains this set.  是否是子序列&quot;&quot;&quot;
    pass

def issuperset(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot; Report whether this set contains another set. 是否是父序列&quot;&quot;&quot;
    pass

def pop(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot;
    Remove and return an arbitrary set element.
    Raises KeyError if the set is empty. 移除元素
    &quot;&quot;&quot;
    pass

def remove(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot;
    Remove an element from a set; it must be a member.
    
    If the element is not a member, raise a KeyError. 移除指定元素，不存在保错
    &quot;&quot;&quot;
    pass

def symmetric\_difference(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot;
    Return the symmetric difference of two sets as a new set.  对称差集
    
    (i.e. all elements that are in exactly one of the sets.)
    &quot;&quot;&quot;
    pass

def symmetric\_difference\_update(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot; Update a set with the symmetric difference of itself and another. 对称差集，并更新到a中 &quot;&quot;&quot;
    pass

def union(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot;
    Return the union of sets as a new set.  并集
    
    (i.e. all elements that are in either set.)
    &quot;&quot;&quot;
    pass

def update(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot; Update a set with the union of itself and others. 更新 &quot;&quot;&quot;
    pass
</code></pre>
<p>**练习：**寻找差异</p>
<p># 数据库中原有
old_dict = {
&ldquo;#1&rdquo;:{ &lsquo;hostname&rsquo;:c1, &lsquo;cpu_count&rsquo;: 2, &lsquo;mem_capicity&rsquo;: 80 },
&ldquo;#2&rdquo;:{ &lsquo;hostname&rsquo;:c1, &lsquo;cpu_count&rsquo;: 2, &lsquo;mem_capicity&rsquo;: 80 }
&ldquo;#3&rdquo;:{ &lsquo;hostname&rsquo;:c1, &lsquo;cpu_count&rsquo;: 2, &lsquo;mem_capicity&rsquo;: 80 }
}</p>
<h1 id="cmdb-新汇报的数据">cmdb 新汇报的数据</h1>
<p>new_dict = {
&ldquo;#1&rdquo;:{ &lsquo;hostname&rsquo;:c1, &lsquo;cpu_count&rsquo;: 2, &lsquo;mem_capicity&rsquo;: 800 },
&ldquo;#3&rdquo;:{ &lsquo;hostname&rsquo;:c1, &lsquo;cpu_count&rsquo;: 2, &lsquo;mem_capicity&rsquo;: 80 }
&ldquo;#4&rdquo;:{ &lsquo;hostname&rsquo;:c2, &lsquo;cpu_count&rsquo;: 2, &lsquo;mem_capicity&rsquo;: 80 }
}</p>
<p><code>需要删除：？   ``需要新建：？   ``需要更新：？   注意：无需考虑内部元素是否改变，只要原来存在，新汇报也存在，就是需要更新</code></p>
<h3 id="深浅拷贝">深浅拷贝</h3>
<p><strong>一、数字和字符串</strong></p>
<p>对于 数字 和 字符串 而言，赋值、浅拷贝和深拷贝无意义，因为其永远指向同一个内存地址。</p>
<p>import copy</p>
<h1 id="-数字字符串">######### 数字、字符串</h1>
<p>n1 = 123</p>
<h1 id="n1--i-am-alex-age-10">n1 = &ldquo;i am alex age 10&rdquo;</h1>
<p>print(id(n1))</p>
<h1 id="-赋值">## 赋值</h1>
<p>n2 = n1
print(id(n2))</p>
<h1 id="-浅拷贝">## 浅拷贝</h1>
<p>n2 = copy.copy(n1)
print(id(n2))</p>
<h1 id="-深拷贝">## 深拷贝</h1>
<p>n3 = copy.deepcopy(n1)
print(id(n3))</p>
<p><img src="http://hugo.caizhenwei.top//425762-20160115223330382-1298317428.png" alt=""></p>
<p><strong>二、其他基本数据类型</strong></p>
<p>对于字典、元祖、列表 而言，进行赋值、浅拷贝和深拷贝时，其内存地址的变化是不同的。</p>
<p>1、赋值</p>
<p><strong>赋值</strong>，只是创建一个变量，该变量指向原来内存地址，如：</p>
<p>n1 = {&ldquo;k1&rdquo;: &ldquo;wu&rdquo;, &ldquo;k2&rdquo;: 123, &ldquo;k3&rdquo;: [&ldquo;alex&rdquo;, 456]}</p>
<p>n2 = n1</p>
<p>　　<img src="http://hugo.caizhenwei.top//425762-20160115225752366-1852942198.png" alt=""></p>
<p>2、浅拷贝</p>
<p><strong>浅拷贝</strong>，在内存中只额外创建第一层数据</p>
<p>import copy</p>
<p>n1 = {&ldquo;k1&rdquo;: &ldquo;wu&rdquo;, &ldquo;k2&rdquo;: 123, &ldquo;k3&rdquo;: [&ldquo;alex&rdquo;, 456]}</p>
<p>n3 = copy.copy(n1)</p>
<p><img src="http://hugo.caizhenwei.top//425762-20160115230038772-549220231.png" alt=""></p>
<p>3、深拷贝</p>
<p><strong>深拷贝</strong>，在内存中将所有的数据重新创建一份（排除最后一层，即：python内部对字符串和数字的优化）</p>
<p>import copy</p>
<p>n1 = {&ldquo;k1&rdquo;: &ldquo;wu&rdquo;, &ldquo;k2&rdquo;: 123, &ldquo;k3&rdquo;: [&ldquo;alex&rdquo;, 456]}</p>
<p>n4 = copy.deepcopy(n1)</p>
<p><img src="http://hugo.caizhenwei.top//425762-20160115230309272-1357770402.png" alt=""></p>
<h3 id="函数">函数</h3>
<p><strong>一、背景</strong></p>
<p>在学习函数之前，一直遵循：面向过程编程，即：根据业务逻辑从上到下实现功能，其往往用一长段代码来实现指定功能，开发过程中最常见的操作就是粘贴复制，也就是将之前实现的代码块复制到现需功能处，如下：</p>
<p>while True：
if cpu利用率 &gt; 90%:
#发送邮件提醒
连接邮箱服务器
发送邮件
关闭连接</p>
<pre><code>if 硬盘使用空间 &gt; 90%:
    #发送邮件提醒
    连接邮箱服务器
    发送邮件
    关闭连接

if 内存占用 &gt; 80%:
    #发送邮件提醒
    连接邮箱服务器
    发送邮件
    关闭连接
</code></pre>
<p>腚眼一看上述代码，if条件语句下的内容可以被提取出来公用，如下：</p>
<p>def 发送邮件(内容)
#发送邮件提醒
连接邮箱服务器
发送邮件
关闭连接</p>
<p>while True：</p>
<pre><code>if cpu利用率 &gt; 90%:
    发送邮件('CPU报警')

if 硬盘使用空间 &gt; 90%:
    发送邮件('硬盘报警')

if 内存占用 &gt; 80%:
</code></pre>
<p>对于上述的两种实现方式，第二次必然比第一次的重用性和可读性要好，其实这就是函数式编程和面向过程编程的区别：</p>
<ul>
<li>函数式：将某功能代码封装到函数中，日后便无需重复编写，仅调用函数即可</li>
<li>面向对象：对函数进行分类和封装，让开发“更快更好更强&hellip;”</li>
</ul>
<p><strong>函数式编程最重要的是增强代码的重用性和可读性</strong></p>
<p><strong><strong>二、定义和使用</strong></strong></p>
<p>def 函数名(参数):</p>
<pre><code>...
函数体
...
返回值
</code></pre>
<p>函数的定义主要有如下要点：</p>
<ul>
<li>def：表示函数的关键字</li>
<li>函数名：函数的名称，日后根据函数名调用函数</li>
<li>函数体：函数中进行一系列的逻辑计算，如：发送邮件、计算出 [11,22,38,888,2]中的最大数等&hellip;</li>
<li>参数：为函数体提供数据</li>
<li>返回值：当函数执行完毕后，可以给调用者返回数据。</li>
</ul>
<p><strong>1、返回值</strong></p>
<p>函数是一个功能块，该功能到底执行成功与否，需要通过返回值来告知调用者。</p>
<p>以上要点中，比较重要有参数和返回值：</p>
<p>def 发送短信():</p>
<pre><code>发送短信的代码...

if 发送成功:
    return True
else:
    return False
</code></pre>
<p>while True:</p>
<pre><code># 每次执行发送短信函数，都会将返回值自动赋值给result
# 之后，可以根据result来写日志，或重发等操作

result = 发送短信()
if result == False:
    记录日志，短信发送失败...
</code></pre>
<p><strong>2、参数</strong></p>
<p>为什么要有参数？</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>def CPU报警邮件() #发送邮件提醒
连接邮箱服务器
发送邮件
关闭连接 def 硬盘报警邮件() #发送邮件提醒
连接邮箱服务器
发送邮件
关闭连接 def 内存报警邮件() #发送邮件提醒
连接邮箱服务器
发送邮件
关闭连接 while True： if cpu利用率 &gt; 90%:
CPU报警邮件（） if 硬盘使用空间 &gt; 90%:
硬盘报警邮件（） if 内存占用 &gt; 80%:
内存报警邮件（）</p>
<p>无参数实现</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>def 发送邮件(邮件内容) #发送邮件提醒
连接邮箱服务器
发送邮件
关闭连接 while True： if cpu利用率 &gt; 90%:
发送邮件(&ldquo;CPU报警了。&rdquo;) if 硬盘使用空间 &gt; 90%:
发送邮件(&ldquo;硬盘报警了。&rdquo;) if 内存占用 &gt; 80%:
发送邮件(&ldquo;内存报警了。&rdquo;)</p>
<p>有参数实现</p>
<p>函数的有三中不同的参数：</p>
<ul>
<li>普通参数</li>
<li>默认参数</li>
<li>动态参数</li>
</ul>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<h1 id="-定义函数">######### 定义函数</h1>
<h1 id="name-叫做函数func的形式参数简称形参">name 叫做函数func的形式参数，简称：形参</h1>
<p>def func(name): print name # ######### 执行函数 #########</p>
<h1 id="wupeiqi-叫做函数func的实际参数简称实参">&lsquo;wupeiqi&rsquo; 叫做函数func的实际参数，简称：实参</h1>
<p>func(&lsquo;wupeiqi&rsquo;)</p>
<p>普通参数</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>def func(name, age = 18): print &ldquo;%s:%s&rdquo; %(name,age) # 指定参数
func(&lsquo;wupeiqi&rsquo;, 19) # 使用默认参数
func(&lsquo;alex&rsquo;)</p>
<p>注：默认参数需要放在参数列表最后</p>
<p>默认参数</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>def func(*args): print args # 执行方式一
func(11,33,4,4454,5) # 执行方式二
li = [11,2,2,3,3,4,54]
func(*li)</p>
<p>动态参数</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>def func(**kwargs): print args # 执行方式一
func(name＝&rsquo;wupeiqi&rsquo;,age=18) # 执行方式二
li = {&rsquo;name&rsquo;:&lsquo;wupeiqi&rsquo;, age:18, &lsquo;gender&rsquo;:&lsquo;male&rsquo;}
func(**li)</p>
<p>动态参数</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>def func(*args, **kwargs): print args print kwargs</p>
<p>动态参数</p>
<p>扩展：发送邮件实例</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>import smtplib from email.mime.text import MIMEText from email.utils import formataddr</p>
<p>msg = MIMEText(&lsquo;邮件内容&rsquo;, &lsquo;plain&rsquo;, &lsquo;utf-8&rsquo;)
msg[&lsquo;From&rsquo;] = formataddr([&ldquo;武沛齐&rdquo;,&lsquo;<a href="mailto:wptawy@126.com">wptawy@126.com</a>&rsquo;])
msg[&lsquo;To&rsquo;] = formataddr([&ldquo;走人&rdquo;,&lsquo;<a href="mailto:424662508@qq.com">424662508@qq.com</a>&rsquo;])
msg[&lsquo;Subject&rsquo;] = &ldquo;主题&rdquo; server = smtplib.SMTP(&ldquo;smtp.126.com&rdquo;, 25)
server.login(&ldquo;<a href="mailto:wptawy@126.com">wptawy@126.com</a>&rdquo;, &ldquo;邮箱密码&rdquo;)
server.sendmail(&lsquo;<a href="mailto:wptawy@126.com">wptawy@126.com</a>&rsquo;, [&lsquo;<a href="mailto:424662508@qq.com">424662508@qq.com</a>&rsquo;,], msg.as_string())
server.quit()</p>
<p>发送邮件实例</p>
<h3 id="内置函数">内置函数</h3>
<p><img src="http://hugo.caizhenwei.top//425762-20160115210339553-378378117.png" alt="">　　</p>
<p>注：查看详细<a href="https://docs.python.org/3/library/functions.html#next">猛击这里</a></p>
<p><strong>open函数</strong>，该函数用于文件处理</p>
<p>操作文件时，一般需要经历如下步骤：</p>
<ul>
<li>打开文件</li>
<li>操作文件</li>
</ul>
<p><strong>一、打开文件</strong></p>
<p>文件句柄 = open(&lsquo;文件路径&rsquo;, &lsquo;模式&rsquo;)</p>
<p>打开文件时，需要指定文件路径和以何等方式打开文件，打开后，即可获取该文件句柄，日后通过此文件句柄对该文件操作。</p>
<p>打开文件的模式有：</p>
<ul>
<li>r ，只读模式【默认】</li>
<li>w，只写模式【不可读；不存在则创建；存在则清空内容；】</li>
<li>x， 只写模式【不可读；不存在则创建，存在则报错】</li>
<li>a， 追加模式【可读；   不存在则创建；存在则只追加内容；】</li>
</ul>
<p>&ldquo;+&rdquo; 表示可以同时读写某个文件</p>
<ul>
<li>r+， 读写【可读，可写】</li>
<li>w+，写读【可读，可写】</li>
<li>x+ ，写读【可读，可写】</li>
<li>a+， 写读【可读，可写】</li>
</ul>
<p> &ldquo;b&quot;表示以字节的方式操作</p>
<ul>
<li>rb  或 r+b</li>
<li>wb 或 w+b</li>
<li>xb 或 w+b</li>
<li>ab 或 a+b</li>
</ul>
<p> 注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型</p>
<p>二、操作</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>class file(object) def close(self): # real signature unknown; restored from __doc__
关闭文件 &quot;&rdquo;&quot; close() -&gt; None or (perhaps) an integer.  Close the file.</p>
<pre><code>    Sets data attribute .closed to True.  A closed file cannot be used for
    further I/O operations.  close() may be called more than once without
    error.  Some kinds of file objects (for example, opened by popen())
    may return an exit status upon closing. &quot;&quot;&quot;

def fileno(self): # real signature unknown; restored from \_\_doc\_\_
</code></pre>
<p>文件描述符 &quot;&quot;&quot; fileno() -&gt; integer &ldquo;file descriptor&rdquo;.</p>
<pre><code>    This is needed for lower-level file interfaces, such os.read(). &quot;&quot;&quot;
    return 0 def flush(self): # real signature unknown; restored from \_\_doc\_\_
</code></pre>
<p>刷新文件内部缓冲区 &quot;&quot;&quot; flush() -&gt; None.  Flush the internal I/O buffer. &quot;&quot;&quot;
pass</p>
<pre><code>def isatty(self): # real signature unknown; restored from \_\_doc\_\_
</code></pre>
<p>判断文件是否是同意tty设备 &quot;&quot;&quot; isatty() -&gt; true or false.  True if the file is connected to a tty device. &quot;&quot;&quot;
return False def next(self): # real signature unknown; restored from __doc__
获取下一行数据，不存在，则报错 &quot;&quot;&quot; x.next() -&gt; the next value, or raise StopIteration &quot;&quot;&quot;
pass</p>
<pre><code>def read(self, size=None): # real signature unknown; restored from \_\_doc\_\_
</code></pre>
<p>读取指定字节数据 &quot;&quot;&quot; read([size]) -&gt; read at most size bytes, returned as a string.</p>
<pre><code>    If the size argument is negative or omitted, read until EOF is reached.
    Notice that when in non-blocking mode, less data than what was requested
    may be returned, even if no size parameter was given. &quot;&quot;&quot;
    pass

def readinto(self): # real signature unknown; restored from \_\_doc\_\_
</code></pre>
<p>读取到缓冲区，不要用，将被遗弃 &quot;&quot;&quot; readinto() -&gt; Undocumented.  Don&rsquo;t use this; it may go away. &quot;&quot;&quot;
pass</p>
<pre><code>def readline(self, size=None): # real signature unknown; restored from \_\_doc\_\_
</code></pre>
<p>仅读取一行数据 &quot;&quot;&quot; readline([size]) -&gt; next line from the file, as a string.</p>
<pre><code>    Retain newline.  A non-negative size argument limits the maximum
    number of bytes to return (an incomplete line may be returned then).
    Return an empty string at EOF. &quot;&quot;&quot;
    pass

def readlines(self, size=None): # real signature unknown; restored from \_\_doc\_\_
</code></pre>
<p>读取所有数据，并根据换行保存值列表 &quot;&quot;&quot; readlines([size]) -&gt; list of strings, each a line from the file.</p>
<pre><code>    Call readline() repeatedly and return a list of the lines so read.
    The optional size argument, if given, is an approximate bound on the
    total number of bytes in the lines returned. &quot;&quot;&quot;
    return \[\] def seek(self, offset, whence=None): # real signature unknown; restored from \_\_doc\_\_
</code></pre>
<p>指定文件中指针位置 &quot;&quot;&quot; seek(offset[, whence]) -&gt; None.  Move to new file position.</p>
<pre><code>    Argument offset is a byte count.  Optional argument whence defaults to
</code></pre>
<p>(offset from start of file, offset should be &gt;= 0); other values are 1
(move relative to current position, positive or negative), and 2 (move
relative to end of file, usually negative, although many platforms allow
seeking beyond the end of a file).  If the file is opened in text mode,
only offsets returned by tell() are legal.  Use of other offsets causes
undefined behavior.
Note that not all file objects are seekable. &quot;&quot;&quot;
pass</p>
<pre><code>def tell(self): # real signature unknown; restored from \_\_doc\_\_
</code></pre>
<p>获取当前指针位置 &quot;&quot;&quot; tell() -&gt; current file position, an integer (may be a long integer). &quot;&quot;&quot;
pass</p>
<pre><code>def truncate(self, size=None): # real signature unknown; restored from \_\_doc\_\_
</code></pre>
<p>截断数据，仅保留指定之前数据 &quot;&quot;&quot; truncate([size]) -&gt; None.  Truncate the file to at most size bytes.</p>
<pre><code>    Size defaults to the current file position, as returned by tell(). &quot;&quot;&quot;
    pass

def write(self, p\_str): # real signature unknown; restored from \_\_doc\_\_
</code></pre>
<p>写内容 &quot;&quot;&quot; write(str) -&gt; None.  Write string str to file.</p>
<pre><code>    Note that due to buffering, flush() or close() may be needed before
    the file on disk reflects the data written. &quot;&quot;&quot;
    pass

def writelines(self, sequence\_of\_strings): # real signature unknown; restored from \_\_doc\_\_
</code></pre>
<p>将一个字符串列表写入文件 &quot;&quot;&quot; writelines(sequence_of_strings) -&gt; None.  Write the strings to the file.</p>
<pre><code>    Note that newlines are not added.  The sequence can be any iterable object
    producing strings. This is equivalent to calling write() for each string. &quot;&quot;&quot;
    pass

def xreadlines(self): # real signature unknown; restored from \_\_doc\_\_
</code></pre>
<p>可用于逐行读取文件，非全部 &quot;&quot;&quot; xreadlines() -&gt; returns self.</p>
<pre><code>    For backward compatibility. File objects now include the performance
    optimizations previously implemented in the xreadlines module. &quot;&quot;&quot;
    pass
</code></pre>
<p>2.x</p>
<p><img src="images/ContractedBlock.gif" alt=""><img src="http://hugo.caizhenwei.top//ExpandedBlockStart.gif" alt=""></p>
<p>class TextIOWrapper(_TextIOBase): &quot;&quot;&quot; Character and line based layer over a BufferedIOBase object, buffer.</p>
<pre><code>encoding gives the name of the encoding that the stream will be
decoded or encoded with. It defaults to locale.getpreferredencoding(False).

errors determines the strictness of encoding and decoding (see
help(codecs.Codec) or the documentation for codecs.register) and
defaults to &quot;strict&quot;.

newline controls how line endings are handled. It can be None, '',
'\\n', '\\r', and '\\r\\n'.  It works as follows:

\* On input, if newline is None, universal newlines mode is
  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and
  these are translated into '\\n' before being returned to the
  caller. If it is '', universal newline mode is enabled, but line
  endings are returned to the caller untranslated. If it has any of
  the other legal values, input lines are only terminated by the given
  string, and the line ending is returned to the caller untranslated.

\* On output, if newline is None, any '\\n' characters written are
  translated to the system default line separator, os.linesep. If
  newline is '' or '\\n', no translation takes place. If newline is any
  of the other legal values, any '\\n' characters written are translated
  to the given string.

If line\_buffering is True, a call to flush is implied when a call to
write contains a newline character. &quot;&quot;&quot;
def close(self, \*args, \*\*kwargs): # real signature unknown
</code></pre>
<p>关闭文件 pass</p>
<pre><code>def fileno(self, \*args, \*\*kwargs): # real signature unknown
</code></pre>
<p>文件描述符 pass</p>
<pre><code>def flush(self, \*args, \*\*kwargs): # real signature unknown
</code></pre>
<p>刷新文件内部缓冲区 pass</p>
<pre><code>def isatty(self, \*args, \*\*kwargs): # real signature unknown
</code></pre>
<p>判断文件是否是同意tty设备 pass</p>
<pre><code>def read(self, \*args, \*\*kwargs): # real signature unknown
</code></pre>
<p>读取指定字节数据 pass</p>
<pre><code>def readable(self, \*args, \*\*kwargs): # real signature unknown
</code></pre>
<p>是否可读 pass</p>
<pre><code>def readline(self, \*args, \*\*kwargs): # real signature unknown
</code></pre>
<p>仅读取一行数据 pass</p>
<pre><code>def seek(self, \*args, \*\*kwargs): # real signature unknown
</code></pre>
<p>指定文件中指针位置 pass</p>
<pre><code>def seekable(self, \*args, \*\*kwargs): # real signature unknown
</code></pre>
<p>指针是否可操作 pass</p>
<pre><code>def tell(self, \*args, \*\*kwargs): # real signature unknown
</code></pre>
<p>获取指针位置 pass</p>
<pre><code>def truncate(self, \*args, \*\*kwargs): # real signature unknown
</code></pre>
<p>截断数据，仅保留指定之前数据 pass</p>
<pre><code>def writable(self, \*args, \*\*kwargs): # real signature unknown
</code></pre>
<p>是否可写 pass</p>
<pre><code>def write(self, \*args, \*\*kwargs): # real signature unknown
</code></pre>
<p>写内容 pass</p>
<pre><code>def \_\_getstate\_\_(self, \*args, \*\*kwargs): # real signature unknown
    pass

def \_\_init\_\_(self, \*args, \*\*kwargs): # real signature unknown
    pass @staticmethod # known case of \_\_new\_\_
def \_\_new\_\_(\*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot; Create and return a new object.  See help(type) for accurate signature. &quot;&quot;&quot;
    pass

def \_\_next\_\_(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot; Implement next(self). &quot;&quot;&quot;
    pass

def \_\_repr\_\_(self, \*args, \*\*kwargs): # real signature unknown
    &quot;&quot;&quot; Return repr(self). &quot;&quot;&quot;
    pass buffer \= property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
</code></pre>
<p>closed = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
encoding = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
errors = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
line_buffering = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
name = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
newlines = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
_CHUNK_SIZE = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
_finalizing = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default</p>
<p>3.x</p>
<p><strong>三、管理上下文</strong></p>
<p>为了避免打开文件后忘记关闭，可以通过管理上下文，即：</p>
<p>with open(&rsquo;log&rsquo;,&lsquo;r&rsquo;) as f:</p>
<pre><code>...
</code></pre>
<p>如此方式，当with代码块执行完毕时，内部会自动关闭并释放文件资源。</p>
<p>在Python 2.7 及以后，with又支持同时对多个文件的上下文进行管理，即：</p>
<p>with open(&rsquo;log1&rsquo;) as obj1, open(&rsquo;log2&rsquo;) as obj2:
pass</p>
<h3 id="lambda表达式">lambda表达式</h3>
<p>学习条件运算时，对于简单的 if else 语句，可以使用三元运算来表示，即：</p>
<p># 普通条件语句
if 1 == 1:
name = &lsquo;wupeiqi&rsquo;
else:
name = &lsquo;alex&rsquo;</p>
<h1 id="三元运算-1">三元运算</h1>
<p>name = &lsquo;wupeiqi&rsquo; if 1 == 1 else &lsquo;alex&rsquo;</p>
<p>对于简单的函数，也存在一种简便的表示方式，即：lambda表达式</p>
<p># ###################### 普通函数 ######################</p>
<h1 id="定义函数普通方式">定义函数（普通方式）</h1>
<p>def func(arg):
return arg + 1</p>
<h1 id="执行函数">执行函数</h1>
<p>result = func(123)</p>
<h1 id="-lambda">###################### lambda</h1>
<h1 id="定义函数lambda表达式">定义函数（lambda表达式）</h1>
<p>my_lambda = lambda arg : arg + 1</p>
<h1 id="执行函数-1">执行函数</h1>
<p>result = my_lambda(123)</p>
<h3 id="递归">递归</h3>
<p>利用函数编写如下数列：</p>
<p>斐波那契数列指的是这样一个数列 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368&hellip;</p>
<p>def func(arg1,arg2):
if arg1 == 0:
print arg1, arg2
arg3 = arg1 + arg2
print arg3
func(arg2, arg3)</p>
<p>func(0,1)</p>
<h3 id="练习题">练习题</h3>
<p>1、简述普通参数、指定参数、默认参数、动态参数的区别</p>
<p>2、写函数，计算传入字符串中【数字】、【字母】、【空格] 以及 【其他】的个数</p>
<p>3、写函数，判断用户传入的对象（字符串、列表、元组）长度是否大于5。</p>
<p>4、写函数，检查用户传入的对象（字符串、列表、元组）的每一个元素是否含有空内容。</p>
<p>5、写函数，检查传入列表的长度，如果大于2，那么仅保留前两个长度的内容，并将新内容返回给调用者。</p>
<p>6、写函数，检查获取传入列表或元组对象的所有奇数位索引对应的元素，并将其作为新列表返回给调用者。</p>
<p>7、写函数，检查传入字典的每一个value的长度,如果大于2，那么仅保留前两个长度的内容，并将新内容返回给调用者。</p>
<p>dic = {&ldquo;k1&rdquo;: &ldquo;v1v1&rdquo;, &ldquo;k2&rdquo;: [11,22,33,44]}</p>
<p>PS:字典中的value只能是字符串或列表</p>
<p>8、写函数，利用递归获取斐波那契数列中的第 10 个数，并将该值返回给调用者。</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
