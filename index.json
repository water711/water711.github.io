[{"categories":["other"],"contents":"在做图形渲染的时候，想了解GPU的使用情况，但是win7的任务管理器没有GPU的信息，还好NVIDIA提供了相关的命令\n进入cmd命令行\ncd C:\\Program Files\\NVIDIA Corporation\\NVSMI #如果该目录加入了环境变量，可忽略 nvidia-smi.exe -h 查看帮助 nvidia-smi.exe -l 3 查看GPU使用率，每3秒刷新一次\n","permalink":"https://water711.github.io/posts/2021-05-29-win7%E4%B8%8B%E6%9F%A5%E7%9C%8Bnvidia%E6%98%BE%E5%8D%A1%E7%9A%84gpu%E4%BD%BF%E7%94%A8%E7%8E%87/","tags":null,"title":"Win7下查看NVIDIA显卡的GPU使用率"},{"categories":["python"],"contents":"一、安装 安装 pip3 install jupyter notebook\n运行 jupyter notebook\n浏览器访问 http://localhost:8888/undefined/tree\n二、配置远程访问 1、生成配置文件\njupyter notebook \u0026ndash;generate-config #运行后输出：Writing default config to: C:\\Users\\administrator\\.jupyter\\jupyter_notebook_config.py\n2、设置密码\njupyter notebook password\n3、修改配置文件\nC:\\Users\\administrator\\.jupyter\\jupyter_notebook_config.py\n把前面的#号注释去掉 c.NotebookApp.ip = \u0026lsquo;*\u0026rsquo; #允许所有ip访问，如报错 No address associated with hostname可设置为:\u0026lsquo;0.0.0.0\u0026rsquo; c.NotebookApp.open_browser = False #不打开浏览器 c.NotebookApp.port = 8888 #端口为8888\n4、本机运行服务\njupyter notebook\n5、局域网电脑浏览器访问\nhttp://IP:8888/undefined/tree\n","permalink":"https://water711.github.io/posts/2021-05-13-%E5%AE%89%E8%A3%85jupyter-notebook%E5%B9%B6%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/","tags":null,"title":"安装Jupyter Notebook并配置远程登录"},{"categories":["linux"],"contents":"1、安装 x11vnc apt install x11vnc -y\n2、生成密码文件 x11vnc -storepasswd 123456 /etc/x11vnc.pass\n参数说明： -storepasswd：指定一个密码 /etc/x11vnc.pass：保存的路径（任意）\n3、新建systemd 配置_文件_ vim /lib/systemd/system/x11vnc.service\n[Unit] Description=Start x11vnc at startup After=multi-user.target [Service] Type=simple ExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /etc/x11vnc.pass -rfbport 5900 -shared -capslock -nomodtweak [Install] WantedBy=multi-user.target\nExecStart 启动命令中，指定刚刚生成的 密码文件 和 端口\n4、启动VNC服务 systemctl enable x11vnc.service systemctl restart x11vnc.service netstat -tunlp | grep 5900\n","permalink":"https://water711.github.io/posts/2021-04-26-kali2021%E5%AE%89%E8%A3%85vnc/","tags":null,"title":"Kali2021安装VNC"},{"categories":["python"],"contents":" 一、安装pyaudio软件包 1、下载whl文件\nhttps://github.com/intxcc/pyaudio_portaudio/releases\n2、安装pyaudio\npip install PyAudio-0.2.11-cp37-cp37m-win_amd64.whl\n二、代码文件 import wave from pyaudio import PyAudio,paInt16 from datetime import datetime\nframerate=16000 NUM_SAMPLES=2000 channels=1 sampwidth=2 TIME=300 #每次录制秒数 count=12 #录制多少次\ndef save_wave_file(filename,data): \u0026lsquo;\u0026lsquo;\u0026lsquo;save the data to the wavfile\u0026rsquo;\u0026rsquo;\u0026rsquo; wf=wave.open(filename,\u0026lsquo;wb\u0026rsquo;) wf.setnchannels(channels) wf.setsampwidth(sampwidth) wf.setframerate(framerate) wf.writeframes(b\u0026quot;\u0026quot;.join(data)) wf.close()\ndef my_record(): file_name = datetime.now().strftime(\u0026quot;%Y%m%d_%H%M%S\u0026quot;) + \u0026lsquo;.wav\u0026rsquo; pa=PyAudio() stream=pa.open(format = paInt16,channels=1, rate=framerate,input=True, frames_per_buffer=NUM_SAMPLES) my_buf=[] count=0 while count\u0026lt;TIME*8:#控制录音时间 string_audio_data = stream.read(NUM_SAMPLES) my_buf.append(string_audio_data) count+=1 #print(\u0026rsquo;.\u0026rsquo;) save_wave_file(file_name,my_buf) stream.close()\nif __name__ == \u0026lsquo;__main__\u0026rsquo;: for i in range(count): my_record()\n三、打包为exe可执行程序 #安装pyinstaller软件包 pip install pyinstaller\n#打包成exe pyinstaller -F test.py\n#打包成exe并自定义图标(图标放在程序所在目录) pyinstaller -F \u0026ndash;icon=my.ico test.py\n参考原文：https://blog.ailemon.me/2019/08/13/python-implement-audio-recorder-and-player/\n","permalink":"https://water711.github.io/posts/2021-04-26-python%E5%AE%9E%E7%8E%B0%E5%BD%95%E9%9F%B3%E5%8A%9F%E8%83%BD/","tags":null,"title":"Python实现录音功能"},{"categories":["nas"],"contents":" 一、使用docker安装 docker hub仓库地址：https://hub.docker.com/r/linuxserver/transmission\n1、下载镜像\ndocker pull linuxserver/transmission\n2、运行容器\ndocker run -d \\ \u0026ndash;name=transmission \\ -e PUID=1000 \\ -e PGID=1000 \\ -e TZ=Asia/Shanghai \\ -e TRANSMISSION_WEB_HOME=/transmission-web-control/ `#optional` \\ -e USER=username `#optional` \\ -e PASS=password `#optional` \\ -p 9091:9091 \\ -p 51413:51413 \\ -p 51413:51413/udp \\ -v /mnt/transmission/config:/config \\ -v /mnt/transmission/downloads:/downloads \\ -v /mnt/transmission/watch:/watch \\ \u0026ndash;restart unless-stopped \\ linuxserver/transmission\n3、配置文件地址\nvim /mnt/transmission/config/settings.json\n二、使用yum安装 1、安装\nyum -y install epel-release yum install tranmission transmission-daemon systemctl start transmission-daemon.service systemctl enable transmission-daemon.service\n2、配置文件地址\nsystemctl stop transmission-daemon.service\nvi /var/lib/transmission/.config/transmission-daemon/settings.json \u0026ldquo;rpc-whitelist\u0026rdquo;: \u0026ldquo;127.0.0.1\u0026rdquo;, #设置允许访问的IP \u0026ldquo;rpc-whitelist-enabled\u0026rdquo;: false, #或者关闭白名单\n注意：如果安装后没有启动过Transmission，是不会生成配置文件。因而，需要先启动服务，再停止服务，生成json配置文件后再进行配置。\n如果用浏览器打开web端，提示“403: Forbidden”，则需要关闭白名单或指定允许访问的IP地址\n三、配置文件参数说明 官方文档：https://github.com/transmission/transmission/wiki/Editing-Configuration-Files\n{ \u0026ldquo;alt-speed-down\u0026rdquo;: 50, \u0026ldquo;alt-speed-enabled\u0026rdquo;: false, \u0026ldquo;alt-speed-time-begin\u0026rdquo;: 540, \u0026ldquo;alt-speed-time-day\u0026rdquo;: 127, \u0026ldquo;alt-speed-time-enabled\u0026rdquo;: false, \u0026ldquo;alt-speed-time-end\u0026rdquo;: 1020, \u0026ldquo;alt-speed-up\u0026rdquo;: 50, \u0026ldquo;bind-address-ipv4\u0026rdquo;: \u0026ldquo;0.0.0.0\u0026rdquo;, \u0026ldquo;bind-address-ipv6\u0026rdquo;: \u0026ldquo;::\u0026rdquo;, \u0026ldquo;blocklist-enabled\u0026rdquo;: false, \u0026ldquo;blocklist-url\u0026rdquo;: \u0026ldquo;http://www.example.com/blocklist\u0026quot;, \u0026ldquo;cache-size-mb\u0026rdquo;: 4, \u0026ldquo;dht-enabled\u0026rdquo;: true, \u0026ldquo;download-dir\u0026rdquo;: \u0026ldquo;/var/lib/transmission/Downloads\u0026rdquo;, #下载目录，修改后要将目录所有者/组设置为transmission \u0026ldquo;download-queue-enabled\u0026rdquo;: true, \u0026ldquo;download-queue-size\u0026rdquo;: 5, \u0026ldquo;encryption\u0026rdquo;: 1, \u0026ldquo;idle-seeding-limit\u0026rdquo;: 30, \u0026ldquo;idle-seeding-limit-enabled\u0026rdquo;: false, \u0026ldquo;incomplete-dir\u0026rdquo;: \u0026ldquo;/var/lib/transmission/Downloads\u0026rdquo;, #未完成任务存放目录 \u0026ldquo;incomplete-dir-enabled\u0026rdquo;: false, #是否启用未完成任务目录 \u0026ldquo;lpd-enabled\u0026rdquo;: false, \u0026ldquo;message-level\u0026rdquo;: 1, \u0026ldquo;peer-congestion-algorithm\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;peer-id-ttl-hours\u0026rdquo;: 6, \u0026ldquo;peer-limit-global\u0026rdquo;: 200, \u0026ldquo;peer-limit-per-torrent\u0026rdquo;: 50, \u0026ldquo;peer-port\u0026rdquo;: 51413, \u0026ldquo;peer-port-random-high\u0026rdquo;: 65535, \u0026ldquo;peer-port-random-low\u0026rdquo;: 49152, \u0026ldquo;peer-port-random-on-start\u0026rdquo;: false, \u0026ldquo;peer-socket-tos\u0026rdquo;: \u0026ldquo;default\u0026rdquo;, \u0026ldquo;pex-enabled\u0026rdquo;: true, \u0026ldquo;port-forwarding-enabled\u0026rdquo;: true, \u0026ldquo;preallocation\u0026rdquo;: 1, \u0026ldquo;prefetch-enabled\u0026rdquo;: true, \u0026ldquo;queue-stalled-enabled\u0026rdquo;: true, \u0026ldquo;queue-stalled-minutes\u0026rdquo;: 30, \u0026ldquo;ratio-limit\u0026rdquo;: 2, \u0026ldquo;ratio-limit-enabled\u0026rdquo;: false, \u0026ldquo;rename-partial-files\u0026rdquo;: true, \u0026ldquo;rpc-authentication-required\u0026rdquo;: false, #开启账号密码登录认证 \u0026ldquo;rpc-bind-address\u0026rdquo;: \u0026ldquo;0.0.0.0\u0026rdquo;, \u0026ldquo;rpc-enabled\u0026rdquo;: true, \u0026ldquo;rpc-host-whitelist\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;rpc-host-whitelist-enabled\u0026rdquo;: true, \u0026ldquo;rpc-password\u0026rdquo;: \u0026ldquo;{f2d424f54eb3112495bbdb850347b95d26537cebA3wmy4o7\u0026rdquo;, #设置登录密码 \u0026ldquo;rpc-port\u0026rdquo;: 9091, \u0026ldquo;rpc-url\u0026rdquo;: \u0026ldquo;/transmission/\u0026rdquo;, \u0026ldquo;rpc-username\u0026rdquo;: \u0026ldquo;\u0026rdquo;, #设置登录账号 \u0026ldquo;rpc-whitelist\u0026rdquo;: \u0026ldquo;127.0.0.1\u0026rdquo;, \u0026ldquo;rpc-whitelist-enabled\u0026rdquo;: true, \u0026ldquo;scrape-paused-torrents-enabled\u0026rdquo;: true, \u0026ldquo;script-torrent-done-enabled\u0026rdquo;: false, \u0026ldquo;script-torrent-done-filename\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;seed-queue-enabled\u0026rdquo;: false, \u0026ldquo;seed-queue-size\u0026rdquo;: 10, \u0026ldquo;speed-limit-down\u0026rdquo;: 100, \u0026ldquo;speed-limit-down-enabled\u0026rdquo;: false, \u0026ldquo;speed-limit-up\u0026rdquo;: 100, \u0026ldquo;speed-limit-up-enabled\u0026rdquo;: false, \u0026ldquo;start-added-torrents\u0026rdquo;: true, \u0026ldquo;trash-original-torrent-files\u0026rdquo;: false, \u0026ldquo;umask\u0026rdquo;: 18, \u0026ldquo;upload-slots-per-torrent\u0026rdquo;: 14, \u0026ldquo;utp-enabled\u0026rdquo;: true }\n","permalink":"https://water711.github.io/posts/2021-04-05-centos7%E5%AE%89%E8%A3%85transmission/","tags":null,"title":"centos7安装transmission"},{"categories":["linux","nas"],"contents":"使用 Docker 镜像快速搭建 IPsec VPN 服务器。支持 IPsec/L2TP，Cisco IPsec 和 IKEv2 协议。\n作者github地址：https://github.com/hwdsl2/docker-ipsec-vpn-server/blob/master/README-zh.md\n一、下载镜像并运行 docker run \\ \u0026ndash;name ipsec-vpn-server \\ \u0026ndash;restart=always \\ -v ikev2-vpn-data:/etc/ipsec.d \\ -v /lib/modules:/lib/modules:ro \\ -p 500:500/udp \\ -p 4500:4500/udp \\ -d \u0026ndash;privileged \\ hwdsl2/ipsec-vpn-server\n二、获取 VPN 登录信息 docker logs ipsec-vpn-server\n在命令输出中查找下面这些行：\nServer IP: 你的VPN服务器IP IPsec PSK: 你的IPsec预共享密钥 Username: 你的VPN用户名 Password: 你的VPN密码\n三、配置 IPsec/L2TP VPN 客户端 https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/docs/clients-zh.md\n四、取消所有流量走VPN 1、禁止PPTP、L2TP 修改本机缺省路由\n点击桌面右下角网络图标，右键点击VPN，选择属性，点击网络-》属性-》高级-》取消“在远程网络上使用默认网关”\n设置后重新连接VPN\n2、设置静态路由，用于访问VPN内网\nroute add 192.168.100.0 mask 255.255.255.0 192.168.42.1\n","permalink":"https://water711.github.io/posts/2021-04-04-%E4%BD%BF%E7%94%A8docker%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAl2tp%E6%9C%8D%E5%8A%A1%E5%99%A8/","tags":null,"title":"使用docker快速搭建L2TP服务器"},{"categories":["linux"],"contents":"很多时候写了定时任务却发现没有执行，或者执行失败，但因为crond是后台运行的，有没有任何提示，很难进行排错。但是可以让crond运行在前端并进行调试的。\ncrond是允许接受选项的\ncrond [-n] [-P] [-x flags] 选项说明： -n：让crond以前端方式运行，即不依赖于终端。 -P：不重设环境变量PATH，而是从父进程中继承。 -x：设置调试项，flags是调试方式，比较有用的方式是test和sch，即\u0026quot;-x test\u0026quot;和\u0026quot;-x sch\u0026quot;。 ：其中test调试将不会真正的执行，sch调试显示调度信息，可以看到等待时间。具体的见下面的示例。\n执行crond并带上调试选项test。\n[root@nas ~]# crond -x test debug flags enabled: test crond: can\u0026rsquo;t lock /var/run/crond.pid, otherpid may be 19023: Resource temporarily unavailable log_it: (CRON 4743) DEATH (can\u0026rsquo;t lock /var/run/crond.pid, otherpid may be 19023): Resource temporarily unavailable\n提示 can't lock /var/run/crond.pid ，处理方法：rm -rf /var/run/crond.pid\ncrond调试正常显示如下：\n[root@server2 ~]# crond -x test debug flags enabled: test [4903] cron started log_it: (CRON 4903) INFO (RANDOM_DELAY will be scaled with factor 8% if used.) log_it: (CRON 4903) INFO (running with inotify support) log_it: (CRON 4903) INFO (@reboot jobs will be run at computer\u0026rsquo;s startup.) log_it: (root 4905) CMD (echo \u0026ldquo;hello world\u0026rdquo; \u0026raquo;/tmp/hello.t\n参考自**：https://www.cnblogs.com/f-ck-need-u/p/7059418.html**\n","permalink":"https://water711.github.io/posts/2021-03-24-crond%E4%BB%BB%E5%8A%A1%E6%B2%A1%E6%9C%89%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/","tags":null,"title":"crond任务没有正常执行的排查方法"},{"categories":["other"],"contents":" .vhdx是从Windows server 2012起引入的一种磁盘格式，是.vhd的升级版。与后者相比，vhdx格式的虚拟硬盘可以更好地保护数据，避免突然断电造成的数据损坏。\n在已经开启了hyper-v的电脑上进行镜像转换： 1、以管理员权限打开powershell\nConvert-VHD –Path hyper镜像路径 –DestinationPath 转换成镜像路径\n例如： Convert-VHD -Path c:\\Ubuntu.vhdx -DestinationPath d:\\Ubuntu_vhd.vhd\nPS：注意两个路径都要带后缀，文件名中如果存在空格则需要使用单引号括起来。\n2、转换完成后，用VirtualBox新建虚拟机（不创建硬盘），并加载转换后的硬盘镜像，启动\n","permalink":"https://water711.github.io/posts/2021-03-20-hyper-v%E7%9A%84vhdx%E6%A0%BC%E5%BC%8F%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F%E8%BD%AC%E6%8D%A2%E4%B8%BAvirtualbox%E6%94%AF%E6%8C%81%E7%9A%84vhd%E6%A0%BC%E5%BC%8F/","tags":null,"title":"Hyper-V的vhdx格式磁盘镜像转换为VirtualBox支持的vhd格式"},{"categories":["linux","nas"],"contents":" 一、下载解压运行 各平台clash安装包链接：https://github.com/Dreamacro/clash/releases\nmkdir clash #创建目录 cd clash #进入目录 wget http://xxxxxxclash-linux-amd64-v1.3.5.gz #下载clash gunzip clash-linux-amd64-v1.3.5.gz #解压 mv clash-linux-amd64-v1.3.5 clash #重命名 chmod +x clash #添加可执行权限\n./clash #前台运行clash INFO[0000] Can\u0026rsquo;t find config, create a initial config file INFO[0000] Can\u0026rsquo;t find MMDB, start download INFO[0205] HTTP proxy listening at: 127.0.0.1:7890\n第一次启动会在用户目录下 ~/.config/clash 自动生成Config.yaml 和Country.mmdb两个文件\n生成的Config.yaml文件只一行 port: 7890，需要后续配置自己的代理信息\n二、关于配置文件 有些机场商家会提供相应的yaml文件，复制进clash配置文件目录即可，如果提供的文件类型为yml类型，直接修改为yaml类型即可\n如运行clash时，出现“FATA[0000] Parse config error: yaml: unmarshal errors”，则需要转换订阅为clash，再重新下载配置\ncd ~/.config/clash wget -O config.yaml http://xxxx.com/link/f?clash=1\u0026amp;log-level=info\n./clash #前台运行 INFO[0000] Start initial compatible provider Proxy INFO[0000] Start initial compatible provider Domestic\nINFO[0000] Start initial compatible provider AsianTV INFO[0000] Start initial compatible provider Others INFO[0000] Start initial compatible provider GlobalTV\nnohup ./clash \u0026amp; #后台运行\n三、策略组设置 浏览器访问：http://clash.razord.top ，输入IP，端口默认为9090\n密钥默认为空，可在配置文件添加密钥\nvim ~/.config/clash/config.yaml Clash 的 RESTful API external-controller: \u0026lsquo;0.0.0.0:9090\u0026rsquo;\nRESTful API 的口令 secret: \u0026lsquo;123456\u0026rsquo;\n登录后可查看所有代理和相关规则设置\n四、使用代理 # HTTP 代理端口 port: 7890\nSOCKS5 代理端口 socks-port: 7891\ncurl使用代理\n# 指定http代理IP和端口 curl -x 127.0.0.1:7890 http://www.google.com #本机使用代理 curl -x 192.168.100.22:7890 http://www.google.com #局域网内指定代理服务器IP使用\nwget使用代理\nwget -e \u0026ldquo;http_proxy=192.168.100.22:7890\u0026rdquo; http://www.google.com #http代理 wget -e \u0026ldquo;https_proxy=192.168.100.22:7890\u0026rdquo; https://www.google.com #https代理\n浏览器添加代理\nHTTP代理：192.168.100.22:7890 Socks主机：192.168.100.22:7891\ndocker容器使用宿主机代理\nip a #查看docker0虚拟网卡IP地址,我这里是172.17.0.1 sudo docker exec -it 容器名 /bin/bash #进入容器\n#在容器内ping docker0 IP地址，如果能通，则使用该地址做为代理服务器地址\nping 172.17.0.1 curl -x 172.17.0.1:7890 http://www.google.com\n在环境变量中设置代理(curl和wget可用)\nexport http_proxy=http://192.168.100.22:7890 export https_proxy=http://192.168.100.22:7890\n","permalink":"https://water711.github.io/posts/2021-02-15-linux%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8clash%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/","tags":null,"title":"Linux安装使用clash网络代理工具"},{"categories":["other"],"contents":" 一、创建TG机器人 1、打开botfather聊天窗口\n手机端：打开TG，点击底部Chats，上方搜索 @botfather ，进行聊天窗口，点击Start\n电脑端：https://telegram.me/BotFather\n2、发送/newbot命令，创建一个机器人\n3、为机器人设置一个呢称，\n4、为机器人设置用户名，以 _bot 结尾，例如： tom_bot\n5、记下botfather机器人发过来的token\n二、获取Chat_id（聊天ID） 1、获取自己的Chat_id：搜索@getidsbot，发送 /start 获取\n2、获取群组的Chat_id：\na、将机器人加入到组中\nb、发送任意带斜杆的消息到组中，例如：/hello\nc、获取机器人的更新列表：\nhttps://api.telegram.org/bot这里填入机器人token/getUpdates\nd、在返回的json中，寻找群组的Chat_id，title为组名\n\u0026quot;ok\u0026quot;: true, \u0026quot;result\u0026quot;: \\[ ...... \u0026quot;chat\u0026quot;: { \u0026quot;id\u0026quot;: -524790023, \u0026quot;title\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;group\u0026quot;, \u0026quot;all\\_members\\_are\\_administrators\u0026quot;: true }, \u0026quot;date\u0026quot;: 1613358222, \u0026quot;text\u0026quot;: \u0026quot;/hello\u0026quot;, 三、将机器人或群组设为Unmute（取消静音） 1、打开telegram，点击底部Chats\n2、找到机器人或群组，左划，点击Unmute\n四、发送通知 在浏览器中发送\nhttps://api.telegram.org/bot这里填入机器人token/sendMessage?chat_id=这里填入聊天ID\u0026amp;text=这里填写要发送的消息内容\n在Linux中发送\ncurl -X POST \u0026ldquo;https://api.telegram.org/bot这里填入机器人token/sendMessage\u0026rdquo; -d \u0026ldquo;chat_id=这里填入聊天ID\u0026amp;text=这里填写要发送的消息内容\u0026rdquo;\n","permalink":"https://water711.github.io/posts/2021-02-15-%E9%80%9A%E8%BF%87tg%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5%E5%88%B0%E6%89%8B%E6%9C%BA/","tags":null,"title":"通过TG机器人发送通知到手机"},{"categories":["other"],"contents":" 一、新建谷歌脚本 1、打开Google Apps Script，点击Start Scripting，新建项目\nhttps://www.google.com/script/start/\n2、粘贴以下代码，并修改机器人token（api.telegram.org/bot后面这串字符）\nfunction doGet(e){ return HtmlService.createHtmlOutput(\u0026ldquo;Hello World!! No, this link should be hidden!!!\u0026rdquo;); }\nfunction doPost(e){ var dataFromTelegram = { \u0026ldquo;method\u0026rdquo;: \u0026ldquo;post\u0026rdquo;, \u0026ldquo;payload\u0026rdquo;: e.postData.contents } var body = JSON.parse(e.postData.contents);\nbody.message.chat.id = body.message.chat.id + \u0026lsquo;\u0026rsquo;;\nvar payload = preparePayload(body); var data = { \u0026ldquo;method\u0026rdquo;: \u0026ldquo;post\u0026rdquo;, \u0026ldquo;payload\u0026rdquo;: payload }\nvar dataToTelegram = { \u0026ldquo;method\u0026rdquo;: \u0026ldquo;post\u0026rdquo;, \u0026ldquo;payload\u0026rdquo;: payload }\nUrlFetchApp.fetch(\u0026ldquo;https://api.telegram.org/bot15234456452:AAFMK1UtlJk82pweww2a3gPcu-4YbfE/\u0026quot;, data); } function preparePayload(body){ var payload;\nif (body.message.text){ payload = { \u0026ldquo;method\u0026rdquo;: \u0026ldquo;sendMessage\u0026rdquo;, \u0026ldquo;chat_id\u0026rdquo;: body.message.chat.id, \u0026ldquo;text\u0026rdquo;: body.message.text, }\n} else if (body.message.sticker){ payload = { \u0026ldquo;method\u0026rdquo;: \u0026ldquo;sendSticker\u0026rdquo;, \u0026ldquo;chat_id\u0026rdquo;: body.message.chat.id, \u0026ldquo;sticker\u0026rdquo;: body.message.sticker.file_id } } else if (body.message.photo){ array = body.message.photo; text = array[1]; payload = { \u0026ldquo;method\u0026rdquo;: \u0026ldquo;sendPhoto\u0026rdquo;, \u0026ldquo;chat_id\u0026rdquo;: body.message.chat.id, \u0026ldquo;photo\u0026rdquo;: text.file_id } } else { payload = { \u0026ldquo;method\u0026rdquo;: \u0026ldquo;sendMessage\u0026rdquo;, \u0026ldquo;chat_id\u0026rdquo;: body.message.chat.id, \u0026ldquo;text\u0026rdquo;: \u0026ldquo;Try other stuff\u0026rdquo; } } return payload }\n二、发布应用 1、点击菜单栏“发布”-》“部署为网络应用”\n2、Who has access to the app，选择 Anyone,even anonymous，再点击Deploy\n3、点击查看权限\n4、选择允许\n三、将机器人连接到google脚本上 1、点击菜单栏“发布”-》“部署为网络应用”，复制应用链接\n2、打开url编码页面，将应用链接进行编码\nhttp://tool.chinaz.com/tools/urlencode.aspx\n3、将编码后的链接和机器人teken替换到下方链接\nhttps://api.telegram.org/bot这里放机器人的token/setWebhook?url=这里放编码后的谷歌应用链接\n4、使用浏览器打开上方链接，出现下图结果则配置成功\n5、打开Telegram机器人聊天窗口，发送消息测试\n视频链接：https://www.youtube.com/watch?v=SxwsGWlMfP4\u0026amp;t=70s\n","permalink":"https://water711.github.io/posts/2021-02-10-telegram%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%A4%8D%E8%AF%BB%E5%8A%9F%E8%83%BD/","tags":null,"title":"Telegram机器人编程，实现复读功能"},{"categories":["linux","nas"],"contents":"NAS操作系统：Centos7\n实现原理：通过访问网页，执行含有shell命令的php代码\n1、安装apache和php yum install -y httpd php\n2、启动apache、关闭selinux systemctl start httpd systemctl enable httpd\n#临时关闭selinux setenforce 0\n#永久关闭selinux vim /etc/selinux/config SELINUX=disabled\n3、修改Web端口和目录（可选） vim /etc/httpd/conf/httpd.conf Listen 1234 \u0026hellip; DocumentRoot \u0026ldquo;/mnt/html\u0026rdquo; \u0026hellip;. \u0026lt;Directory \u0026ldquo;/mnt/html\u0026rdquo;\u0026gt; systemctl restart httpd\n4、测试 vim /mnt/html/test.php 浏览器运行：http:IP:端口/test.php\n5、为apache用户提权 apache用户权限非常低，大部分命令仍然不能运行\nvim /etc/sudoers root ALL=(ALL) ALL apache ALL=(ALL) NOPASSWD:ALL #添加这一行 6、测试 vim /mnt/html/test1.php 7、网站安全配置，只允许指定IP访问 vim /etc/httpd/conf/httpd.conf \u0026lt;Directory \u0026ldquo;/mnt/html\u0026rdquo;\u0026gt; AllowOverride None Require all granted Deny From all Allow From 127.0.0.1 10.0.0.3 #只允许指定IP访问 8、手机端收藏网页，发送到桌面 ","permalink":"https://water711.github.io/posts/2021-02-10-%E6%89%8B%E6%9C%BA%E7%AB%AF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%8F%91%E9%80%81%E5%91%BD%E4%BB%A4%E5%88%B0nas%E4%B8%BB%E6%9C%BA/","tags":null,"title":"手机端实现一键发送命令到NAS主机"},{"categories":["linux","nas"],"contents":"官网/安装文档： https://www.portainer.io/\nhttps://www.portainer.io/installation/\nhttps://portainer.readthedocs.io/en/stable/deployment.html\nPortainer是Docker的可视化管理工具，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm集群和服务等集中管理和操作、登录用户管理和控制等功能。\n一、拉取portainer镜像 docker pull portainer/portainer\n二、启动portainer docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /mnt/portainer:/data \u0026ndash;name portainer \u0026ndash;restart=always portainer/portainer\n三、浏览器访问 http://服务器IP地址:9000\n1、设置密码\n2、选择Local，连接本地主机docker\n3、查看本地所有容器\n4、查看容器的日志、inspect、占用的硬件资源、执行命令\n","permalink":"https://water711.github.io/posts/2021-02-09-docker%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7-portainer%E5%AE%89%E8%A3%85/","tags":null,"title":"Docker可视化工具--Portainer安装"},{"categories":["linux","nas"],"contents":"1、安装软件包 yum -y install samba\n2、建立访问用户 useradd test smbpasswd -a test\n3、配置samba共享 [data] path = /mnt/data write list = test\n其它参数\nvalid users = name #只允许该用户访问，其它用户可见但无法访问 hosts allow = 192.168.1. #只允许该网段访问 ;前面加分号为注释，等号两边要加空格\n4、启动samba服务 systemctl restart smb nmb systemctl enable smb nmb\n5、配置防火墙 firewall-cmd \u0026ndash;permanent \u0026ndash;add-service=samba firewall-cmd \u0026ndash;permanent \u0026ndash;add-service=samba-client firewall-cmd \u0026ndash;permanent \u0026ndash;add-service=mouted firewall-cmd \u0026ndash;reload\n6、通过子配置文件，让目录只对有权限的用户可见 新建子配置文件\nvim /etc/samba/test1.smb.conf [share11] path = /data/aa valid users = test1\n新建子配置文件\nvim /etc/samba/test2.smb.conf [share12] path = /data/aa valid users = test2\n引用子配置文件\nvim /etc/samba/smb.conf [global] config file = /etc/samba/%U.smb.conf ;include = /etc/samba/%U.smb.conf\n使用config file时，当以test1的身份访问Samba服务器，只能看到share1，其他在smb.conf中定义的共享资源都无法看到。 使用include时，当以test1的身份访问Samba服务器，除了可以看到share1，其他在smb.conf中定义的共享资源也可以看到；\n","permalink":"https://water711.github.io/posts/2021-02-08-centos7-%E9%83%A8%E7%BD%B2samba%E6%9C%8D%E5%8A%A1/","tags":null,"title":"Centos7 部署Samba服务"},{"categories":["linux","nas"],"contents":"官方文档：https://gitlab.com/Shinobi-Systems/Shinobi/-/tree/dev/Docker\n一、安装shinobi 方法1、使用脚本自动安装（存储路径默认在$HOME目录下）\ncurl -o https://gitlab.com/Shinobi-Systems/Shinobi-Installer/raw/master/shinobi-docker.sh\n方法2、手动安装运行\n安装Shinobi\ndocker run -d \u0026ndash;name=\u0026lsquo;Shinobi\u0026rsquo; -p \u0026lsquo;8080:8080/tcp\u0026rsquo; -v \u0026ldquo;/dev/shm/Shinobi/streams\u0026rdquo;:\u0026rsquo;/dev/shm/streams\u0026rsquo;:\u0026lsquo;rw\u0026rsquo; -v \u0026ldquo;$HOME/Shinobi/config\u0026rdquo;:\u0026rsquo;/config\u0026rsquo;:\u0026lsquo;rw\u0026rsquo; -v \u0026ldquo;$HOME/Shinobi/customAutoLoad\u0026rdquo;:\u0026rsquo;/home/Shinobi/libs/customAutoLoad\u0026rsquo;:\u0026lsquo;rw\u0026rsquo; -v \u0026ldquo;$HOME/Shinobi/database\u0026rdquo;:\u0026rsquo;/var/lib/mysql\u0026rsquo;:\u0026lsquo;rw\u0026rsquo; -v \u0026ldquo;$HOME/Shinobi/videos\u0026rdquo;:\u0026rsquo;/home/Shinobi/videos\u0026rsquo;:\u0026lsquo;rw\u0026rsquo; -v \u0026ldquo;$HOME/Shinobi/plugins\u0026rdquo;:\u0026rsquo;/home/Shinobi/plugins\u0026rsquo;:\u0026lsquo;rw\u0026rsquo; -v \u0026lsquo;/etc/localtime\u0026rsquo;:\u0026rsquo;/etc/localtime\u0026rsquo;:\u0026lsquo;ro\u0026rsquo; shinobisystems/shinobi:dev\n安装对象检测（可选）\ndocker run -d \u0026ndash;name=\u0026lsquo;shinobi-tensorflow\u0026rsquo; -e PLUGIN_HOST=\u0026lsquo;10.1.103.113\u0026rsquo; -e PLUGIN_PORT=\u0026lsquo;8080\u0026rsquo; -v \u0026ldquo;$HOME/Shinobi/docker-plugins/tensorflow\u0026rdquo;:\u0026rsquo;/config\u0026rsquo;:\u0026lsquo;rw\u0026rsquo; shinobisystems/shinobi-tensorflow:latest\n二、添加摄像头 1、查看超级用户和密码\ndocker logs Shinobi Default Superuser : admin@shinobi.video Default Password : admin Log in at http://HOST_IP:SHINOBI_PORT/super\n2、用超级用户登录后台，创建普通用户\nhttp://HOST_IP:SHINOBI_PORT/super\n3、登录普通用户，添加摄像头\n点击左上角加号\n三、Shinobi手机端 下载链接：https://cdn.shinobi.video/installers/ShinobiMobile/\n以苹果手机端操作为例\n1、点击Connectto a Shinobi或右下角图标连接Shinobi\n2、输入IP地址、账号和密码，点击Login登录\n3、点击右上角刷新按钮，会出现添加过的摄像头\n4、右击右上角复选框，可全选摄像头，或点击摄像头复选框，选择某个摄像头\n5、点击右上角“小电视”图标，可实时预览所有选中的摄像头，或点击某个摄像头“小电视”图标，预览单个摄像头\n四、修改时区 在使用过程中，发现回放的时间和实际时间有差异，比如今天16号，但回放列表显示今天日期是17号\n[root@nas ~]# docker exec -it Shinobi /bin/bash\n#查看当前时区，默认是UTC root@8b70f5ed8580:/home/Shinobi# cat /etc/timezone\nEtc/UTC\n#修改为亚洲上海时区 root@8b70f5ed8580:/home/Shinobi# echo \u0026ldquo;Asia/Shanghai\u0026rdquo; \u0026gt; /etc/timezone\n","permalink":"https://water711.github.io/posts/2021-02-08-docker%E9%83%A8%E7%BD%B2%E5%BC%80%E6%BA%90%E6%91%84%E5%83%8F%E5%A4%B4%E5%BD%95%E5%88%B6%E8%BD%AF%E4%BB%B6shinobi/","tags":null,"title":"Docker部署开源摄像头录制软件shinobi"},{"categories":["linux","nas"],"contents":"官方文档：https://gitlab.com/Shinobi-Systems/Shinobi/-/tree/dev/Docker\n一、安装shinobi 方法1、使用脚本自动安装（存储路径默认在$HOME目录下）\ncurl -o https://gitlab.com/Shinobi-Systems/Shinobi-Installer/raw/master/shinobi-docker.sh\n方法2、手动安装运行\n安装Shinobi\ndocker run -d \u0026ndash;name=\u0026lsquo;Shinobi\u0026rsquo; -p \u0026lsquo;8080:8080/tcp\u0026rsquo; -v \u0026ldquo;/dev/shm/Shinobi/streams\u0026rdquo;:\u0026rsquo;/dev/shm/streams\u0026rsquo;:\u0026lsquo;rw\u0026rsquo; -v \u0026ldquo;$HOME/Shinobi/config\u0026rdquo;:\u0026rsquo;/config\u0026rsquo;:\u0026lsquo;rw\u0026rsquo; -v \u0026ldquo;$HOME/Shinobi/customAutoLoad\u0026rdquo;:\u0026rsquo;/home/Shinobi/libs/customAutoLoad\u0026rsquo;:\u0026lsquo;rw\u0026rsquo; -v \u0026ldquo;$HOME/Shinobi/database\u0026rdquo;:\u0026rsquo;/var/lib/mysql\u0026rsquo;:\u0026lsquo;rw\u0026rsquo; -v \u0026ldquo;$HOME/Shinobi/videos\u0026rdquo;:\u0026rsquo;/home/Shinobi/videos\u0026rsquo;:\u0026lsquo;rw\u0026rsquo; -v \u0026ldquo;$HOME/Shinobi/plugins\u0026rdquo;:\u0026rsquo;/home/Shinobi/plugins\u0026rsquo;:\u0026lsquo;rw\u0026rsquo; -v \u0026lsquo;/etc/localtime\u0026rsquo;:\u0026rsquo;/etc/localtime\u0026rsquo;:\u0026lsquo;ro\u0026rsquo; shinobisystems/shinobi:dev\n安装对象检测（可选）\ndocker run -d \u0026ndash;name=\u0026lsquo;shinobi-tensorflow\u0026rsquo; -e PLUGIN_HOST=\u0026lsquo;10.1.103.113\u0026rsquo; -e PLUGIN_PORT=\u0026lsquo;8080\u0026rsquo; -v \u0026ldquo;$HOME/Shinobi/docker-plugins/tensorflow\u0026rdquo;:\u0026rsquo;/config\u0026rsquo;:\u0026lsquo;rw\u0026rsquo; shinobisystems/shinobi-tensorflow:latest\n二、添加摄像头 1、查看超级用户和密码\ndocker logs Shinobi Default Superuser : admin@shinobi.video Default Password : admin Log in at http://HOST_IP:SHINOBI_PORT/super\n2、用超级用户登录后台，创建普通用户\nhttp://HOST_IP:SHINOBI_PORT/super\n3、登录普通用户，添加摄像头\n点击左上角加号\n三、Shinobi手机端 下载链接：https://cdn.shinobi.video/installers/ShinobiMobile/\n以苹果手机端操作为例\n1、点击Connectto a Shinobi或右下角图标连接Shinobi\n2、输入IP地址、账号和密码，点击Login登录\n3、点击右上角刷新按钮，会出现添加过的摄像头\n4、右击右上角复选框，可全选摄像头，或点击摄像头复选框，选择某个摄像头\n5、点击右上角“小电视”图标，可实时预览所有选中的摄像头，或点击某个摄像头“小电视”图标，预览单个摄像头\n四、修改时区 在使用过程中，发现回放的时间和实际时间有差异，比如今天16号，但回放列表显示今天日期是17号\n[root@nas ~]# docker exec -it Shinobi /bin/bash\n#查看当前时区，默认是UTC root@8b70f5ed8580:/home/Shinobi# cat /etc/timezone\nEtc/UTC\n#修改为亚洲上海时区 root@8b70f5ed8580:/home/Shinobi# echo \u0026ldquo;Asia/Shanghai\u0026rdquo; \u0026gt; /etc/timezone\n","permalink":"https://water711.github.io/posts/2021-02-08-docker%E9%83%A8%E7%BD%B2%E5%BC%80%E6%BA%90%E6%91%84%E5%83%8F%E5%A4%B4%E5%BD%95%E5%88%B6%E8%BD%AF%E4%BB%B6shinobinull/","tags":null,"title":"Docker部署开源摄像头录制软件shinobi"},{"categories":["linux","nas"],"contents":" 1、查看docker默认目录 docker info | grep \u0026ldquo;Docker Root Dir\u0026rdquo;\n2、新建或者编辑 daemon.json 文件 vim /etc/docker/daemon.json\n{ \u0026ldquo;graph\u0026rdquo;: \u0026ldquo;/mnt/docker\u0026rdquo; }\n3、重启docker服务 systemctl restart docker\n4、查看docker目录文件 ls /mnt/docker\n","permalink":"https://water711.github.io/posts/2021-02-07-centos7-%E4%BF%AE%E6%94%B9docker%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/","tags":null,"title":"Centos7 修改Docker默认存储位置"},{"categories":["other"],"contents":" 一、下载安装Docker Toolbox https://github.com/docker/toolbox/releases\n二、安装Docker Quickstart Terminal 注意：安装完成之后，先不要打开Docker Quickstart Terminal\n三、添加环境变量，替换默认docker machine的存储位置 如果不修改，则docker会把镜像默认下载到C盘，导致以后系统盘空间变小\n变量名为：MACHINE_STORAGE_PATH\n如果已安装了default docker虚拟机，需要先删除原来的，再安装到指定位置。参考这篇文章：https://www.cnblogs.com/ginponson/p/8601320.html\n四、打开Docker Quickstart Terminal，初始化环境 Running pre-create checks\u0026hellip; (default) Unable to get the latest Boot2Docker ISO release version: Get https:/ /api.github.com/repos/boot2docker/boot2docker/releases/latest: read tcp 172.16.1 00.4:49835-\u0026gt;192.30.255.117:443: wsarecv: An existing connection was forcibly clo sed by the remote host. Creating machine\u0026hellip; (default) Unable to get the latest Boot2Docker ISO release version: Get https:/ /api.github.com/repos/boot2docker/boot2docker/releases/latest: read tcp 172.16.1 00.4:49836-\u0026gt;192.30.255.117:443: wsarecv: An existing connection was forcibly clo sed by the remote host. (default) Copying C:\\Users\\Administrator\\.docker\\machine\\cache\\boot2docker.iso t o C:\\Users\\Administrator\\.docker\\machine\\machines\\default\\boot2docker.iso\u0026hellip; (default) Creating VirtualBox VM\u0026hellip; (default) Creating SSH key\u0026hellip; (default) Starting the VM\u0026hellip; (default) Check network to re-create if needed\u0026hellip; (default) Windows might ask for the permission to create a network adapter. Some times, such confirmation window is minimized in the taskbar. (default) Found a new host-only adapter: \u0026ldquo;VirtualBox Host-Only Ethernet Adapter #2\u0026rdquo; (default) Windows might ask for the permission to configure a network adapter. S ometimes, such confirmation window is minimized in the taskbar. (default) Windows might ask for the permission to configure a dhcp server. Somet imes, such confirmation window is minimized in the taskbar. (default) Waiting for an IP\u0026hellip; Waiting for machine to be running, this may take a few minutes\u0026hellip; Detecting operating system of created instance\u0026hellip; Waiting for SSH to be available\u0026hellip; Detecting the provisioner\u0026hellip; Provisioning with boot2docker\u0026hellip; Copying certs to the local machine directory\u0026hellip; Copying certs to the remote machine\u0026hellip; Setting Docker configuration on the remote daemon\u0026hellip; Checking connection to Docker\u0026hellip; Docker is up and running! To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: D:\\Program Files (x86)\\Docker Toolbox\\docker-machine.exe env default\n## . ## ## ## == ## ## ## ## ## === /\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\\\\\\_\\_\\_/ === ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ / ===- ~~~ \\\\\\_\\_\\_\\_\\_\\_ o \\_\\_/ \\\\ \\\\ \\_\\_/ \\\\\\_\\_\\_\\_\\\\\\_\\_\\_\\_\\_\\_\\_/ docker is configured to use the default machine with IP 192.168.99.100 For help getting started, check out the docs at https://docs.docker.com\nStart interactive shell\nPS：启动过程中会下载boot2docker.iso，如果下载速度慢，导致请求超时，需手动下载并移动到以下目录\n.\\.docker\\machine\\cache\\boot2docker.iso\n四、配置Docker 加速器，提高镜像下载速度 DaoCloud官方文档：http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox\ndocker-machine ssh default sudo sed -i \u0026ldquo;s|EXTRA_ARGS=\u0026rsquo;|EXTRA_ARGS=\u0026rsquo;\u0026ndash;registry-mirror=http://f1361db2.m.daocloud.io |g\u0026rdquo; /var/lib/boot2docker/profile exit docker-machine restart default\n","permalink":"https://water711.github.io/posts/2021-02-02-windows-server-2012-r2%E5%AE%89%E8%A3%85docker/","tags":null,"title":"Windows Server 2012 R2安装docker"},{"categories":["other"],"contents":" 一、下载安装Docker Toolbox https://github.com/docker/toolbox/releases\n二、安装Docker Quickstart Terminal 注意：安装完成之后，先不要打开Docker Quickstart Terminal\n三、添加环境变量，替换默认docker machine的存储位置 如果不修改，则docker会把镜像默认下载到C盘，导致以后系统盘空间变小\n变量名为：MACHINE_STORAGE_PATH\n如果已安装了default docker虚拟机，需要先删除原来的，再安装到指定位置。参考这篇文章：https://www.cnblogs.com/ginponson/p/8601320.html\n四、打开Docker Quickstart Terminal，初始化环境 Running pre-create checks\u0026hellip; (default) Unable to get the latest Boot2Docker ISO release version: Get https:/ /api.github.com/repos/boot2docker/boot2docker/releases/latest: read tcp 172.16.1 00.4:49835-\u0026gt;192.30.255.117:443: wsarecv: An existing connection was forcibly clo sed by the remote host. Creating machine\u0026hellip; (default) Unable to get the latest Boot2Docker ISO release version: Get https:/ /api.github.com/repos/boot2docker/boot2docker/releases/latest: read tcp 172.16.1 00.4:49836-\u0026gt;192.30.255.117:443: wsarecv: An existing connection was forcibly clo sed by the remote host. (default) Copying C:\\Users\\Administrator\\.docker\\machine\\cache\\boot2docker.iso t o C:\\Users\\Administrator\\.docker\\machine\\machines\\default\\boot2docker.iso\u0026hellip; (default) Creating VirtualBox VM\u0026hellip; (default) Creating SSH key\u0026hellip; (default) Starting the VM\u0026hellip; (default) Check network to re-create if needed\u0026hellip; (default) Windows might ask for the permission to create a network adapter. Some times, such confirmation window is minimized in the taskbar. (default) Found a new host-only adapter: \u0026ldquo;VirtualBox Host-Only Ethernet Adapter #2\u0026rdquo; (default) Windows might ask for the permission to configure a network adapter. S ometimes, such confirmation window is minimized in the taskbar. (default) Windows might ask for the permission to configure a dhcp server. Somet imes, such confirmation window is minimized in the taskbar. (default) Waiting for an IP\u0026hellip; Waiting for machine to be running, this may take a few minutes\u0026hellip; Detecting operating system of created instance\u0026hellip; Waiting for SSH to be available\u0026hellip; Detecting the provisioner\u0026hellip; Provisioning with boot2docker\u0026hellip; Copying certs to the local machine directory\u0026hellip; Copying certs to the remote machine\u0026hellip; Setting Docker configuration on the remote daemon\u0026hellip; Checking connection to Docker\u0026hellip; Docker is up and running! To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: D:\\Program Files (x86)\\Docker Toolbox\\docker-machine.exe env default\n## . ## ## ## == ## ## ## ## ## === /\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\\\\\\_\\_\\_/ === ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ / ===- ~~~ \\\\\\_\\_\\_\\_\\_\\_ o \\_\\_/ \\\\ \\\\ \\_\\_/ \\\\\\_\\_\\_\\_\\\\\\_\\_\\_\\_\\_\\_\\_/ docker is configured to use the default machine with IP 192.168.99.100 For help getting started, check out the docs at https://docs.docker.com\nStart interactive shell\nPS：启动过程中会下载boot2docker.iso，如果下载速度慢，导致请求超时，需手动下载并移动到以下目录\n.\\.docker\\machine\\cache\\boot2docker.iso\n四、配置Docker 加速器，提高镜像下载速度 DaoCloud官方文档：http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox\ndocker-machine ssh default sudo sed -i \u0026ldquo;s|EXTRA_ARGS=\u0026rsquo;|EXTRA_ARGS=\u0026rsquo;\u0026ndash;registry-mirror=http://f1361db2.m.daocloud.io |g\u0026rdquo; /var/lib/boot2docker/profile exit docker-machine restart default\n","permalink":"https://water711.github.io/posts/2021-02-02-windows-server-2012-r2%E5%AE%89%E8%A3%85dockernull/","tags":null,"title":"Windows Server 2012 R2安装docker"},{"categories":["other"],"contents":" 一、手机上新建目录，用于存放github仓库文件 二、打开Working Copy，点击右上角加号，选择Setup synced directory 三、选中第1步新建的目录，点击完成，在弹出的界面中点击左上角的Done 四、点击Repository-》Create Repository，输入仓库URL地址，取消Allow Push，点击右上角保存 五、点击右下角指纹按钮，在弹出页面中，点击Fetch，同步仓库文件到本地（第一次可能会失败） 六、如果同步失败，退出软件，重新打开，进入该仓库，点击Branch，查看分支 七、选择分支，点击Checkout 可以看到该分支下所有目录和文件\n","permalink":"https://water711.github.io/posts/2021-02-01-%E4%BD%BF%E7%94%A8working-copy%E8%BF%9C%E7%A8%8B%E6%8C%82%E8%BD%BDgithub%E4%BB%93%E5%BA%93/","tags":null,"title":"使用Working Copy远程挂载github仓库"},{"categories":["other"],"contents":"域名被DNS污染，手动在hosts文件中添加解析\n199.232.4.133 raw.githubusercontent.com\n","permalink":"https://water711.github.io/posts/2021-01-28-%E8%A7%A3%E5%86%B3raw-github%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98/","tags":null,"title":"解决raw.github无法访问的问题"},{"categories":["other"],"contents":"命令行中输入：diskperf -y\n","permalink":"https://water711.github.io/posts/2021-01-26-windows-server-2012-2016-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E5%A2%9E%E5%8A%A0%E7%A3%81%E7%9B%98%E7%9B%91%E6%8E%A7/","tags":null,"title":"Windows Server 2012/2016 任务管理器增加磁盘监控"},{"categories":["other"],"contents":"Win7环境搭建openwrt插件库 一、将编译好的插件库拷贝到Win7电脑（只需拷贝以下两个目录）\n/lede/bin/packages/mips_24kc /lede/bin/targets/ar71xx/generic/packages\n我这边拷贝到 F盘openwrt_package文件夹\n二、开启IIS信息服务\n运行中输入 appwiz.cpl，打开程序和功能，点击左上角“打开或关闭Windows功能”\n三、配置网站\n1、运行中输入 inetmgr，打开IIS，点击展开默认网站-》管理网站-》高级设置\n2、修改物理路径为插件库所有目录\n3、启用目录浏览\n4、添加MIME类型\nPS：如果不添加MIME类型，则无法通过网站访问和下载sig和ipk文件，我们也可以将文件扩展名指定为 * 号，允许访问所有类型文件\n5、浏览器访问测试\nhttps://本机IP地址\n6、右键复制mips_24kc和packages目录链接地址，粘贴到文本文档中备用\nhttp://192.168.1.92/packages/ http://192.168.1.92/mips_24kc/\n四、配置openwrt\n1、登录openwrt，进入 系统-》软件包-》配置\n将发行版软件源中的代码注释掉，在每行中添加#号，点击提交\n# src/gz openwrt_core https://mirrors.cloud.tencent.com/lede/snapshots/targets/ar71xx/generic/packages\nsrc/gz openwrt_base https://mirrors.cloud.tencent.com/lede/snapshots/packages/mips_24kc/base src/gz openwrt_freifunk https://mirrors.cloud.tencent.com/lede/snapshots/packages/mips_24kc/freifunk src/gz openwrt_luci https://mirrors.cloud.tencent.com/lede/releases/18.06.8/packages/mips_24kc/luci src/gz openwrt_packages https://mirrors.cloud.tencent.com/lede/snapshots/packages/mips_24kc/packages src/gz openwrt_routing https://mirrors.cloud.tencent.com/lede/snapshots/packages/mips_24kc/routing src/gz openwrt_telephony https://mirrors.cloud.tencent.com/lede/snapshots/packages/mips_24kc/telephony 将“发行版软件源”的代码拷贝文本文档，将后面链接替换为自己搭建网站的链接\n将替换后代码，拷贝到“自定义软件源”，点击提交\nsrc/gz openwrt_core http://192.168.1.92/packages/ src/gz openwrt_base http://192.168.1.92/mips_24kc/ base src/gz openwrt_freifunk http://192.168.1.92/mips_24kc/ freifunk src/gz openwrt_luci http://192.168.1.92/mips_24kc/ luci src/gz openwrt_packages http://192.168.1.92/mips_24kc/ packages src/gz openwrt_routing http://192.168.1.92/mips_24kc/ routing src/gz openwrt_telephony http://192.168.1.92/mips_24kc/ telephony\n2、点击软件包-》动作，刷新列表，刷新后在“可用软件包”中会出现我们搭建好的软件库\ndocker环境搭建openwrt插件库 部署http文件服务\ndocker run -dit -p 80:80 \u0026ndash;name httpd-op-packages \\ -v /mnt/http_op_packages/htdocs:/usr/local/apache2/htdocs \\ -v /mnt/http_op_packages/logs:/usr/local/apache2/logs \\ \u0026ndash;restart=always httpd\nopenwrt其余步骤与windows环境相同\n","permalink":"https://water711.github.io/posts/2021-01-16-win7%E6%90%AD%E5%BB%BAopenwrt%E6%8F%92%E4%BB%B6%E5%BA%93/","tags":null,"title":"Win7搭建Openwrt插件库"},{"categories":["other"],"contents":"查询当前是否开启了查询日志 mysql\u0026gt; show global variables like \u0026lsquo;%general_log%\u0026rsquo;; +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ | Variable_name | Value | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ | general_log | OFF | | general_log_file | D:\\mysql\\data\\LENOVO-LA0X1198.log | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\n开启查询日志 mysql\u0026gt; SET GLOBAL general_log = \u0026lsquo;ON\u0026rsquo;;\n关闭查询日志 mysql\u0026gt; SET GLOBAL general_log = \u0026lsquo;OFF\u0026rsquo;;\n","permalink":"https://water711.github.io/posts/2021-01-15-mysql%E4%B8%B4%E6%97%B6%E5%BC%80%E5%90%AF%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/","tags":null,"title":"Mysql临时开启查询日志"},{"categories":["other"],"contents":"有时候服务器是Win7系统的时候，远程登录桌面时，即使登录的是不同的管理账号，还是会把远程登录的人给踢下来。即不同的账号只能同时存在一个会话窗。下面教大家如果设置Win7让两个账号的两会话同时存在，且相互之间不冲突。\n下载一个universal termsrv.dll patch。\n链接：http://pan.baidu.com/s/1kV9hirt 密码：jqg2\n第三方工具。解压到文件夹。打开UniversalTermsrvPatch文件夹\u0026mdash;\u0026gt;管理员身份运行UniversalTermsrvPatch-x86.exe文件。\n点击破解，重启后生效，如果重启后还不能多用户登录，则按照原文链接，进行本地组策略设置。\n原文链接：http://www.wuwenhui.cn/4312.html\n","permalink":"https://water711.github.io/posts/2021-01-14-win7%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%94%A8%E6%88%B7%E5%90%8C%E6%97%B6%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/","tags":null,"title":"Win7实现多用户同时远程登录"},{"categories":["linux"],"contents":"SpeedTest官方文档：https://www.speedtest.net/apps/cli\n方法一： wget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py chmod +x speedtest-cli ./speedtest-cli \u0026ndash;share\n方法二： sudo yum install wget wget https://bintray.com/ookla/rhel/rpm -O bintray-ookla-rhel.repo sudo mv bintray-ookla-rhel.repo /etc/yum.repos.d/ sudo yum install speedtest\n","permalink":"https://water711.github.io/posts/2021-01-13-centos7%E4%BD%BF%E7%94%A8speedtest%E5%B7%A5%E5%85%B7%E6%B5%8B%E9%80%9F/","tags":null,"title":"CentOS7使用SpeedTest工具测速"},{"categories":["linux"],"contents":" 一、导入ELRepo仓库的公共密钥 rpm \u0026ndash;import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org\n二、安装EL仓库源 rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm\n三、查看可提供升级的内核版本 yum \u0026ndash;disablerepo=\u0026quot;*\u0026quot; \u0026ndash;enablerepo=\u0026ldquo;elrepo-kernel\u0026rdquo; list available\n四、升级内核 yum \u0026ndash;enablerepo=elrepo-kernel install 包名\n","permalink":"https://water711.github.io/posts/2021-01-07-centos7-%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/","tags":null,"title":"Centos7 升级内核"},{"categories":["linux"],"contents":"一、如果系统安装过docker，先卸载 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine\n二、安装依赖包 sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2\n三、添加Docker软件包源 sudo yum-config-manager \u0026ndash;add-repo https://download.docker.com/linux/centos/docker-ce.repo\n四、安装Docker CE（社区版） sudo yum install docker-ce docker-ce-cli containerd.io\n五、启动 systemctl start docker systemctl enable docker docker info\n","permalink":"https://water711.github.io/posts/2021-01-07-centos7-%E5%AE%89%E8%A3%85docker/","tags":null,"title":"Centos7 安装docker"},{"categories":["other"],"contents":"一、GitHub 镜像访问 最常见GitHub镜像地址：\nhttps://hub.fastgit.org/ https://github.com.cnpmjs.org/ 访问上面的镜像网站，网站的内容跟GitHub是完整同步的镜像，然后在这个网站里面进行下载克隆等操作。\n二、GitHub 文件加速 使用非常简单，内有提示！\ngh-proxy开源项目示例演示 听海演示 三、Github 加速下载 Code ZIP GitHub加速下载在线工具：http://toolwa.com/github/ 使用方法： 进入 GitHub 某一项目主页\n点击右侧的绿色按钮 “Code” \u0026gt; “Download ZIP”\n等浏览器弹出下载框后复制下载框中的链接地址并粘贴到以上输入框\n点击加速下载\n四、加速链接 Github GitHub加速链接生成在线工具：https://github.zhlh6.cn/\n使用方法：\n输入Github仓库地址，使用生成的地址进行git ssh操作即可， 如：git clone 仓库的ssh地址 原理：利用ucloud提供的GlobalSSH功能，对ssh端口协议数据进行加速\n五、谷歌浏览器GitHub加速插件(推荐) 插件直接下载安装\n六、GitHub raw 链接加速 GitHub raw=raw.githubusercontent.com\n将 raw.githubusercontent.com 替换为 raw.staticdn.net 即可加速。\n七、GitHub + JsDelivr JsDelivr CDN只能加速仓库的静态文件\n参考\nPicGo教程①，GitHub建立属于自己的免费图床 PicGo教程②，配合Typora使用，自动返回远程图床链接 八、通过Gitee中转fork仓库下载 1、访问gitee网站： https://gitee.com/ 并登录，在右上角顶部选择“从GitHub/GitLab导入仓库”\n2、在导入页面中粘贴你的Github仓库地址，点击导入即可\n3、等待导入操作完成，然后在导入的仓库中下载浏览对应的该GitHub仓库代码，你也可以点击仓库顶部的“刷新”按钮进行Github代码仓库的同步。\n九、通过修改HOSTS文件进行加速 1、手动把CDNip和域名地址绑定。\n访问：http://github.global.ssl.fastly.net.ipaddress.com/#ipinfo 获取CDNip和域名\neg：199.232.69.194 https://github.global.ssl.fastly.net\n访问：https://github.com.ipaddress.com/#ipinfo 获取CDNip和域名\neg：140.82.114.4 http://github.com\n2、修改本地host文件映射上面查找到的IP\n①. 修改C:WindowsSystem32driversetchosts文件的权限，指定可写入：\n右击-\u0026gt;hosts-\u0026gt;属性-\u0026gt;安全-\u0026gt;编辑-\u0026gt;点击Users-\u0026gt;在Users的权限“写入”后面打勾。\n②. 右击-\u0026gt;hosts-\u0026gt;打开方式-\u0026gt;选定记事本（或者你喜欢的编辑器）-\u0026gt;在末尾处添加以下内容：\n199.232.69.194 github.global.ssl.fastly.net 140.82.114.4 github.com\n原文链接：https://www.tsingsea.com/git-clone-speed-up.html\n","permalink":"https://water711.github.io/posts/2021-01-06-github%E8%AE%BF%E9%97%AE%E5%A4%AA%E6%85%A2git-clone%E5%A4%AA%E6%85%A2%E7%9A%849%E7%A7%8D%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","tags":null,"title":"GitHub访问太慢，git clone太慢的9种解决办法"},{"categories":["linux"],"contents":" 一、安装VNCServer sudo apt-get install vnc4server\n二、设置密码并运行vncserver（输入命令后输入密码） vncserver\n三、配置xstartup文件 修改xstartup文件内容，针对Xfce4桌面环境.\nvim ~/.vnc/xstartup\n#!/bin/sh unset SESSION_MANAGER unset DBUS_SESSION_BUS_ADDRESS startxfce4 \u0026amp; [ -x /etc/vnc/xstartup ] \u0026amp;\u0026amp; exec /etc/vnc/xstartup [ -r $HOME/.Xresources ] \u0026amp;\u0026amp; xrdb $HOME/.Xresources xsetroot -solid grey\n四、重启vncserver 修改配置文件后，运行如下命令结束掉之前产生的窗口:1\nvncserver -kill :1\n五、重新启动（reboot系统后，然后启动服务） vncserver\nvnc客户端连接 vnc viewer链接新建链接，然后地址输入ip:5901\n注意事项 1.防火墙\n2.如果是用了腾讯云或者其他如阿里云等则需要配置安全组放开5901端口\n原文链接：https://blog.csdn.net/hanmingjun/article/details/107122567\n","permalink":"https://water711.github.io/posts/2021-01-06-ubuntu18-04-1-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEvnc-server/","tags":null,"title":"ubuntu18.04.1 安装配置vnc server"},{"categories":["linux"],"contents":"参考链接：https://www.daocloud.io/mirror\nLinux curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io\n该脚本可以将 \u0026ndash;registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。更多详情请访问文档。\n使用前请先确保您的 Docker 版本在 1.8 或更高版本，否则无法使用加速，配置完成后，请根据终端中的提示重启 docker\n国内其它docker镜像源地址 docker官方中国区 ：https://registry.docker-cn.com\n网易 ：http://hub-mirror.c.163.com\n网易蜂巢 ：http://hub-mirror.c.163.com\n中国科技大学： https://docker.mirrors.ustc.edu.cn\n阿里云 ：http://\u0026lt;你的ID\u0026gt;.mirror.aliyuncs.com\n","permalink":"https://water711.github.io/posts/2021-01-04-centos7-%E4%BF%AE%E6%94%B9docker%E9%95%9C%E5%83%8F%E6%BA%90/","tags":null,"title":"Centos7 修改docker镜像源"},{"categories":["linux"],"contents":" 设置默认启动内核 1、查看系统可用内核\n[root@NAS]# awk -F\\\u0026rsquo; \u0026lsquo;$1==\u0026ldquo;menuentry \u0026quot; {print i++ \u0026quot; : \u0026quot; $2}\u0026rsquo; /etc/grub2.cfg\n0 : CentOS Linux (4.4.248-1.el7.elrepo.x86_64) 7 (Core) 1 : CentOS Linux (3.10.0-1160.11.1.el7.x86_64) 7 (Core) 2 : CentOS Linux (3.10.0-957.el7.x86_64) 7 (Core) 3 : CentOS Linux (0-rescue-70b8558dd1bf4abb887cf26344a88da3) 7 (Core) Linux (3.10.0-1127.8.2.el7.x86_64) 7 (Core)\u0026rsquo; \u0026ndash;class centos \u0026ndash;class gnu-linux \u0026ndash;class gnu \u0026ndash;class os \u0026ndash;unrestricted $menuentry_id_option \u0026lsquo;gnulinux-3.10.0-957.el7.x86_64-advanced-31cdfa8e-4bda-4e29-a11e-8e46000798d6\u0026rsquo; {\n2、查看系统开机默认启动内核\n[root@NAS ~]# grub2-editenv list saved_entry=CentOS Linux (3.10.0-1160.11.1.el7.x86_64) 7 (Core)\n3、查看系统当前内核\n[root@NAS ~]# uname -r\n4、设置默认启动内核\n[root@NAS ~]# grub2-set-default \u0026lsquo;CentOS Linux (4.4.248-1.el7.elrepo.x86_64) 7 (Core)\u0026rsquo;\n5、验证\n[root@NAS ~]# grub2-editenv list\n删除多余内核 1、查看系统安装了哪些内核包\n[root@NAS ~]# rpm -qa |grep kernel\n2、删除旧的内核\n[root@NAS ~]# yum remove 包名\n","permalink":"https://water711.github.io/posts/2020-12-29-centos7-%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8%E5%B9%B6%E5%88%A0%E9%99%A4%E5%A4%9A%E4%BD%99%E5%86%85%E6%A0%B8/","tags":null,"title":"centos7 设置默认启动内核，并删除多余内核"},{"categories":["other"],"contents":"解决方法： 1.进入CSR蓝牙驱动的安装目录，默认是：C:\\Program Files\\CSR\\CSR Harmony Wireless Software Stack；\n2.找到“BLEtokenCredentialProvider.dll”将其删除或重命名即可。\n原文链接：https://blog.csdn.net/guangguang210/article/details/79051550\n","permalink":"https://water711.github.io/posts/2020-12-19-%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%92%8C%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%97%B6csr%E8%93%9D%E7%89%99%E9%A9%B1%E5%8A%A8%E5%BC%95%E8%B5%B7/","tags":null,"title":"访问共享文件和连接远程桌面时，CSR蓝牙驱动引起的资源管理器崩溃"},{"categories":["other"],"contents":"一、ASUS华硕路由器开启Openvpn 二、苹果手机连接OpenVPN 1、使用美区APPLE ID登录APP store，搜索OpenVPN，下载应用\n2、将ASUS导出的OpenVPN配置文件，发送到手机，并使用OpenVPN应用打开文件\n3、点击ADD导入配置\n4、输入VPN账号密码\n5、连接成功\n三、PC端连接OpenVPN 1、下载安装OpenVPN客户端\nhttps://www.techspot.com/downloads/5182-openvpn.html\n2、打开OpenVPN，在右下角系统托盘，右键导入OpenVPN配置文件\n3、点击连接，输入VPN账号密码\n四、OpenVPN自定义路由 方法一：修改客户端配置文件\nroute-nopull # 不从服务端获取路由 route 192.168.1.0 255.255.255.0 net_gateway # 192.168.1.0/24网段，不走vpn网关 route 192.168.2.0 255.255.255.0 vpn_gateway # 192.168.2.0/24网段，走vpn网关\n方法二：修改服务端配置文件\n# 将该以下路由推送到客户端 push \u0026ldquo;route 192.168.1.0 255.255.255.0 net_gateway\u0026rdquo; push \u0026ldquo;route 192.168.2.0 255.255.255.0 vpn_gateway\u0026rdquo;\nPS：如果配置中有 redirect-gateway ，则需要注释掉\n","permalink":"https://water711.github.io/posts/2020-12-14-asus%E5%8D%8E%E7%A1%95%E8%B7%AF%E7%94%B1%E5%99%A8%E5%BC%80%E5%90%AFopenvpn%E4%BD%BF%E7%94%A8%E8%8B%B9%E6%9E%9C%E6%89%8B%E6%9C%BA%E8%BF%9E%E6%8E%A5openvpn/","tags":null,"title":"ASUS华硕路由器开启Openvpn，使用苹果手机连接OpenVPN"},{"categories":["other"],"contents":"一、ASUS华硕路由器开启Openvpn 二、苹果手机连接OpenVPN 1、使用美区APPLE ID登录APP store，搜索OpenVPN，下载应用\n2、将ASUS导出的OpenVPN配置文件，发送到手机，并使用OpenVPN应用打开文件\n3、点击ADD导入配置\n4、输入VPN账号密码\n5、连接成功\n三、PC端连接OpenVPN 1、下载安装OpenVPN客户端\nhttps://www.techspot.com/downloads/5182-openvpn.html\n2、打开OpenVPN，在右下角系统托盘，右键导入OpenVPN配置文件\n3、点击连接，输入VPN账号密码\n四、OpenVPN自定义路由 方法一：修改客户端配置文件\nroute-nopull # 不从服务端获取路由 route 192.168.1.0 255.255.255.0 net_gateway # 192.168.1.0/24网段，不走vpn网关 route 192.168.2.0 255.255.255.0 vpn_gateway # 192.168.2.0/24网段，走vpn网关\n方法二：修改服务端配置文件\n# 将该以下路由推送到客户端 push \u0026ldquo;route 192.168.1.0 255.255.255.0 net_gateway\u0026rdquo; push \u0026ldquo;route 192.168.2.0 255.255.255.0 vpn_gateway\u0026rdquo;\nPS：如果配置中有 redirect-gateway ，则需要注释掉\n","permalink":"https://water711.github.io/posts/2020-12-14-asus%E5%8D%8E%E7%A1%95%E8%B7%AF%E7%94%B1%E5%99%A8%E5%BC%80%E5%90%AFopenvpn%E4%BD%BF%E7%94%A8%E8%8B%B9%E6%9E%9C%E6%89%8B%E6%9C%BA%E8%BF%9E%E6%8E%A5openvpnnull/","tags":null,"title":"ASUS华硕路由器开启Openvpn，使用苹果手机连接OpenVPN"},{"categories":["linux"],"contents":" 一、安装ffmpeg 1、安装epel源\n[root@BK ~]# yum install -y epel-release\n2、安装Nux-Dextop源\n[root@BK ~]# rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-1.el7.nux.noarch.rpm\n3、安装ffmpeg\n[root@BK ~]# yum install -y ffmpeg\n4、查看ffmpeg版本\n[root@BK ~]# ffmpeg -version\n二、使用ffmpeg转换格式并压缩视频 使用默认参数转mp4格式\n[root@BK ~]# ffmpeg -i input_video.avi output_video.mp4\n设置输出视频位率为400kbps\n[root@BK ~]# ffmpeg -i input_video.avi -b:v 400k output_video.mp4\n设置输出视频分辨率为600x400\n[root@BK ~]# ffmpeg -i input_video.avi -s 600x400 output_video.mp4\n","permalink":"https://water711.github.io/posts/2020-12-04-centos7-%E5%AE%89%E8%A3%85ffmpeg%E5%AF%B9%E8%A7%86%E9%A2%91%E8%BD%AC%E7%A0%81%E5%8E%8B%E7%BC%A9/","tags":null,"title":"Centos7 安装FFmpeg对视频转码压缩"},{"categories":["linux"],"contents":" 1、查看当前磁盘空间使用情况 [root@BK ~]# df -h Filesystem Size Used Avail Use% Mounted on devtmpfs 1.8G 0 1.8G 0% /dev tmpfs 1.9G 0 1.9G 0% /dev/shm tmpfs 1.9G 8.9M 1.8G 1% /run tmpfs 1.9G 0 1.9G 0% /sys/fs/cgroup /dev/mapper/centos-root 411G 1.8G 409G 1% / /dev/sda1 1014M 192M 823M 19% /boot /dev/mapper/centos-home 50G 33M 50G 1% /home tmpfs 371M 0 371M 0% /run/user/0\n2、备份/home目录 [root@BK ~]# cp -rp /home/ /tmp/\n-r 递归复制该目录下的子目录 -p 将文件和目录具有的权限一同复制\n3、卸载/home分区 [root@BK ~]# umount /home umount: /home: target is busy. (In some cases useful info about processes that use the device is found by lsof(8) or fuser(1))\n如果提示 umount: /home: target is busy，使用fuser命令查看当前在使用home目录的进程，并结束进程\n[root@BK ~]# yum install psmisc [root@BK ~]# fuser -m /home /home: 17736c 17795c\n[root@BK ~]# kill -9 17736 17795 [root@BK ~]# umount /home\n4、在fstab文件注释/home目录，取消开机挂载 [root@BK ~]# vim /etc/fstab #/dev/mapper/centos-home /home xfs defaults 0 0\n5、删除/home所在的LV(logical volume) [root@BK ~]# lvremove /dev/mapper/centos-home Do you really want to remove active logical volume centos/home? [y/n]: y Logical volume \u0026ldquo;home\u0026rdquo; successfully removed\n6、查看VG(volume group)未分配的空间大小（Free PE / Size ） [root@BK ~]# vgdisplay \u0026mdash; Volume group \u0026mdash; VG Name centos System ID Format lvm2 Metadata Areas 1 Metadata Sequence No 5 VG Access read/write VG Status resizable MAX LV 0 Cur LV 2 Open LV 2 Max PV 0 Cur PV 1 Act PV 1 VG Size \u0026lt;464.76 GiB PE Size 4.00 MiB Total PE 118978 Alloc PE / Size 106178 / \u0026lt;414.76 GiB Free PE / Size 12800 / 50.00 GiB VG UUID FLbm62-WMrB-1ozX-1hdm-5IuW-e49l-AYy99C\n7、扩展/root所在的LV(logical volume)空间 [root@BK ~]# lvextend -L +50G /dev/mapper/centos-root Size of logical volume centos/root changed from \u0026lt;410.77 GiB (105156 extents) to \u0026lt;428.77 GiB (109764 extents). Logical volume centos/root successfully resized.\n8、扩展xfs文件系统空间 [root@BK ~]# xfs_growfs /dev/mapper/centos-root\nPS：如果是ext文件系统,则使用resize2fs命令扩展文件系统\n9、查看扩容后根目录空间大小 [root@BK ~]# df -H Filesystem Size Used Avail Use% Mounted on devtmpfs 2.0G 0 2.0G 0% /dev tmpfs 2.0G 0 2.0G 0% /dev/shm tmpfs 2.0G 9.3M 2.0G 1% /run tmpfs 2.0G 0 2.0G 0% /sys/fs/cgroup /dev/mapper/centos-root 495G 1.9G 493G 1% / /dev/sda1 1.1G 201M 863M 19% /boot tmpfs 389M 0 389M 0% /run/user/0\n10、将备份的文件拷贝回/home目录 [root@BK ~]# cp -rp /tmp/home/* /home/\n","permalink":"https://water711.github.io/posts/2020-12-04-centos7-%E5%B0%86home%E7%9B%AE%E5%BD%95%E5%92%8C%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%9A%84%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E5%90%88%E5%B9%B6/","tags":null,"title":"Centos7 将home目录和根目录的磁盘空间合并"},{"categories":["other"],"contents":" 官方文档：https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/forfiles\nforfiles命令：按照通配符或修改日期进行文件搜索，并将搜索结果传给另一个命令进行文件操作\n案例：\n#搜索source目录下，7天以前的avi视频文件，移动到共享目录backup forfiles /p D:\\source /S /M \u0026ldquo;*.avi\u0026rdquo; /d -7 /c \u0026ldquo;cmd /c move @path \\\\192.168.1.10\\backup\u0026rdquo;\n#删除当前目录下，15天前的日志文件 forfiles /p \u0026ldquo;.\u0026rdquo; /s /m *.log /d -15 /c \u0026ldquo;cmd /c del @path\u0026rdquo;\n上面案例用到的参数（不区分大小写）：\n/P pathname 表示开始搜索的路径。默认文件夹是当前工作的目录 (.)。 /M searchmask 根据搜索掩码搜索文件。默认搜索掩码是 '\\*'。 /S 指导 forfiles 递归到子目录。像 \u0026quot;DIR /S\u0026quot;。 /D date 选择文件，其上一次修改日期大于或等于 (+)，或者小于或等于 (-) 用 \u0026quot;yyyy-MM-dd\u0026quot; 格式指定的日期; 或选择文件，其上一次修改日期大于或等于 (+) 当前日期加 \u0026quot;dd\u0026quot; 天，或者小于或等于 (-) 当前 日期减 \u0026quot;dd\u0026quot; 天。有效的 \u0026quot;dd\u0026quot; 天数可以是 0 - 32768 范围内的任何数字。如果没有指定，\u0026quot;+\u0026quot; 被当作默认符号。 /C command 表示为每个文件执行的命令。命令字符串应该用双引号括起来。 默认命令是 \u0026quot;cmd /c echo @file\u0026quot;。下列变量 可以用在命令字符串中: @path - 返回文件的完整路径。 ","permalink":"https://water711.github.io/posts/2020-12-03-%E6%89%B9%E5%A4%84%E7%90%86%E4%B9%8Bforfiles%E5%91%BD%E4%BB%A4/","tags":null,"title":"批处理之forfiles命令"},{"categories":["linux"],"contents":" 一、安装Elasticsearch 1、下载安装包并解压\n[root@ELK ~]# wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.9.2-linux-x86_64.tar.gz [root@ELK ~]# tar xzvf elasticsearch-7.9.2-linux-x86_64.tar.gz -C /usr/local/\n2、创建用户和用户组\nelasticsearch默认不允许使用root用户运行，如果要强行使用root运行，要加上该参数 ./bin/elasticsearch -Des.insecure.allow.root=true\n[root@ELK ~]# useradd es [root@ELK ~]# passwd es [root@ELK ~]# chown -R es:es /usr/local/elasticsearch-7.9.2/\n3、启动elasticsearch\n[root@ELK ~]# su - es [es@ELK ~]# cd /usr/local/elasticsearch-7.9.2/ [es@ELK elasticsearch-7.9.2]$ ./bin/elasticsearch [root@ELK ~]# curl http://127.0.0.1:9200 #测试启动是否成功\n启动出错\n[root@ELK ~]# tail -f /var/log/messages #需要设置es用户的最大打开文件数和最大进程数 [1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535]\n#需要修改单个进程拥有虚拟内存区域的大小 [2]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]\n#需要配置elasticsearch.yml文件，指定discovery主机 [3]: the default discovery settings are unsuitable for production use; at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured\n4、配置系统内核参数\n修改es用户的最大打开文件数和最大进程数\n[root@ELK ~]# vim /etc/security/limits.conf //在文件最后加入 es soft nofile 65536 es hard nofile 65536 es soft nproc 4096 es hard nproc 4096\n修改单个进程拥有虚拟内存区域的大小\n[root@ELK ~]# vim /etc/sysctl.conf vm.max_map_count=655360\n重启系统生效\n[root@ELK ~]# reboot\n5、配置elasticsearch\n[root@ELK ~]# vim /usr/local/elasticsearch-7.9.2/config/elasticsearch.yml network.host: 192.168.1.225 #修改为本机IP，允许其它主机远程访问 discovery.seed_hosts: [\u0026ldquo;192.168.1.225\u0026rdquo;] #集群主机节点，单节点则只填本机 #path.data: /path/to/data #数据存放目录，默认在./elasticsearch/data下 #path.logs: /path/to/logs #日志存放目录，默认在./elasticsearch/logs下\n6、配置防火墙\n[root@ELK ~]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-port=9200/tcp [root@ELK ~]# firewall-cmd \u0026ndash;reload\n7、配置为服务并开机启动\n[root@ELK ~]# vim /etc/systemd/system/elasticsearch.service [Unit] Description=elasticsearch.service After=network.target\n[Service] Type=forking User=es #使用哪个用户启动\nLimitNOFILE=100000 LimitNPROC=100000 ExecStart=/usr/local/elasticsearch-7.9.2/bin/elasticsearch -d #启动的程序路径\n[Install] WantedBy=multi-user.target\n启动\n[root@ELK ~]# systemctl enable elasticsearch [root@ELK ~]# systemctl start elasticsearch\n二、安装插件elasticsearch-head 1、安装git和nodejs（nodejs需要9.0或以上版本）\n[root@ELK ~]# yum -y install git [root@ELK ~]# wget https://npm.taobao.org/mirrors/node/v14.13.1/node-v14.13.1-linux-x64.tar.xz [root@ELK ~]# tar xf node-v14.13.1-linux-x64.tar.xz -C /usr/local/ [root@ELK ~]# mv /usr/local/node-v14.13.1-linux-x64/ /usr/local/nodejs [root@ELK ~]# ln -sv /usr/local/nodejs/bin/npm /usr/local/bin/ [root@ELK ~]# ln -sv /usr/local/nodejs/bin/node /usr/local/bin/\n2、安装配置elasticsearch-head\n[root@ELK ~]# cd /usr/local/ [root@ELK local]# git clone git://github.com/mobz/elasticsearch-head.git [root@ELK local]# cd elasticsearch-head/ [root@ELK elasticsearch-head]# npm install\n#npm默认源安装较慢，更换淘宝源加快安装速度 [root@ELK ~]# npm config set registry https://registry.npmjs.org/ #配置官方的源 [root@ELK ~]# npm config set registry https://registry.npm.taobao.org #配置淘宝的源 [root@ELK ~]# npm config get registry #查看当前注册的源\nnpm install出错，查看npm日志\n[root@ELK elasticsearch-head]# less /root/.npm/_logs/2020-10-03T17_03_29_020Z-debug.log \u0026hellip;\u0026hellip;.. Failed at the phantomjs-prebuilt@2.1.16 install script.\n解决方法，单独安装phantomjs：\n[root@ELK elasticsearch-head]# npm install phantomjs-prebuilt@2.1.14 \u0026ndash;ignore-scripts\n3、配置elasticsearch允许跨域访问\n[root@ELK ~]# vim /usr/local/elasticsearch-7.9.2/config/elasticsearch.yml\n//在文件末尾追加下面两行代码 http.cors.enabled: true http.cors.allow-origin: \u0026ldquo;*\u0026rdquo;\n4、修改elasticsearch-head默认连接地址\n[root@ELK ~]# vim /usr/local/elasticsearch-head/_site/app.js this.base_uri = this.config.base_uri || this.prefs.get(\u0026ldquo;app-base_uri\u0026rdquo;) || \u0026ldquo;http://192.168.1.225:9200\u0026rdquo;; #将localhost修改为es服务器地址\n5、配置防火墙\n[root@ELK ~]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-port=9100/tcp [root@ELK ~]# firewall-cmd \u0026ndash;reload\n6、设置开机启动\n方法一：配置为服务\n[root@ELK ~]# vim /etc/init.d/elasticsearch-head #!/bin/sh #chkconfig: 2345 80 05 #description: elasticsearch-head\nelasticsearch-head 的路径 cd /usr/local/elasticsearch-head nohup npm run start \u0026gt;/usr/local/elasticsearch-head/nohup.out 2\u0026gt;\u0026amp;1 \u0026amp; [root@ELK ~]# chmod +x /etc/init.d/elasticsearch-head [root@ELK ~]# chkconfig \u0026ndash;add elasticsearch-head\n方法二：配置开机启动脚本\n[root@ELK ~]# vim /etc/rc.local [root@ELK ~]# chmod +x /etc/rc.d/rc.local cd /usr/local/elasticsearch-head/node_modules/grunt/bin/ ./grunt server\u0026amp;\n7、解决单节点 Elasticsearch 健康状态为 yellow 问题\n原因：单点部署的 Elasticsearch，默认分片的副本数为 1，而相同的分片不能在同一个节点上，所以就出现上面 unsigned shards 的问题\n[root@ELK ~]# curl -X PUT \u0026ldquo;192.168.1.225:9200/_settings\u0026rdquo; -H \u0026lsquo;Content-Type: application/json\u0026rsquo; -d \u0026lsquo;{\u0026ldquo;number_of_replicas\u0026rdquo;:0}\u0026rsquo; 返回 {\u0026ldquo;acknowledged\u0026rdquo;:true}\n方法二、将es部署为集群\n三、安装Logstash 1、安装JAVA\n官网下载Java：https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html\n[root@ELK ~]# tar xvf jdk-8u261-linux-x64.tar.gz -C /usr/local/ [root@ELK ~]# mv /usr/local/jdk1.8.0_261/ /usr/local/java\n[root@ELK ~]# vim /etc/profile export JAVA_HOME=/usr/local/java export JRE_HOME=${JAVA_HOME}/jre export PATH=${JAVA_HOME}/bin:$PATH\n[root@ELK ~]# source /etc/profile #立即加载profile文件中的环境变量 [root@ELK ~]# java -version #测试\n2、安装logstash\n官网下载：https://www.elastic.co/cn/downloads/logstash\n[root@ELK ~]# wget https://artifacts.elastic.co/downloads/logstash/logstash-7.9.2.tar.gz [root@ELK ~]# tar xvf logstash-7.9.2.tar.gz -C /usr/local/ [root@ELK ~]# chown -R root:root /usr/local/logstash-7.9.2/ [root@ELK ~]# cd /usr/local/logstash-7.9.2/ [root@ELK ~]# bin/logstash -e \u0026lsquo;input { stdin { } } output { stdout {} }\u0026rsquo; #运行测试\n#测试，将logstash收集的内容写入到elasticsearch [root@ELK ~]# /usr/local/logstash-7.9.2/bin/logstash -e \u0026lsquo;input { stdin{} } output { elasticsearch { hosts =\u0026gt; \u0026ldquo;192.168.1.225:9200\u0026rdquo; } stdout{ codec =\u0026gt; rubydebug } }\u0026rsquo;\n3、logstash指定配置文件运行\n新建配置文件，用于收集syslog日志，监听514端口\n[root@ELK ~]# vim /root/mylogstash/logstash.conf input{ syslog { type =\u0026gt; \u0026ldquo;system-syslog\u0026rdquo; host =\u0026gt; \u0026ldquo;192.168.1.225\u0026rdquo; #监听本地哪个地址，默认0.0.0.0 port =\u0026gt; \u0026ldquo;514\u0026rdquo; } } output { elasticsearch { hosts =\u0026gt; [\u0026ldquo;192.168.1.225:9200\u0026rdquo;] } }\n加载配置文件并运行logstash\n[root@ELK ~]# /usr/local/logstash-7.9.2/bin/logstash -f /root/mylogstash/logstash.conf\n配置防火墙\n[root@ELK ~]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-port=514/tcp [root@ELK ~]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-port=514/udp [root@ELK ~]# firewall-cmd \u0026ndash;reload\n4、配置为服务并开机启动\n[root@ELK ~]# vim /usr/local/logstash-7.9.2/config/startup.options JAVACMD=/usr/local/java/bin/java #指定java二进制文件路径 LS_HOME=/usr/local/logstash-7.9.2/ #指定logstash目录 #LS_SETTINGS_DIR=/usr/local/logstash-7.9.2/config/ #注释该行 LS_OPTS=\u0026quot;-f /root/mylogstash/\u0026quot; LS_USER=root LS_GROUP=root\n[root@ELK ~]# /usr/local/logstash-7.9.2/bin/system-install #生成logstash.service文件 [root@ELK ~]# cat /etc/systemd/system/logstash.service [root@ELK ~]# systemctl enable logstash [root@ELK ~]# systemctl start logstash\n注意：使用logstash收集syslog日志并监听514端口时，必须使用root用户启动Logstash，因为Linux系统中对1024以下端口需要root权限\n四、安装Kibana 1、安装kibana\n官网：https://www.elastic.co/cn/downloads/kibana\n[root@ELK ~]# wget https://artifacts.elastic.co/downloads/kibana/kibana-7.9.2-linux-x86_64.tar.gz [root@ELK ~]# tar -xvf kibana-7.9.2-linux-x86_64.tar.gz -C /usr/local/ [root@ELK ~]# mv /usr/local/kibana-7.9.2-linux-x86_64/ /usr/local/kibana-7.9.2\n2、配置Kibana\n[root@ELK ~]# vim /usr/local/kibana-7.9.2/config/kibana.yml server.host: \u0026ldquo;192.168.1.225\u0026rdquo; #修改为本机IP地址，允许远程用户连接 elasticsearch.hosts: [\u0026ldquo;http://192.168.1.225:9200\u0026rdquo;] #修改为elasticsearch所在服务器地址\n3、前台运行Kibana\n[root@ELK ~]# cd /usr/local/kibana-7.9.2/ [root@ELK kibana-7.9.2]# bin/kibana\n4、配置防火墙\n[root@ELK ~]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-port=5601/tcp [root@ELK ~]# firewall-cmd \u0026ndash;reload\n5、浏览器访问：http://192.168.1.225:5601/\n6、将Kibana配置成服务开机启动\n[root@ELK ~]# useradd kibana -s /sbin/nologin [root@ELK ~]# chown -R kibana:kibana /usr/local/kibana-7.9.2/\n[root@ELK ~]# vim /lib/systemd/system/kibana.service [Unit] Description=Kibana After=network.target\n[Service] Type=simple User=kibana Group=kibana ExecStart=/usr/local/kibana-7.9.2/bin/kibana PIDFile=/var/run/kibana.pid Restart=always\n[Install] WantedBy=default.target\n启动\n[root@ELK ~]# systemctl enable kibana.service [root@ELK ~]# systemctl start kibana.service\n","permalink":"https://water711.github.io/posts/2020-10-17-centos7%E9%83%A8%E7%BD%B2elk%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F/","tags":null,"title":"Centos7部署ELK日志收集系统"},{"categories":["zabbix"],"contents":" 问题一、Zabbix server内存溢出，无法启动 问题原因：\n这是由于zabbix默认的缓存配置只有8M，当你zabbix正常运行一段时间后，大批量添加一些被监控设备就会出现这种情况。\n解决方法：\n打开zabbix_server.conf文件，将CacheSize改一个较大的值，我现在给自己配的是1024M。\nvim /etc/zabbix/zabbix_server.conf CacheSize=1024M #第385行\n问题二、Zabbix housekeeper processes more than 75% busy\n问题原因：\n由于zabbix每天都会产生大量数据（比如我现在监控项有20K+，每30s-5min每个监控项会产生一条数据，一天会产生非常多数据），为了防止数据库爆炸，zabbix会自动定期清理历史数据（这个历史数据保留时间值你可以在监控项中自己配置），但清理历史数据会影响mysql性能，就会出现上面的报错。\n解决方法：\n这里需要调整两个参数，一个是清理时间间隔、一个是清理的最大删除量。\nvim /etc/zabbix/zabbix_server.conf HousekeepingFrequency=12 #原值是每一小时清理一次，建议改为12或24小时清理一次。第363行 MaxHousekeeperDelete=100000 #原值为每次清理5000条，建议改为上限100000条。 第376行\n问题三、Zabbix poller processes more than 75% busy 问题原因：\n这里可能有如下两个原因：\n1、通过Zabbix agent采集数据的设备死机或其他原因导致zabbix agent死掉server获取不到数据。\n2、server向agent获取数据时时间过长，超过了server设置的timeout时间。\n解决方法：\n1、增加zabbix server启动时初始化的进程数量：\nvim /etc/zabbix/zabbix_server.conf StartPollers=12 #第165行，视自己服务器性能改，上限是1000，如果改完发现启不起来可以改小一点。\n2、修改模板自动发现规则中的保留失去的资源期间为0。\n问题四：Zabbix discoverer processes more than 75% busy 问题原因：\n看问题报警字面意思是自动发现进程忙碌数超过75%，这是因为我们用的监控模版中带着大量自动发现项，每一个自动发现项都会产生一个进程，所以一般我们添加多台被监控设备时就会出现这样的报错。\n解决办法：\n修改自动发现进程数。\nvim /etc/zabbix/zabbix_server.conf StartDiscoverers=10 #第219行，取掉#号，默认为1，改为10，上限为250请视自己的需求和服务器配置而定\n其次还可以通过执行定期重启server脚本来清理进程，释放内存。\n[root@m01 ~]# grep \u0026lsquo;StartDiscoverers\u0026rsquo; /etc/zabbix/zabbix_server.conf2 3 ### Option: StartDiscoverers4 5 StartDiscoverers=56 7 [root@m01 ~]# systemctl restart zabbix-server.service [root@m01 ~]# crontab -e2 3 @daily service zabbix-server restart \u0026gt; /dev/null 2\u0026gt;\u0026amp;14 5\n问题五：Zabbix alerter processes more than 75% busy 问题原因：\n这个问题通常是因为邮件告警进程过于繁忙导致的，如果邮件动作间隔设置过短，在一些极端情况下（比如核心网络宕了）会发生大量邮件（比如上万条邮件）告警，则会导致邮件进程繁忙或者邮件进程直接挂了。\n解决方法：\n修改邮件脚本，将邮件的动作改为打印时间，等待邮件完全释放再改回来，如下：\n[root@m01 ~]# cat /usr/lib/zabbix/alertscripts/sms 2 3 #!/bin/bash 4 5 echo `date` \u0026raquo;/tmp/sms.txt\n问题六：Zabbix poller processes more than 75% busy 问题原因：\n1、zabbix消耗的内存过多。\n2、某个进程卡住了。\n3、僵尸进程太多、出错、导致慢了。\n4、网络延时。\n解决方案：\n这里有两个解决方案，第一是修改zabbix_server.conf文件调优性能，第二是简单粗暴定期重启server释放进程。\nvim /etc/zabbix/zabbix_server.conf StartPollers=12 #第165行，我现在设置为12，如果你服务器性能够强可以继续增加，上限是1000\n其次是简单粗暴定期重启\nservice zabbix-server restart crontab -e 调出Cron编辑器中增加一个计划： @daily service zabbix-server restart \u0026gt; /dev/null 2\u0026gt;\u0026amp;1\n问题七：server端日志中出现大量first network error, wait for 15 seconds 问题原因：\n产生这个问题的主要原因是你的监控项执行时间过长，超过了默认配置的timeout=15s时间，这里只要将你的server、proxy和agent的conf文件中的timeout时间改长一点即可，上限是30s，如果30s还不够那就要改系统源码来突破这个上限了。\n解决方法：\nvim /etc/zabbix/zabbix_server.conf #这里以修改server端conf文件为例，其他两个类似的就不列举了 Timeout=30 #第448行\n问题八：More than 100 items having missing data for more than 10 minutes和Zabbix poller processes more than 75% busy 问题原因：\n这两个问题的主要原因是你配置的缓存或者进程数太少，导致监控项很多时服务器来不及处理。\n解决方法：\n直接增加server端进程数和缓存即可。\nvim /etc/zabbix/zabbix_server.conf StartPollers=500 StartPollersUnreachable=50 StartTrappers=30 StartDiscoverers=6 CacheSize=1G CacheUpdateFrequency=300 StartDBSyncers=20 HistoryCacheSize=512M TrendCacheSize=256M HistoryTextCacheSize=80M ValueCacheSize=1G #这里把关于该问题的可能性能项配置一起给到大家\n问题九：connection to database \u0026lsquo;zabbix\u0026rsquo; failed: [1040] Too many connections 问题原因：\n从字面意思上可以看出数据库的连接数已经超出最大限制。\n解决方法：\n直接修改mysql的最大连接数即可。\nvim /etc/my.cnf max_connections=1000 #将最大链接数调整为1000 systemctl restart mariadb.service #重启SQL\n问题十：批量添加大量被监控设备后出现服务端直接宕机，报警提示Zabbix value cache working in low memory mode Less than 25% free in the configuration cache。 问题原因：\n由于大量添加被监控设备，导致服务器内存溢出。\n解决方案：\nvim /etc/zabbix/zabbix_server.conf CacheSize=1024M #第385行\n问题十一：Zabbix alerter processes more than 75% busy 问题原因：\n从字面意思可以看出当你产生大量告警是即会出现这个报错，告警进程过多。\n解决方案：\n调整conf文件中的最大告警进程数即可。\nvim /etc/zabbix/zabbix_server.conf StartAlerters=3 #第254行，去掉#注释，修改为10，上限为100。\n问题十二：zabbix unreachable poller processes more than 75 busy 问题原因：\n产生这个问题的主要原因是zabbix server端轮询的不可达设备（被监控设备处于死机状态、agent与server数据传输超过timeout时间、mysql或zabbix server的io卡住了）过多导致。\n解决方案：\nvim /etc/zabbix/zabbix_server.conf StartPingers=12 #第165行，修改为12，上限是1000\n以上这些基本都是因为zabbix的zabbix_server.conf文件中的默认性能配置过低导致的错误，在日常使用中经常会遇到，只要进行简单配置后重新启动zabbix server即可解决。该贴会持续不定期更新我日常工作中遇到的各种问题\n原文链接：https://www.jianshu.com/p/2d911d55448f\n","permalink":"https://water711.github.io/posts/2020-10-16-zabbix%E8%B0%83%E4%BC%98%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/","tags":null,"title":"Zabbix调优不完全指南"},{"categories":["python"],"contents":" **公司有100多台S1720接入层交换机，没有购买License，只能使用Web界面进行配置，每次进行相同的操作需要花费大量时间，例如：修改密码、保存配置、导出配置、添加日志主机、添加NTP服务器等，**为节省重复且枯燥的操作，编写了下面脚本，操纵浏览器进行自动化配置。\n准备工作 1、安装Python\n2、安装谷歌浏览器\n3、下载chromedriver驱动，放到脚本所在目录\n4、新建IP.txt，保存所有交换机IP，放到脚本所在目录\n一、批量修改密码 # -*- coding : utf-8 -*-\nfrom selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait import time\nUserName = \u0026lsquo;admin\u0026rsquo; OldPassword = \u0026lsquo;admin@huawei.com\u0026rsquo; NewPassword = \u0026rsquo;newpassword123'\ndef open_broswer(): #新建options options = webdriver.ChromeOptions()\n#添加选项，禁止在控制台打印日志 options.add\\_experimental\\_option('excludeSwitches', \\['enable-logging'\\]) #添加选项，忽略网站SSL证书错误 options.add\\_argument('--ignore-certificate-errors') #载入options并启动浏览器 driver=webdriver.Chrome(options=options) return driver def alert_confirm(): \u0026rsquo;\u0026rsquo;' 解决以下页面弹框提示 Web网管支持的Chrome浏览器版本范围为:Chrome 54 ~ Chrome 66,为了更好的浏览体验,建议您使用Chrome 66版本浏览器 \u0026rsquo;\u0026rsquo;' try: alert = driver.switch_to.alert #切换到弹框窗口 alert.text driver.switch_to.alert.accept() #确认弹框 except: pass\ndef change_password(ip): print(ip) driver.get(\u0026ldquo;http://\u0026rdquo; + ip)\nalert\\_confirm() #确认弹框 #窗口最大化 driver.maximize\\_window() #输入账号 username = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('UserName')) username.send\\_keys(UserName) #输入密码 pwd = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('userPassword')) pwd.send\\_keys(OldPassword) #点击登录 submit = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('goBtn')) submit.click() time.sleep(6) #点击维护 maintenance = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('maintenance')) maintenance.click() time.sleep(6) #点击管理员 lswUser = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('lswUser')) lswUser.click() time.sleep(2) #点击第1个账号 tableTDContentuserName\\_0 = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('tableTDContentuserName\\_0')) tableTDContentuserName\\_0.click() time.sleep(2) #输入旧密码 uinp\\_oldPassword = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('uinp\\_oldPassword')) uinp\\_oldPassword.send\\_keys(OldPassword) #输入新密码 uinp\\_newPassword = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('uinp\\_newPassword')) uinp\\_newPassword.send\\_keys(NewPassword) #再次输入新密码 uinp\\_confirmPassword = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('uinp\\_confirmPassword')) uinp\\_confirmPassword.send\\_keys(NewPassword) #保存密码修改 btn\\_okDiv\\_uBtn = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('btn\\_okDiv\\_uBtn')) btn\\_okDiv\\_uBtn.click() time.sleep(1) #打开浏览器 driver = open_broswer()\n#遍历txt文件的ip地址 with open(\u0026lsquo;ip.txt\u0026rsquo;,\u0026lsquo;r\u0026rsquo;) as f: while 1: ip = f.readline().strip(\u0026rsquo;\\n\u0026rsquo;) if not ip: break change_password(ip) #执行函数，修改交换机密码\n二、批量保存交换机配置 # -*- coding : utf-8 -*-\nfrom selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait import time,datetime\nUserName = \u0026lsquo;admin\u0026rsquo; Password = \u0026lsquo;admin@huawei.com\u0026rsquo;\ndef open_broswer(): #新建options options = webdriver.ChromeOptions()\n#添加选项，禁止在控制台打印日志 options.add\\_experimental\\_option('excludeSwitches', \\['enable-logging'\\]) #添加选项，忽略网站SSL证书错误 options.add\\_argument('--ignore-certificate-errors') #载入options并启动浏览器 driver=webdriver.Chrome(options=options) return driver def alert_confirm(): \u0026rsquo;\u0026rsquo;\u0026rsquo; 解决以下页面弹框提示 Web网管支持的Chrome浏览器版本范围为:Chrome 54 ~ Chrome 66,为了更好的浏览体验,建议您使用Chrome 66版本浏览器 \u0026rsquo;\u0026rsquo;\u0026rsquo; try: alert = driver.switch_to.alert #切换到弹框窗口 alert.text driver.switch_to.alert.accept() #确认弹框 except: pass\ndef save_config(ip): print(ip) driver.get(\u0026ldquo;http://\u0026rdquo; + ip)\nalert\\_confirm() #确认弹框 driver.maximize\\_window() #窗口最大化 #输入账号 username = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('UserName')) username.send\\_keys(UserName) #输入密码 pwd = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('userPassword')) pwd.send\\_keys(Password) #点击登录 submit = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('goBtn')) submit.click() time.sleep(10) #登录完成后，需要等待7-8秒，才能保存，否则会提示系统正在加载，请稍后再试 #点击保存配置(交接机系统有两个版本，保存按钮的id不同，使用异常处理兼容两个版本) try: save = WebDriverWait(driver,3).until(lambda driver: driver.find\\_element\\_by\\_id('save')) save.click() except: sysSaveDiv\\_uBtn = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('sysSaveDiv\\_uBtn')) sysSaveDiv\\_uBtn.click() time.sleep(1) #点击确认保存配置 wconfirmBtn = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('wconfirmBtn')) wconfirmBtn.click() #等待保存完成 wconfirmBtn = WebDriverWait(driver,9999).until(lambda driver: driver.find\\_element\\_by\\_id('tipBtn')) wconfirmBtn.click() print(\u0026quot;保存成功\u0026quot;) #打开浏览器 driver = open_broswer()\n#遍历txt文件的ip地址 with open(\u0026lsquo;ip.txt\u0026rsquo;,\u0026lsquo;r\u0026rsquo;) as f: while 1: ip = f.readline().strip(\u0026rsquo;\\n\u0026rsquo;) if not ip: break save_config(ip) #执行函数，保存交换机配置\n三、批量导出交换机配置 # -*- coding : utf-8 -*-\nfrom selenium import webdriver from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.common.action_chains import ActionChains import time\nUserName = \u0026lsquo;admin\u0026rsquo; Password = \u0026lsquo;admin@huawei.com\u0026rsquo;\ndef open_browser(ip): #新建options options = webdriver.ChromeOptions()\n#添加选项，禁止在控制台打印日志 options.add\\_experimental\\_option('excludeSwitches', \\['enable-logging'\\]) #添加选项，忽略网站SSL证书错误 options.add\\_argument('--ignore-certificate-errors') #设置浏览器下载文件默认保存路径 path = 'F:\\\\\\\\config\\\\\\\\' + ip prefs = {'profile.default\\_content\\_settings.popups': 0, 'download.default\\_directory': path} options.add\\_experimental\\_option('prefs', prefs) #载入options并启动浏览器 driver=webdriver.Chrome(options=options) return driver def alert_confirm(): \u0026rsquo;\u0026rsquo;\u0026rsquo; 解决以下页面弹框提示 Web网管支持的Chrome浏览器版本范围为:Chrome 54 ~ Chrome 66,为了更好的浏览体验,建议您使用Chrome 66版本浏览器 \u0026rsquo;\u0026rsquo;\u0026rsquo; try: alert = driver.switch_to.alert #切换到弹框窗口 alert.text driver.switch_to.alert.accept() #确认弹框 except: pass\ndef export_config(ip,driver): print(ip) driver.get(\u0026ldquo;http://\u0026rdquo; + ip)\nalert\\_confirm() #确认弹框 driver.maximize\\_window() #窗口最大化 #输入账号 username = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('UserName')) username.send\\_keys(UserName) #输入密码 pwd = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('userPassword')) pwd.send\\_keys(Password) #输入密码 submit = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('goBtn')) submit.click() time.sleep(7) #点击维护 maintenance = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('maintenance')) maintenance.click() time.sleep(7) #点击系统管理 lswSysManager = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('lswSysManager')) lswSysManager.click() time.sleep(9) #搜索文件 uinp\\_searchFileComboInput = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('uinp\\_searchFileComboInput')) uinp\\_searchFileComboInput.send\\_keys(\u0026quot;vrpcfg\u0026quot;) #模拟键盘回车按键 ActionChains(driver).send\\_keys(Keys.ENTER).perform() time.sleep(1) #点击下载 tableTDContentfileOperate\\_0 = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_xpath('//\\*\\[@id=\u0026quot;tableTDContentfileOperate\\_0\u0026quot;\\]/img')) tableTDContentfileOperate\\_0.click() time.sleep(3) print(\u0026quot;保存成功\u0026quot;) driver.quit() with open(\u0026lsquo;ip.txt\u0026rsquo;,\u0026lsquo;r\u0026rsquo;) as f: while 1: ip = f.readline().strip(\u0026rsquo;\\n\u0026rsquo;) if not ip: break driver = open_browser(ip) export_config(ip,driver)\n四、批量添加交换机日志主机 # -*- coding : utf-8 -*-\nfrom selenium import webdriver from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.common.action_chains import ActionChains import time\nUserName = \u0026lsquo;admin\u0026rsquo; Password = \u0026lsquo;admin@huawei.com\u0026rsquo; log_host_ip = \u0026lsquo;192.168.1.225\u0026rsquo; #日志主机IP\ndef open_broswer(): #新建options options = webdriver.ChromeOptions()\n#添加选项，禁止在控制台打印日志 options.add\\_experimental\\_option('excludeSwitches', \\['enable-logging'\\]) #添加选项，忽略网站SSL证书错误 options.add\\_argument('--ignore-certificate-errors') #载入options并启动浏览器 driver=webdriver.Chrome(options=options) return driver def alert_confirm(): \u0026rsquo;\u0026rsquo;\u0026rsquo; 解决以下页面弹框提示 Web网管支持的Chrome浏览器版本范围为:Chrome 54 ~ Chrome 66,为了更好的浏览体验,建议您使用Chrome 66版本浏览器 \u0026rsquo;\u0026rsquo;\u0026rsquo; try: alert = driver.switch_to.alert #切换到弹框窗口 alert.text driver.switch_to.alert.accept() #确认弹框 except: pass\ndef add_log_host(ip): print(ip) driver.get(\u0026ldquo;http://\u0026rdquo; + ip)\nalert\\_confirm() #确认弹框 driver.maximize\\_window() #窗口最大化 #输入账号 username = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('UserName')) username.send\\_keys(UserName) #输入密码 pwd = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('userPassword')) pwd.send\\_keys(Password) #点击登录 submit = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('goBtn')) submit.click() time.sleep(7) #点击维护 maintenance = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('maintenance')) maintenance.click() time.sleep(5) #点击日志 lswLogManager = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('lswLogManager')) lswLogManager.click() time.sleep(2) #点击参数配置 parameterConfig\\_tab = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('parameterConfig\\_tab')) parameterConfig\\_tab.click() #点击添加日志主机 add\\_btn\\_uBtn = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('add\\_btn\\_uBtn')) add\\_btn\\_uBtn.click() time.sleep(1) ActionChains(driver).send\\_keys(log\\_host\\_ip).perform() #点击确定 btnObj\\_1 = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('btnObj\\_1')) btnObj\\_1.click() time.sleep(1) #再次点击确定 tipBtn = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('tipBtn')) tipBtn.click() time.sleep(1) #点击保存配置 try: save = WebDriverWait(driver,3).until(lambda driver: driver.find\\_element\\_by\\_id('save')) save.click() except: sysSaveDiv\\_uBtn = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('sysSaveDiv\\_uBtn')) sysSaveDiv\\_uBtn.click() time.sleep(1) #确认保存配置 wconfirmBtn = WebDriverWait(driver,999).until(lambda driver: driver.find\\_element\\_by\\_id('wconfirmBtn')) wconfirmBtn.click() time.sleep(3) #打开浏览器 driver = open_broswer()\n#遍历txt文件的ip地址 with open(\u0026lsquo;ip.txt\u0026rsquo;,\u0026lsquo;r\u0026rsquo;) as f: while 1: ip = f.readline().strip(\u0026rsquo;\\n\u0026rsquo;) if not ip: break add_log_host(ip)\n","permalink":"https://water711.github.io/posts/2020-10-09-pythonselenium-%E6%89%B9%E9%87%8F%E9%85%8D%E7%BD%AE%E5%8D%8E%E4%B8%BAs1720%E4%BA%A4%E6%8D%A2%E6%9C%BA/","tags":null,"title":"python+selenium 批量配置华为S1720交换机"},{"categories":["linux"],"contents":" 一、安装FTP服务 1、安装vsftpd软件\n[root@FTP ~]# yum -y install vsftpd\n2、防火墙放行FTP服务\n[root@FTP ~]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-service=ftp\n[root@FTP ~]# firewall-cmd \u0026ndash;reload\n3、启动服务\n[root@FTP ~]# systemctl start vsftpd [root@FTP ~]# systemctl enable vsftpd\n4、测试\n该匿名用户目录位于：/var/ftp/pub/\n二、关闭匿名用户 1、修改配置文件\n[root@FTP ~]# vim /etc/vsftpd/vsftpd.conf anonymous_enable=NO\n2、重启服务\n#重启服务 [root@FTP vsftpd]# systemctl restart vsftpd\n3、测试\n三、FTP开启root用户访问（不建议） 1、将root从禁止登录列表中移除\n[root@FTP ~]# vim /etc/vsftpd/ftpusers #root\n[root@FTP ~]# vim /etc/vsftpd/user_list #root\n2、关闭selinux\n[root@FTP ~]# setenforce 0\n四、新建用户用于FTP访问 1、新建用户\n[root@FTP ~]# useradd test [root@FTP ~]# passwd test\n2、新建测试文件\n[root@FTP ~]# su - test [test@FTP ~]$ touch file1.txt\n3、修改ftp配置文件\n[test@FTP ~]$ vim /etc/vsftpd/vsftpd.conf chroot_local_user=YES #限制用户只能访问为其配置的目录\n4、去除用户主目录的写权限\n[test@FTP ~]$ chmod a-w /home/test/\nps：从2.3.5之后，vsftpd增强了安全检查，如果用户被限定在了其主目录下，则该用户的主目录不能再具有写权限了！如果检查发现还有写权限，就会报下面错误。 500 OOPS: vsftpd: refusing to run with writable root inside chroot ()\n5、测试\n地址格式： ftp://username:password@hostname:port\n五、其它参数设置 [root@FTP ~]# vim /etc/vsftpd/vsftpd.conf local_max_rate=200k //设置本地用户最大的传输速率为200kbps anon_max_rate=10k //设置匿名用户最大的传输速率为10kbps\n六、配置TLS/SSL，实现加密传输 1、安装openssl\n[root@NAS ~]# yum install -y openssl\n2、生成SSL证书\n[root@NAS ~]# openssl req -x509 -nodes -days 365 -newkey rsa:1024 \\ -keyout /etc/vsftpd/vsftpd.pem \\ -out /etc/vsftpd/vsftpd.pem\nCountry Name (2 letter code) [XX]:bj #输入国家 State or Province Name (full name) []:bj #输入省份 Locality Name (eg, city) [Default City]: #输入城市 Organization Name (eg, company) [Default Company Ltd]: 3输入公司/组织 Organizational Unit Name (eg, section) []:test #输入公司/组织简称 Common Name (eg, your name or your server\u0026rsquo;s hostname) []:test #输入主机名称 Email Address []:123@qq.com #输入邮件地址\n3、修改配置文件\n[root@NAS ~]# vim /etc/vsftpd/vsftpd.conf #在最后面添加以下配置参数 ssl_enable=YES allow_anon_ssl=NO force_local_data_ssl=NO force_local_logins_ssl=NO ssl_tlsv1=YES ssl_sslv2=NO ssl_sslv3=NO rsa_cert_file=/etc/vsftpd/vsftpd.pem\n4、重启服务\n[root@NAS ~]# systemctl restart vsftpd\n","permalink":"https://water711.github.io/posts/2020-10-05-centos7%E9%83%A8%E7%BD%B2ftp%E6%9C%8D%E5%8A%A1/","tags":null,"title":"Centos7部署FTP服务"},{"categories":["other"],"contents":" 一、打开事件查看器\n点击 控制面板-\u0026gt; 管理工具 -\u0026gt; 事件查看器，或者在cmd命令行下输入 eventvwr\n二、连接服务器查看日志\n1、菜单栏 -\u0026gt; 操作 -\u0026gt; 连接到另一台计算机\n2、输入服务器IP和账号密码（该账号需要有日志查看权限）\n注意：用户名前面的计算机名称要保留，计算机名称任意即可，\n如果删掉前面计算机名称，确认后会自动带上本机的计算机名称和用户名，导致登录失败\n三、创建自定义视图\n1、在**“操作”菜单上，单击“创建自定义视图”**\n2、选择需要查看的“**日志类型”**和“事件级别”\n3、输入自定义视图名称\n四、重复前面三步，连接服务器并创建视图\n","permalink":"https://water711.github.io/posts/2020-10-05-windows%E4%BA%8B%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%99%A8-%E8%BF%9E%E6%8E%A5%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97/","tags":null,"title":"windows事件查看器 连接多台服务器查看日志"},{"categories":["other"],"contents":"可能出现原因： 服务端机器，禁用了默认管理员和来宾账户\n例如： 客户端机器当前使用的是administrator账户，访问服务端时，默认是用这个账户来作为用户名登录，但是由于服务端的administrator账号是禁用状态，服务器返回这个账户禁止，客户端不再提示用户输入用户名和密码，直接终止共享访问\n解决办法： 方法1：本机建立一个新账户，再通过新账户而不是同名的administrator账户去访问共享服务端就不会出现“登录失败:禁用的当前账户”，会直接提示输入密码 方法2：修改服务器端的访问模式，让everyone都能访问，并启用来宾账户，客户端以guest登录 方法3：客户端打开cmd命令提示符，输入net use \\\\ip\\共享文件夹 /user:用户名，回车后输入密码，再通过\\\\ip就能访问共享文件夹了\n","permalink":"https://water711.github.io/posts/2020-09-22-win7%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E6%8F%90%E7%A4%BA%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5%E7%A6%81%E7%94%A8%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7/","tags":null,"title":"win7访问共享文件，提示\"登录失败：禁用当前用户\""},{"categories":["linux"],"contents":"方式一、MySQL Yum Repository 官方安装文档：http://dev.mysql.com/doc/refman/8.0/en/linux-installation-yum-repo.html\n1、访问官网：https://www.mysql.com/downloads/\n2、点击：MySQL Community (GPL) Downloads »\n3、点击：MySQL Yum Repository，复制下载链接\n4、下载对应操作系统版本的RPM包\n[root@server1 ~]# wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm\n5、安装mysql yum源\n[root@server1 ~]# rpm -ivh mysql80-community-release-el7-3.noarch.rpm\n6、查看当前启用的默认安装版本\n[root@server1 ~]# yum repolist enabled | grep \u0026ldquo;mysql\u0026rdquo;\n如果不是我们需要的版本，则要修改yum仓库文件\n[root@server1 ~]# vim /etc/yum.repos.d/mysql-community.repo\n#将enable设为1，启用需要安装的版本\n7、安装mysql\n[root@server1 ~]# yum install mysql-server\n8、启动mysql\n#centos7启动mysql [root@server1 ~]# systemctl start mysqld [root@server1 ~]# systemctl enable mysqld\n#centos6启动mysql前需要关闭selinux，否则mysql初始化会失败 [root@server1 ~]# setenforce 0 [root@server1 ~]# service mysqld start\n9、查看mysql初始密码\n[root@server1 ~]# grep \u0026rsquo;temporary password\u0026rsquo; /var/log/mysqld.log\n10、登录mysql并修改密码\n[root@server1 ~]# mysql -uroot -p\nmysql\u0026gt; alter user \u0026lsquo;root\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; IDENTIFIED BY \u0026lsquo;password\u0026rsquo;;\n方式二、二进制预编译安装 官方安装文档：https://dev.mysql.com/doc/refman/8.0/en/binary-installation.html\n1、访问官网：https://dev.mysql.com/downloads/mysql/\n2、选择MySQL Community Server -\u0026gt; \u0026ldquo;Linux - Generic\u0026rdquo;，下载预编译压缩包\n[root@server1 ~]# wget \u0026ndash;no-check-certificate https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.21-linux-glibc2.12-x86_64.tar.xz\n3、安装依赖库\nyum -y install libaio\n4、配置mysql\n[root@server1 ~]# groupadd mysql [root@server1 ~]# useradd -r -g mysql -s /bin/false mysql [root@server1 ~]# mv mysql-8.0.21-linux-glibc2.12-x86_64.tar.xz /usr/local [root@server1 ~]# cd /usr/local [root@server1 local]# tar xvf mysql-8.0.21-linux-glibc2.12-x86_64.tar.xz [root@server1 local]# ln -s mysql-8.0.21-linux-glibc2.12-x86_64 mysql [root@server1 local]# cd mysql\n#删除mariadb的配置文件，mysql启动时会默认加载该配置文件，导致启动失败 [root@server1 mysql]# rm /etc/my.cnf\n初始化mysql，会生成root初始化密码，注意保存 [root@server1 mysql]# bin/mysqld \u0026ndash;initialize \u0026ndash;user=mysql\n#（可选）创建SSL自签名证书、密钥文件和RSA密钥对文件 [root@server1 mysql]# bin/mysql_ssl_rsa_setup\n5、启动mysql并修改密码\n#启动mysql [root@salt01 mysql]# bin/mysqld_safe \u0026ndash;user=mysql \u0026amp;\n#本地连接mysql [root@server1 mysql]# bin/mysql -uroot -p\n#修改mysql密码 mysql\u0026gt; ALTER USER \u0026lsquo;root\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; IDENTIFIED BY \u0026lsquo;password\u0026rsquo;;\n6、将mysql添加到系统服务\n[root@server1 ~]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld [root@server1 ~]# chkconfig \u0026ndash;add mysqld [root@server1 ~]# systemctl restart mysqld\n7、设置环境变量\n[root@server1 ~]# vim /etc/profile export MYSQL_HOME=/usr/local/mysql export PATH=$PATH:$MYSQL_HOME/bin\n[root@server1 ~]# source /etc/profile\n8、配置防火墙，开放3306端口\n[root@server1 ~]# firewall-cmd \u0026ndash;permanent \u0026ndash;zone=public \u0026ndash;add-port=3306/tcp [root@server1 ~]# firewall-cmd \u0026ndash;reload\n方式三、源码安装 官方安装文档：https://dev.mysql.com/doc/refman/8.0/en/source-installation.html\n知悉：\na. mysql从5.5版本开始，不再使用./configure编译，而是使用cmake编译器\nb. mysql从8.0.16版本开始，要求cmake的版本是cmake3以上\nc. centos7.6默认安装的是cmake2.8.12.2和gcc4.8.5，编译前需要升级到cmake3和gcc5.3以上版本\nd. 最好先卸载mariadb和删除/etc/my.cnf文件，mysql启动时会默认加载该配置文件，导致在安装参数里的设置无效，引发一系列错误\n1、访问官网：https://dev.mysql.com/downloads/\n2、选择 MySQL Community Server -\u0026gt; \u0026ldquo;Source Code\u0026rdquo; -\u0026gt; \u0026ldquo;Generic Linux\u0026rdquo;，下载源码\n[root@server1 ~]# wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.21.tar.gz\n3、安装依赖\n[root@server1 ~]# yum -y install gcc gcc-c++ ncurses ncurses-devel libaio-devel openssl openssl-devel\n4、编译前配置\n[root@server1 ~]# rm /etc/my.cnf #删除mariadb的配置文件 [root@server1 ~]# groupadd mysql [root@server1 ~]# useradd -r -g mysql -s /bin/false mysql [root@server1 ~]# tar zxvf mysql-8.0.21.tar.gz\nyum默认安装cmake版本为2.8.12.2，编译mysql会提示以下错误：\n-- Running cmake version 2.8.12.2 CMake Warning at CMakeLists.txt:71 (MESSAGE): Please use cmake3 rather than cmake on this platform\n\u0026ndash; Please install cmake3 (yum install cmake3) CMake Error at CMakeLists.txt:101 (CMAKE_MINIMUM_REQUIRED): CMake 3.5.1 or higher is required. You are running version 2.8.12.2\n4、安装gcc5.3及上版本\n[root@server1 ~]# gcc -v [root@localhost ~]# yum -y install centos-release-scl #安装scl源 [root@server1 ~]# yum list|grep gcc #列出可安装的gcc版本 [root@server1 ~]# yum -y install devtoolset-8-gcc* #安装gcc8 [root@server1 ~]# source /opt/rh/devtoolset-8/enable #临时切换gcc为新版本 [root@server1 ~]# gcc -v [root@server1 ~]# vim ~/.bashrc #将切换gcc版本命令加入开机启动脚本\n5、安装cmake3\ncmake官网：http://www.cmake.org/\n[root@server1 ~]# yum -remove cmake -y #如果有旧版本，先移除 [root@server1 ~]# wget https://github.com/Kitware/CMake/releases/download/v3.18.2/cmake-3.18.2.tar.gz [root@server1 ~]# tar zxvf cmake-3.18.2.tar.gz [root@server1 ~]# gcc -v #编译前确保gcc版本升级到8.0以上 [root@server1 ~]# cd cmake-3.18.2 [root@server1 cmake-3.18.2]# ./bootstrap [root@server1 cmake-3.18.2]# gmake \u0026amp;\u0026amp; gmake install [root@server1 cmake-3.18.2]# cmake \u0026ndash;version\n6、编译\n编译参数官方文档：https://dev.mysql.com/doc/refman/8.0/en/source-configuration-options.html\n[root@server1 ~]# cd mysql-8.0.21 [root@server1 mysql-8.0.21]# mkdir bld [root@server1 mysql-8.0.21]# cd bld [root@server1 bld]#\n[root@server1 ~]# cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\ -DSYSCONFDIR=/usr/local/mysql \\ -DMYSQL_UNIX_ADDR=/data/mysql/mysql.sock \\ -DDEFAULT_CHARSET=utf8mb4 \\ -DWITH_SSL=system \\ -DWITH_ARCHIVE_STORAGE_ENGINE=1 \\ -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\ -DWITH_INNODB_MEMCACHED=ON \\ -DMYSQL_TCP_PORT=3306 \\ -DDOWNLOAD_BOOST=1 \\ -DWITH_BOOST=/tmp \\ -DMYSQL_DATADIR=/data/mysql\n[root@server1 bld]# make -j 4 \u0026amp;\u0026amp; make install\n7、编译后配置\n[root@server1 ~]# mkdir -p /data/mysql [root@server1 ~]# chown mysql:mysql -R /data/mysql [root@server1 ~]# cd /usr/local/mysql [root@server1 mysql]# bin/mysqld \u0026ndash;initialize \u0026ndash;user=mysql # 初始化mysql，会生成root初始化密码，注意保存\n8、启动mysql并修改密码\n#启动mysql [root@salt01 mysql]# bin/mysqld_safe \u0026ndash;user=mysql \u0026amp;\n#本地连接mysql [root@server1 mysql]# bin/mysql -uroot -p\n#修改mysql密码 mysql\u0026gt; ALTER USER \u0026lsquo;root\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; IDENTIFIED BY \u0026lsquo;password\u0026rsquo;;\n9、添加mysql到系统服务\n[root@server1 ~]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld [root@server1 ~]# chmod 755 /etc/init.d/mysqld [root@server1 ~]# chkconfig mysqld on [root@server1 ~]# systemctl restart mysqld\n10、设置环境变量\n[root@server1 ~]# vim /etc/profile export MYSQL_HOME=/usr/local/mysql export PATH=$PATH:$MYSQL_HOME/bin\n[root@server1 ~]# source /etc/profile\n11、配置防火墙，开放3306端口\n[root@server1 ~]# firewall-cmd \u0026ndash;permanent \u0026ndash;zone=public \u0026ndash;add-port=3306/tcp [root@server1 ~]# firewall-cmd \u0026ndash;reload\n出现的问题 1、mysql启动失败\n[root@server1 ~]# systemctl start mysqld mysqld[23082]: mysqld_safe error: log-error set to \u0026lsquo;/var/log/mariadb/mariadb.log\u0026rsquo;, however file don\u0026rsquo;t exists. Create writable for user \u0026lsquo;mysql\u0026rsquo;. mysqld[23082]: ERROR! The server quit without updating PID file (/var/lib/mysql/server1.pid)\n原因：初始化mysql时，系统中还残留mariadb配置\n解决方法：\n[root@server1 ~]# rm /etc/my.cnf #删除mariadb残留的配置文件 [root@server1 mysql]# bin/mysqld \u0026ndash;initialize \u0026ndash;user=mysql #重新初始化\n2、编译cmake3，在执行 ./bootstrap 过程中出现下面提示\nCMake Error at CMakeLists.txt:107 (message): The C++ compiler does not support C++11 (e.g. std::unique_ptr).\n解决方法：执行第4步操作，升级gcc版本，重新编译cmake3（最好删除cmake3目录重新解压），如果还不行，重启系统再进行编译\n3、编译mysql，出现下面提示\nCMake Error at cmake/boost.cmake:106 (MESSAGE): You can download it with -DDOWNLOAD_BOOST=1 -DWITH_BOOST=\n解决方法：编译时添加参数\n-DDOWNLOAD_BOOST=1，表示系统会自动下载解压boost，若已下载，请将该参数置0\ncmake -DDOWNLOAD_BOOST=1 -DWITH_BOOST=/tmp\n","permalink":"https://water711.github.io/posts/2020-08-23-centos7%E5%AE%89%E8%A3%85mysql8-0/","tags":null,"title":"Centos7安装mysql8.0"},{"categories":["linux","zabbix"],"contents":"效果展示 实现方式 服务号 订阅号 -》 测试号（本文使用测试号演示） 一、注册微信公众号 服务号需要是企业身份，并进行微信认证\n个人可以申请订阅号后，开启测试号获取模板消息接口来进行测试\n二、开通模板消息并设置告警模板 服务号：公众号后台-》添加功能-》模板消息\n测试号：\n三、编写Python脚本 #!/usr/local/python3/bin/python3\nimport requests import json import sys\ndef get_token(appid, secret): url = \u0026ldquo;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential\u0026amp;appid=\u0026rdquo; + appid + \u0026ldquo;\u0026amp;secret=\u0026rdquo; + secret response = requests.get(url) ret = response.json() return ret[\u0026lsquo;access_token\u0026rsquo;]\ndef send_message(token): url = \u0026ldquo;https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=\u0026rdquo; + token data = { \u0026ldquo;touser\u0026rdquo;:to_user, \u0026ldquo;template_id\u0026rdquo;:template_id, \u0026ldquo;data\u0026rdquo;:{ \u0026ldquo;keyword1\u0026rdquo;:{ \u0026ldquo;value\u0026rdquo;:event_time, \u0026ldquo;color\u0026rdquo;:\u0026quot;#993399\u0026quot; }, \u0026ldquo;keyword2\u0026rdquo;: { \u0026ldquo;value\u0026rdquo;:host_name, \u0026ldquo;color\u0026rdquo;:\u0026quot;#0099CC\u0026quot; }, \u0026ldquo;keyword3\u0026rdquo;: { \u0026ldquo;value\u0026rdquo;:event_name, \u0026ldquo;color\u0026rdquo;:\u0026quot;#FF0000\u0026quot; } } } data = json.dumps(data) response = requests.post(url ,data=data)\nappid = \u0026ldquo;wx11111111111111\u0026rdquo; #公众号appid secret = \u0026ldquo;fa582222222222222222222\u0026rdquo; ##公众号secret template_id = \u0026ldquo;3mYrEo_MB8rCsBoPBF5h80nsjYR2koGnZ\u0026rdquo; #公众号模板ID\nto_user = sys.argv[1] # zabbix运行脚本时传入的第1个参数 message = sys.argv[2].split(\u0026rsquo;;\u0026rsquo;) # zabbix运行脚本时传入的第2个参数\nevent_time = message[0] host_name = message[1] event_name = message[2]\ntoken = get_token(appid, secret) send_message(token)\n将脚本移动到Zabbix指定脚本目录\n[root@zabbix ]# cat /etc/zabbix/zabbix_server.conf | grep AlertScriptsPath #查看zabbix配置文件，找到存放脚本的目录\n[root@zabbix ]# chmod +x alert_weixin.py [root@zabbix ]# mv alert_weixin.py /usr/lib/zabbix/alertscripts/\n四、配置Zabbix 1、创建报警媒介类型：管理-\u0026gt;报警媒介类型-\u0026gt;创建媒体类型\n2、为用户添加报警媒介：管理-\u0026gt;用户-\u0026gt;报警媒介-\u0026gt;添加\n类型：微信公众号（报警媒介类型）\n收件人：公众号用户oppenid（对应{ALERT.SENDTO}变量，将传入脚本第1个参数）\n3、配置事件触发后的动作\n","permalink":"https://water711.github.io/posts/2020-08-08-zabbix%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%91%8A%E8%AD%A6/","tags":null,"title":"Zabbix之使用微信公众号告警"},{"categories":["python"],"contents":"github地址 前后端：https://github.com/water711/Django_echarts_bootstrap\n微信小程序：https://github.com/water711/echarts-keliu-wechat\nPC端效果展示： 微信小程序端展示 ","permalink":"https://water711.github.io/posts/2020-07-30-djangoechartsbootstrap%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","tags":null,"title":"Django+Echarts+Bootstrap实现数据可视化"},{"categories":["python"],"contents":"datetime是Python处理日期和时间的标准库。\n官方文档：https://docs.python.org/3/library/datetime.html\nfrom datetime import datetime,timedelta\n#获取当前日期时间 now = datetime.now()\n#str转换为datetime mday = datetime.strptime(\u0026lsquo;2020-01-01 12:10:55\u0026rsquo;, \u0026lsquo;%Y-%m-%d %H:%M:%S\u0026rsquo;) print(mday) # 2020-01-01 12:10:55 print(type(mday)) # \u0026lt;class \u0026lsquo;datetime.datetime\u0026rsquo;\u0026gt;\n#datetime转换为str(将字符串格式化为datetime) s = mday.strftime(\u0026rsquo;%Y-%m-%d %H:%M:%S\u0026rsquo;) print(s) # 2020-01-01 12:10:55 print(type(s)) # \u0026lt;class \u0026lsquo;str\u0026rsquo;\u0026gt;\n#datetime加减(需要导入timedelta类) day1 = mday + timedelta(days=2) #2020-01-03 12:10:55 day2 = mday + timedelta(hours=5) #2020-01-01 17:10:55 day3 = mday - timedelta(days=5, hours=6) #2019-12-27 06:10:55\n#打印一年的日期 start_date = datetime.strptime(\u0026lsquo;2019-01-01\u0026rsquo;,\u0026rsquo;%Y-%m-%d\u0026rsquo;) for i in range(0,365): ndate = start_date + timedelta(days=i) ndate = str(ndate).split(\u0026quot; \u0026ldquo;)[0] #将日期和时间切割出来，取日期 print(ndate)\n","permalink":"https://water711.github.io/posts/2020-07-27-python-datetime%E6%A8%A1%E5%9D%97/","tags":null,"title":"python datetime模块"},{"categories":["other"],"contents":" 1、播放器右键-》选项-》3D视频-》点击安装（H.264 MVC解码）自动打开网页进行下载\n2、安装完解码器后，点击选项-》滤镜-》视频解码器-》选择 FFmpeg.dll\n","permalink":"https://water711.github.io/posts/2020-07-03-%E8%A7%A3%E5%86%B3potplayer%E4%B8%8D%E6%94%AF%E6%8C%81s-w-hevch265%E8%A7%A3%E7%A0%81/","tags":null,"title":"解决PotPlayer不支持S/W HEVC(H265)解码"},{"categories":["python"],"contents":"来源某国外视频：https://www.bilibili.com/video/BV1E4411f7Q1\n环境 Python：3.7.0\nOpenCV：3.4.3.18\n# -*- coding:utf-8 -*-\nimport cv2 import numpy as np import math cap = cv2.VideoCapture(0)\nwhile(1):\nret, frame = cap.read() frame = cv2.flip(frame,1) kernel = np.ones((3,3), np.uint8) # define region of interest roi = frame\\[100:300, 100:300\\] cv2.rectangle(frame,(100,100),(300,300),(0,255,0),0) hsv = cv2.cvtColor(roi, cv2.COLOR\\_BGR2HSV) # define range of skin color in HSV lower\\_skin = np.array(\\[0,20,70\\], dtype=np.uint8) upper\\_skin = np.array(\\[20,255,255\\], dtype=np.uint8) #extract skin color image mask = cv2.inRange(hsv, lower\\_skin, upper\\_skin) #extrapolate the hand to fill dark spots within mask = cv2.dilate(mask,kernel,iterations = 4) #blur the image mask = cv2.GaussianBlur(mask,(5,5),100) #find contours \\_, contours, hierarchy = cv2.findContours(mask, cv2.RETR\\_TREE, cv2.CHAIN\\_APPROX\\_SIMPLE) #find contour of max area(hand) cnt = max(contours, key = lambda x: cv2.contourArea(x)) #apprax the contour a little epsilon = 0.0005\\*cv2.arcLength(cnt,True) approx = cv2.approxPolyDP(cnt,epsilon,True) #make convex hull around hand hull = cv2.convexHull(cnt) #define area of hull and area of hand areahull = cv2.contourArea(hull) areacnt = cv2.contourArea(cnt) #find the percentage of area not covered by hand in convex hull arearatio = ((areahull-areacnt)/areacnt)\\*100 #find the defects in convex hull with respect to hand hull = cv2.convexHull(approx, returnPoints=False) defects = cv2.convexityDefects(approx, hull) #i = no. of defects l=0 #code for finding no of defects due to fingers for i in range(defects.shape\\[0\\]): s,e,f,d = defects\\[i,0\\] start = tuple(approx\\[s\\]\\[0\\]) end = tuple(approx\\[e\\]\\[0\\]) far = tuple(approx\\[f\\]\\[0\\]) pt = (100,100) #find lergth of all sides of triungle a = math.sqrt((end\\[0\\] - start\\[0\\])\\*\\*2 + (end\\[1\\] - start\\[1\\])\\*\\*2) b = math.sqrt((far\\[0\\] - start\\[0\\])\\*\\*2 + (far\\[1\\] - start\\[1\\])\\*\\*2) c = math.sqrt((end\\[0\\] - far\\[0\\])\\*\\*2 + (end\\[1\\] - far\\[1\\])\\*\\*2) s = (a+b+c)/2 ar = math.sqrt(s\\*(s-a)\\*(s-b)\\*(s-c)) #distance between point and convex hull d = (2\\*ar)/a # apply consine rule here angle = math.acos((b\\*\\*2 + c\\*\\*2 - a\\*\\*2)/(2\\*b\\*c)) \\* 57 # ignore anggles \u0026gt; 90 and ignore points very close to convex hull if angle \u0026lt;= 90 and d\u0026gt;30: l += 1 cv2.circle(roi, far, 3, \\[255,0,0\\], -1) #draw lines around hand cv2.line(roi, start, end, \\[0,255,0\\], 2) l+=1 #print corresponding gestures which are in their ranges font = cv2.FONT\\_HERSHEY\\_SIMPLEX if l==1: if areacnt\u0026lt;20000: cv2.putText(frame, 'Put hand in the box',(0,50), font, 2, (0,0,255), 3, cv2.LINE\\_AA) else: if arearatio\u0026lt;12: cv2.putText(frame, '0',(0,50), font, 2, (0,0,255), 3, cv2.LINE\\_AA) elif arearatio\u0026lt;17.5: cv2.putText(frame, 'Best of luck', (0,50), font, 2, (0,0,255), 3, cv2.LINE\\_AA) else: cv2.putText(frame, '1',(0,50), font, 2, (0,0,255), 3, cv2.LINE\\_AA) elif l==2: cv2.putText(frame, '2',(0,50), font, 2, (0,0,255), 3, cv2.LINE\\_AA) elif l==3: if arearatio\u0026lt;27: cv2.putText(frame, '3', (0,50), font, 2, (0,0,255), 3, cv2.LINE\\_AA) else: cv2.putText(frame, 'ok', (0,50), font, 2, (0,0,255), 3, cv2.LINE\\_AA) elif l==4: cv2.putText(frame, '4', (0, 50), font, 2, (0, 0, 255), 3, cv2.LINE\\_AA) elif l == 5: cv2.putText(frame, '5', (0, 50), font, 2, (0, 0, 255), 3, cv2.LINE\\_AA) elif l == 4: cv2.putText(frame, '5', (0, 50), font, 2, (0, 0, 255), 3, cv2.LINE\\_AA) elif l == 4: cv2.putText(frame, 'reposition', (0, 50), font, 2, (0, 0, 255), 3, cv2.LINE\\_AA) else: cv2.putText(frame, 'reposition', (10, 50), font, 2, (0, 0, 255), 3, cv2.LINE\\_AA) #show the windows cv2.imshow('mask', mask) cv2.imshow('frame', frame) k = cv2.waitKey(25) \u0026amp; 0xFF if k == 27: break cv2.destroyAllwindows() cap.release()\n","permalink":"https://water711.github.io/posts/2020-06-17-%E4%BD%BF%E7%94%A8pythonopencv%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/","tags":null,"title":"使用Python+OpenCV实现手势识别"},{"categories":["python"],"contents":" 一、注册讯飞开放平台账号 1、官网注册：https://www.xfyun.cn/\n2、进入讯飞控制台，创建应用\n3、点击应用，查看APPID、APISecret和APIKey\n二、查看文档，下载Demo WebAPI 文档：https://www.xfyun.cn/doc/asr/voicedictation/API.html\n三、录制音频，并使用ffmpeg转码 支持的音频格式\n讯飞音频格式说明：https://www.xfyun.cn/doc/asr/voicedictation/Audio.html\n1、官网下载ffmpeg，windows下载已编译版本\n2、命令行，进入ffmpeg\\bin目录，进行转码\nffmpeg -y -i E:\\audio_test.m4a -acodec pcm_s16le -f s16le -ac 1 -ar 16000 E:\\audio_test.pcm //将m4a格式转为pcm格式\n四、修改demo代码 以上代码省略\u0026hellip;\u0026hellip;\nif __name__ == \u0026ldquo;__main__\u0026rdquo;: # 测试时候在此处正确填写相关信息即可运行，填写APPID、APIKey、APISecret和音频路径 time1 = datetime.now() wsParam = Ws_Param(APPID=\u0026lsquo;xxxxxx\u0026rsquo;, APIKey=\u0026lsquo;xxxxxxxxxxxxxxxx\u0026rsquo;, APISecret=\u0026lsquo;xxxxxxxxxxxxxxxxx\u0026rsquo;, AudioFile=r\u0026rsquo;E:\\audio_test.pcm\u0026rsquo;) \u0026hellip;\u0026hellip;\n运行结果\nsid:iat0007f62c@dx17292ff09777a1d802 call success!,data is:[{\u0026ldquo;bg\u0026rdquo;: 53, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;富强\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 133, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;，\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 133, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;民族\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 237, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;w\u0026rdquo;: \u0026ldquo;文明\u0026rdquo;, \u0026ldquo;sc\u0026rdquo;: 0}]}, {\u0026ldquo;bg\u0026rdquo;: 305, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;，\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 305, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;w\u0026rdquo;: \u0026ldquo;和谐\u0026rdquo;, \u0026ldquo;sc\u0026rdquo;: 0}]}, {\u0026ldquo;bg\u0026rdquo;: 373, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;w\u0026rdquo;: \u0026ldquo;等\u0026rdquo;, \u0026ldquo;sc\u0026rdquo;: 0}]}, {\u0026ldquo;bg\u0026rdquo;: 425, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;24\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 513, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;个\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 529, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;w\u0026rdquo;: \u0026ldquo;字\u0026rdquo;, \u0026ldquo;sc\u0026rdquo;: 0}]}, {\u0026ldquo;bg\u0026rdquo;: 549, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;叫\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 589, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;社会主义\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 685, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;核心\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 733, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;价值观\u0026rdquo;}]}] sid:iat0007f62c@dx17292ff09777a1d802 call success!,data is:[{\u0026ldquo;bg\u0026rdquo;: 889, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;，\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 889, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;党\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 929, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;的\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 941, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;十\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 965, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;八\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 985, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;w\u0026rdquo;: \u0026ldquo;大\u0026rdquo;, \u0026ldquo;sc\u0026rdquo;: 0}]}, {\u0026ldquo;bg\u0026rdquo;: 1013, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;w\u0026rdquo;: \u0026ldquo;提出\u0026rdquo;, \u0026ldquo;sc\u0026rdquo;: 0}]}] sid:iat0007f62c@dx17292ff09777a1d802 call success!,data is:[{\u0026ldquo;bg\u0026rdquo;: 1115, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;，\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 1115, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;w\u0026rdquo;: \u0026ldquo;倡导\u0026rdquo;, \u0026ldquo;sc\u0026rdquo;: 0}]}, {\u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;w\u0026rdquo;: \u0026ldquo;富强\u0026rdquo;, \u0026ldquo;sc\u0026rdquo;: 0}], \u0026ldquo;bg\u0026rdquo;: 1183}, {\u0026ldquo;bg\u0026rdquo;: 1283, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;，\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 1283, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;民主\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 1375, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;，\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 1375, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;文明\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 1471, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;，\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 1471, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;和谐\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 1587, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;w\u0026rdquo;: \u0026ldquo;，\u0026rdquo;, \u0026ldquo;sc\u0026rdquo;: 0}]}, {\u0026ldquo;bg\u0026rdquo;: 1587, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;w\u0026rdquo;: \u0026ldquo;倡导\u0026rdquo;, \u0026ldquo;sc\u0026rdquo;: 0}]}, {\u0026ldquo;bg\u0026rdquo;: 1647, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;自由\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 1735, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;，\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 1735, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;平等\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 1831, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;，\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 1831, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;公正\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 1927, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;，\u0026rdquo;}]}, {\u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;法治\u0026rdquo;}], \u0026ldquo;bg\u0026rdquo;: 1927}, {\u0026ldquo;bg\u0026rdquo;: 2035, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;，\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 2035, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;倡导\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 2083, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;爱国\u0026rdquo;}]}] sid:iat0007f62c@dx17292ff09777a1d802 call success!,data is:[{\u0026ldquo;bg\u0026rdquo;: 2198, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;，\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 2198, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;敬业\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 2278, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;，\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 2278, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;诚信\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 2382, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;，\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 2382, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;友善\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 2490, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;，\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 2490, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;w\u0026rdquo;: \u0026ldquo;积极\u0026rdquo;, \u0026ldquo;sc\u0026rdquo;: 0}]}, {\u0026ldquo;bg\u0026rdquo;: 2534, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;培育\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 2594, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;和\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 2622, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;践行\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 2690, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;社会主义\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 2818, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;核心\u0026rdquo;}]}, {\u0026ldquo;bg\u0026rdquo;: 2878, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;sc\u0026rdquo;: 0, \u0026ldquo;w\u0026rdquo;: \u0026ldquo;价值观\u0026rdquo;}]}] sid:iat0007f62c@dx17292ff09777a1d802 call success!,data is:[{\u0026ldquo;bg\u0026rdquo;: 0, \u0026ldquo;cw\u0026rdquo;: [{\u0026ldquo;w\u0026rdquo;: \u0026ldquo;。\u0026rdquo;, \u0026ldquo;sc\u0026rdquo;: 0}]}]\nclosed 0:00:06.760000\n修改demo中的on_message函数，只输出文本\n# 收到websocket消息的处理 def on_message(ws, message): try: code = json.loads(message)[\u0026ldquo;code\u0026rdquo;] sid = json.loads(message)[\u0026ldquo;sid\u0026rdquo;] if code != 0: errMsg = json.loads(message)[\u0026ldquo;message\u0026rdquo;] print(\u0026ldquo;sid:%s call error:%s code is:%s\u0026rdquo; % (sid, errMsg, code)) else: data = json.loads(message)[\u0026ldquo;data\u0026rdquo;][\u0026ldquo;result\u0026rdquo;][\u0026ldquo;ws\u0026rdquo;] for i in data: print(i[\u0026ldquo;cw\u0026rdquo;][0][\u0026ldquo;w\u0026rdquo;], end=\u0026rsquo;\u0026rsquo;) except Exception as e: print(\u0026ldquo;receive msg,but parse exception:\u0026rdquo;, e)\n运行结果\n富强，民族文明，和谐等24个字叫社会主义核心价值观，党的十八大提出，倡导富强，民主，文明，和谐，倡导自由，平等，公正，法治，倡导爱国，敬业，诚信，友善，积极培育和践行社会主义核心价值观。### closed ### 0:00:07.322000\n","permalink":"https://water711.github.io/posts/2020-06-08-python%E4%BD%BF%E7%94%A8%E8%AE%AF%E9%A3%9Eapi%E8%BF%9B%E8%A1%8C%E8%AF%AD%E9%9F%B3%E8%BD%AC%E6%96%87%E5%AD%97/","tags":null,"title":"Python使用讯飞API进行语音转文字"},{"categories":["linux"],"contents":"参考文档：http://c.biancheng.net/view/908.html\n磁盘配额概述 1、磁盘配额限制只能作用于普通用户和用户组，超级用户 root 不能做磁盘配额；\n2、磁盘配额限制只能针对分区，不能针对目录，即仅能针对文件系统进行限制，例如 /dev/sda1 挂载到 /home，那么在 /home下的所有目录都会受到磁盘配额的限制；\n3、磁盘配额可以限制用户占用的磁盘容量大小（block），也能限制用户允许占用的文件个数（inode）。\n磁盘配额使用条件 1、内核必须支持磁盘配额。Centos 6.x和7.x 版本，默认支持磁盘配额，否则就要重新编译内核，加入 quota supper 功能\n[root@web ~]# grep CONFIG_QUOTA /boot/config-* CONFIG_QUOTA=y CONFIG_QUOTA_NETLINK_INTERFACE=y\nCONFIG_QUOTA_DEBUG is not set CONFIG_QUOTA_TREE=y CONFIG_QUOTACTL=y CONFIG_QUOTACTL_COMPAT=y\n2、如果是分区的文件系统为xfs，则可以使用系统自带的xfs_quota工具来设置，如果为其它文件系统，则需要安装quota\n一、磁盘配额设置（xfs分区） 对home目录进行磁盘配额设置\n1、检查/home目录是否为独立的文件系统\n#情况一：下面/home 是独立的文件系统，因此可以直接对其进行限制。但如果/home 不是独立的文件系统，则可能就要针对根目录做磁盘配额了，但不建议大家这样做。 [root@test ~]# df -H Filesystem Size Used Avail Use% Mounted on /dev/mapper/centos-root 19G 1.8G 17G 10% / /dev/sda1 1.1G 171M 894M 16% /boot /dev/sda2 20G 1G 894M 5% /home \u0026hellip;\u0026hellip;\n#情况二：如果home目录，不是独立的文件系统，建议重新分一个区，挂载到home目录下 [root@test ~]# df -H Filesystem Size Used Avail Use% Mounted on /dev/mapper/centos-root 19G 1.8G 17G 10% / /dev/sda1 1.1G 171M 894M 16% /boot \u0026hellip;\u0026hellip;\n#新建分区 [root@test ~]# fdisk /dev/sdb n 增加一个分区 w 写入分区表并退出\n#格式化分区 [root@test ~]# mkfs.xfs /dev/sdb1\n#列出所有块设备 [root@test ~]# lsblk\n#查看块设备ID和文件系统格式 [root@test ~]# blkid\n2、重新挂载分区，添加quota参数\n[root@test ~]# vim /etc/fstab /dev/sdb1 /home xfs defaults,usrquota,grpquota 0 0\n#挂载fstab文件中所有文件系统 [root@test ~]# mount -a\n[root@test ~]# mount | grep usrquota\n3、磁盘配额设置\n#限制tom用户，磁盘容量软限制30m，硬限制50m，文件数量软限制6个，硬限制7个 [root@test ~]# xfs_quota -x -c \u0026rsquo;limit bsoft=30m bhard=50m isoft=6 ihard=7 tom\u0026rsquo; /home\n#查看设置 [root@test ~]# xfs_quota -x -c \u0026lsquo;report\u0026rsquo; /home\n4、测试\n#切换到普通用户tom [root@test ~]# su - tom\n#生成60M的文件 [tom@test ~]$ dd if=/dev/zero of=/home/tom/file1 bs=1M count=60 提示：dd: error writing ‘/home/tom/file1’: Disk quota exceeded\n#新建3个文件（home目录自带3个隐藏文件） [tom@test ~]$ touch file2 file3 file4 提示：touch: cannot touch ‘file4’: Disk quota exceeded\n[tom@test ~]$ ls -a\n二、磁盘配额设置（ext4分区） 对home目录进行磁盘配额设置\n1、检查/home目录是否为独立的文件系统\n#情况一：下面/home 是独立的文件系统，因此可以直接对其进行限制。但如果/home 不是独立的文件系统，则可能就要针对根目录做磁盘配额了，但不建议大家这样做。 [root@test ~]# df -H Filesystem Size Used Avail Use% Mounted on /dev/mapper/centos-root 19G 1.8G 17G 10% / /dev/sda1 1.1G 171M 894M 16% /boot /dev/sda2 20G 1G 894M 5% /home \u0026hellip;\u0026hellip;\n#情况二：如果home目录，不是独立的文件系统，建议重新分一个区，挂载到home目录下 [root@test ~]# df -H Filesystem Size Used Avail Use% Mounted on /dev/mapper/centos-root 19G 1.8G 17G 10% / /dev/sda1 1.1G 171M 894M 16% /boot \u0026hellip;\u0026hellip;\n#新建分区 [root@test ~]# fdisk /dev/sdb n 增加一个分区 w 写入分区表并退出\n#格式化分区 [root@test ~]# mkfs.ext4 /dev/sdb1\n#列出所有块设备 [root@test ~]# lsblk\n#查看块设备ID和文件系统格式 [root@test ~]# blkid\n2、重新挂载分区，添加quota参数\n#添加挂载参数：usrquota（启用用户限额）和 grpquota（启动用户组限额） [root@test ~]# vim /etc/fstab /dev/sdb1 /home ext4 defaults,usrquota,grpquota 0 0\n#挂载fstab文件中所有文件系统 [root@test ~]# mount -a\n[root@test ~]# mount | grep usrquota\n3、安装quota工具，并进行磁盘配额设置\n#安装quota [root@test ~]# yum install -y quota\n#扫描文件系统（必须含有挂载参数 usrquota 和 grpquota），加 -fM 参数可强制扫描 [root@test ~]# quotacheck -avug quotacheck: Scanning /dev/sdb1 [/home] done quotacheck: Checked 3 directories and 2 files\n#使用quota扫描后，在/home目录下建立了 Quota 记录文件 [root@test ~]# ls -a /home. .. aquota.group aquota.user\n#开启磁盘配额限制(quotaon开启，quotaoff关闭) [root@test ~]# quotaon -auvg /dev/sdb1 [/home]: group quotas turned on /dev/sdb1 [/home]: user quotas turned on\n#交互式修改磁盘配额，限制tom用户和tom组，磁盘容量软限制30m，硬限制50m，文件数量软限制6个，硬限制7个 [root@test ~]# edquota -u tom Disk quotas for user tom (uid 1001): Filesystem blocks soft hard inodes soft hard /dev/sdb1 16 30000 50000 4 6 7 （blocks和inodes值自动生成，不用修改，磁盘容量限制单位为Kb， edquota -u修改用户配额，-g修改组配额，当 soft/hard 为 0 时，表示没有限制）\n#非交互式修改磁盘配额 [root@localhost ~]# setquota -u tom 30000 50000 6 7 /home setquota -u 用户名 容量软限制 容量硬限制 个数软限制 个数硬限制 分区名\n#修改宽限天数(可选) [root@test ~]# edquota -t\n#查询某用户当前磁盘配额 [root@test ~]# quota -uvs tom\n4、测试\n#切换到普通用户tom [root@test ~]# su - tom\n#生成60M的文件 [tom@test ~]$ dd if=/dev/zero of=/home/tom/file1 bs=1M count=60 提示：dd: error writing ‘/home/ly/file1’: Disk quota exceeded\n#新建3个文件（home目录自带3个隐藏文件） [tom@test ~]$ touch file2 file3 file4 提示：touch: cannot touch ‘file4’: Disk quota exceeded\n[tom@test ~]$ ls -a\n","permalink":"https://water711.github.io/posts/2020-06-07-centos7-%E7%A3%81%E7%9B%98%E9%85%8D%E9%A2%9D/","tags":null,"title":"Centos7 磁盘配额"},{"categories":["other"],"contents":"1、主板BISO开启网络唤醒 不同的主板，开启的位置可能有所不同\n2、操作系统中网卡开启网络唤醒 Windows系统下：\nLinux系统下：\nhttps://jingyan.baidu.com/article/f7ff0bfc33090f2e26bb13f8.html\n查看网卡是否支持网络唤醒\n[root@NAS ~]# ethtool eth0 Supports Wake-on: pumbg //支持唤醒的方式 Wake-on: d //d为关闭唤醒，g为开启唤醒（但是我在真机下，d也能进行网络唤醒）\n[root@NAS ~]# man ethtool p Wake on PHY activity u Wake on unicast messages m Wake on multicast messages b Wake on broadcast messages a Wake on ARP g Wake on MagicPacket™ s Enable SecureOn™ password for MagicPacket™ d Disable (wake on nothing). This option clears all previous options.\n开启网络唤醒\n[root@NAS ~]# ethtool -s eth0 wol g\n如果当机器重启后，eth0的设置又会回复到Wake-on: d 状态，问题的解决有两种办法，分别是：\n方法一： [root@NAS ~]# vim /etc/rc.local /sbin/ethtool -s eth0 wol g\n方法二 [root@NAS ~]# vim /etc/sysconfig/network-scripts/ifcfg-eth0 ETHTOOL_OPTS=\u0026ldquo;wol g\u0026rdquo;\n3、路由器上将端口映射到外网 也可以使用已经映射的其它端口 4、使用Wake On Lan进行唤醒 ","permalink":"https://water711.github.io/posts/2020-06-06-%E8%B7%A8%E5%85%AC%E7%BD%91%E8%BF%9C%E7%A8%8B%E7%BD%91%E7%BB%9C%E5%94%A4%E9%86%92pc/","tags":null,"title":"跨公网远程网络唤醒PC"},{"categories":["other"],"contents":"1、主板BISO开启网络唤醒 不同的主板，开启的位置可能有所不同\n2、操作系统中网卡开启网络唤醒 Windows系统下：\nLinux系统下：\nhttps://jingyan.baidu.com/article/f7ff0bfc33090f2e26bb13f8.html\n查看网卡是否支持网络唤醒\n[root@NAS ~]# ethtool eth0 Supports Wake-on: pumbg //支持唤醒的方式 Wake-on: d //d为关闭唤醒，g为开启唤醒（但是我在真机下，d也能进行网络唤醒）\n[root@NAS ~]# man ethtool p Wake on PHY activity u Wake on unicast messages m Wake on multicast messages b Wake on broadcast messages a Wake on ARP g Wake on MagicPacket™ s Enable SecureOn™ password for MagicPacket™ d Disable (wake on nothing). This option clears all previous options.\n开启网络唤醒\n[root@NAS ~]# ethtool -s eth0 wol g\n如果当机器重启后，eth0的设置又会回复到Wake-on: d 状态，问题的解决有两种办法，分别是：\n方法一： [root@NAS ~]# vim /etc/rc.local /sbin/ethtool -s eth0 wol g\n方法二 [root@NAS ~]# vim /etc/sysconfig/network-scripts/ifcfg-eth0 ETHTOOL_OPTS=\u0026ldquo;wol g\u0026rdquo;\n3、路由器上将端口映射到外网 也可以使用已经映射的其它端口 4、使用Wake On Lan进行唤醒 ","permalink":"https://water711.github.io/posts/2020-06-06-%E8%B7%A8%E5%85%AC%E7%BD%91%E8%BF%9C%E7%A8%8B%E7%BD%91%E7%BB%9C%E5%94%A4%E9%86%92pcnull/","tags":null,"title":"跨公网远程网络唤醒PC"},{"categories":["linux"],"contents":"1、安装Apache #安装 [root@web ~]# yum -y install httpd\n#防火墙开放http服务 [root@web ~]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-service=http [root@web ~]# firewall-cmd \u0026ndash;reload\n#新建测试页面 [root@web ~]# echo \u0026ldquo;web page\u0026rdquo; \u0026gt; /var/www/html/index.html\n#启动服务 [root@web ~]# systemctl start httpd [root@web ~]# systemctl enable httpd\n#测试 使用浏览器访问web主机IP\n2、修改网站目录 #新建网站目录及页面 [root@web ~]# mkdir /web [root@web ~]# echo \u0026ldquo;new web page\u0026rdquo; \u0026gt; /web/index.html\n#修改主配置文件 [root@web ~]# vim /etc/httpd/conf/httpd.conf //修改以下两处位置 DocumentRoot \u0026ldquo;/web\u0026rdquo; \u0026lt;Directory \u0026ldquo;/web\u0026rdquo;\u0026gt;\n#重启httpd服务 [root@web ~]# systemctl restart httpd\n#关闭selinux [root@web ~]# setenforce 0\n#测试 使用浏览器访问web主机IP\n3、新建虚拟主机 #新建虚拟主机配置文件，注意文件一定要是.conf的后缀 [root@web ~]# vim /etc/httpd/conf.d/test1.com.conf \u0026lt;VirtualHost *:80\u0026gt; ServerName www.test1.com DocumentRoot /web/test1/ [root@web ~]# vim /etc/httpd/conf.d/test2.com.conf Listen 81 //修改虚拟主机端口为81 \u0026lt;VirtualHost *:81\u0026gt; ServerName www.test2.com DocumentRoot /web/test2 #新建网站目录及文件 [root@web ~]# mkdir /web/test1 [root@web ~]# echo \u0026ldquo;test1 page\u0026rdquo; \u0026gt; /web/test1/index.html [root@web ~]# mkdir /web/test2 [root@web ~]# echo \u0026ldquo;test2 page\u0026rdquo; \u0026gt; /web/test2/index.html #防火墙开放端口 [root@web ~]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-port=81/tcp [root@web ~]# firewall-cmd \u0026ndash;reload\n#重启httpd服务 [root@web ~]# systemctl restart httpd\n#测试 修改客户端电脑host文件： 192.168.1.156 www.test1.com 192.168.1.156 www.test2.com 浏览器访问www.test1.com和www.test2.com:81（如果无法正常访问，检查网站目录权限，apache用户是否有读权限）\n","permalink":"https://water711.github.io/posts/2020-06-05-centos7-%E9%83%A8%E7%BD%B2apache%E6%9C%8D%E5%8A%A1/","tags":null,"title":"Centos7 部署Apache服务"},{"categories":["linux"],"contents":" 1、安装bind软件包 [root@DNS ~]# yum -y install bind\n2、修改主配置文件，添加正向解析区域 [root@DNS ~]# vim /etc/named.conf\noptions { listen-on port 53 { any; }; //将127.0.0.1修改为any listen-on-v6 port 53 { any; }; //将::1修改为any directory \u0026ldquo;/var/named\u0026rdquo;; //区域数据文件默认位置，可以不用修改 \u0026hellip; allow-query { any; }; //将127.0.0.1修改为any\n#在最后面添加正向解析区域 zone \u0026ldquo;test.com\u0026rdquo; { type master; //类型为主要区域 file \u0026ldquo;test.com.zone\u0026rdquo;; //区域数据文件名 };\n3、新建区域数据文件 [root@DNS ~]# vim /var/named/test.com.zone @ IN SOA dns root ( 2020060500 1H 15M 1W 1D ) @ IN NS dns dns IN A 192.168.1.156 www IN A 192.168.1.156\n4、启动服务 [root@DNS ~]# systemctl restart named [root@DNS ~]# systemctl enable named [root@DNS ~]# ss -lanp | grep :53\n5、防火墙开放DNS服务 [root@DNS ~]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-service=dns [root@DNS ~]# firewall-cmd \u0026ndash;reload\n6、测试 ","permalink":"https://water711.github.io/posts/2020-06-05-centos7%E9%83%A8%E7%BD%B2dns%E6%9C%8D%E5%8A%A1/","tags":null,"title":"Centos7部署DNS服务"},{"categories":["linux"],"contents":"场景：电脑挂载多个硬盘做NAS，硬盘大部分时间为待机状态（不使用），为节约电费，有必要设置硬盘休眠\n1、安装硬盘性能测试/设置工具\n[root@NAS ~]# yum -y install hdparm\n[root@NAS ~]# hdparm \u0026ndash;help\n参数说明： -S\u0026lt;时间\u0026gt; 设定硬盘进入省电模式前的等待时间（关闭旋转电机） -y 使IDE硬盘进入省电模式 -Y 使IDE硬盘进入睡眠模式 -C 检测IDE硬盘的电源管理模式 -f 将内存缓冲区的数据写入硬盘，并清楚缓冲区 -i 显示硬盘的硬件规格信息，这些信息是在开机时由硬盘本身所提供 -I 直接读取硬盘所提供的硬件规格信息 -t 评估硬盘的读取效率 -T 评估硬盘快取的读取效率\n2、使硬盘立即进入省电状态\n[root@NAS ~]# hdparm -Y /dev/sda\nPS：可以配合crontab来设置定时休眠\n3、设置硬盘省电策略\n无访问一定时间后自动停转，关闭旋转电机\n[root@NAS ~]# hdparm -S 10 /dev/sda\n//这里-S取值为10，则为50秒 换算关系为：1 = 5秒\nPS：在centos7下测试，发现有时候硬盘不会自动休眠\n4、查看当前硬盘省电状态\n[root@NAS ~]# hdparm -C /dev/sda\n//active：活动状态 //standby 省电状态\n5、使用crontab定期执行硬盘休眠\n[root@NAS ~]# crontab -e */1 * * * * /usr/sbin/hdparm -Y /dev/sda \u0026gt; /dev/null\n//每分钟执行一次休眠\n6、配合autofs自动挂载硬盘，实现硬盘未使用时自动休眠\n原理：autofs设置不使用时自动卸载挂载点，并配合脚本检测硬盘是否挂载，当硬盘未被挂载，立即执行硬盘休眠\na、安装autofs\n[root@NAS ~]# yum -y install autofs\nb、修改主配置文件\n[root@NAS ~]# vim /etc/auto.master /mnt /etc/nas.misc 挂载目录 子配置文件\nc、修改子配置文件\n[root@NAS nas]# vim /etc/nas.misc nas -fstype=ntfs,ro,nosuid,nodev :/dev/sda1 #将/dev/sda1设备，挂载到/mnt/nas目录下(mnt为主配置文件中设置的挂载目录)\nd、修改无访问时卸载时间（默认300秒）\n#全局设置 [root@NAS ~]# vim /etc/sysconfig/autofs TIMEOUT=180 //修改为180秒\n#局部设置(设置后会覆盖全局设置) [root@NAS ~]# vim /etc/auto.master /mnt /etc/nas.misc \u0026ndash;timeout=180\ne、启动autofs服务\n[root@NAS nas]# systemctl restart autofs [root@NAS nas]# systemctl enable autofs\nf、测试\n[root@NAS ~]# ls /mnt #当前mnt目录为空\n[root@NAS ~]# ls /mnt/nas #访问nas目录，自动挂载\n[root@NAS ~]# df -h #查看挂载的磁盘\ng、编写脚本，检测当前是否挂载设备，如果没挂载，则立即休眠硬盘\n[root@NAS ~]# vim check_disk.sh\n#!/bin/bash\ndf -h | grep \u0026lsquo;/mnt/nas\u0026rsquo; \u0026gt; /dev/null result=`echo $?`\nif [ $result != 0 ];then hdparm -Y /dev/sda \u0026gt; /dev/null fi\nh、使用crontab定期执行脚本\n[root@NAS ~]# crontab -e */2 * * * * /bin/sh /root/check_disk.sh \u0026gt; /dev/null\n//每2分钟执行一次脚本\n","permalink":"https://water711.github.io/posts/2020-06-02-linux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E7%A1%AC%E7%9B%98%E8%87%AA%E5%8A%A8%E4%BC%91%E7%9C%A0%E7%9C%81%E7%94%B5/","tags":null,"title":"Linux下设置硬盘自动休眠省电"},{"categories":["linux","other"],"contents":"参考文章链接：https://www.cnblogs.com/sun51586/p/10497538.html\n准备：\n一个u盘，并制作老毛桃winpe启动盘\n下载centos7 mini版本。（注意：因为dvd版本大于4g，一般fat格式的u盘无法存放，如果格式化为NTFS，则centos镜像无法识别）\n安装中常见错误 ，如下图：\n1，Warning: /dev/root does not exist!\n2，Warning: no suitable images\n还有一些其它错误 ，不知是何原因，遇到时请重试几次。不知是老毛桃制作的启动盘有问题，还是u盘有问题，还是电脑有问题。总之多试几次是可以的。\n-\n安装步骤：\n1、制作老毛桃PE启动U盘，将下载centos7的iso文件复制到u盘的/LMT目录\n2、从u盘启动电脑，选择“启动自定义ISO/IMG文件”\n3、选择“自动搜索并列出LMT目录下所有文件”\n4、选中镜像文件，回车\n5、选中“Install CentOS 7”，按Tab键，修改启动命令后，回车\n\u0026gt; vmlinuz initrd=initrd.img linux dd quiet\n6、出现下图界面面，找到vfat文件格式的设备，记下设备名称（我这里是sdb1）\n7、重启电脑，按前面步骤回到第5步界面，选中“Install CentOS 7”,按Tab键，修改启动命令后，回车\nPS：/dev/sdb1为U盘设备路径，LMT为存放镜像的目录\n\u0026gt; vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdb1:/LMT/ quiet\n8、完成上述步骤后，就能进入系统安装界面\n","permalink":"https://water711.github.io/posts/2020-06-02-%E8%80%81%E6%AF%9B%E6%A1%83pe%E4%BB%A5iso%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F%E5%AE%89%E8%A3%85centos7/","tags":null,"title":"老毛桃PE以ISO镜像模式安装CentOS7"},{"categories":["linux","other"],"contents":"参考文章链接：https://www.cnblogs.com/sun51586/p/10497538.html\n准备：\n一个u盘，并制作老毛桃winpe启动盘\n下载centos7 mini版本。（注意：因为dvd版本大于4g，一般fat格式的u盘无法存放，如果格式化为NTFS，则centos镜像无法识别）\n安装中常见错误 ，如下图：\n1，Warning: /dev/root does not exist!\n2，Warning: no suitable images\n还有一些其它错误 ，不知是何原因，遇到时请重试几次。不知是老毛桃制作的启动盘有问题，还是u盘有问题，还是电脑有问题。总之多试几次是可以的。\n-\n安装步骤：\n1、制作老毛桃PE启动U盘，将下载centos7的iso文件复制到u盘的/LMT目录\n2、从u盘启动电脑，选择“启动自定义ISO/IMG文件”\n3、选择“自动搜索并列出LMT目录下所有文件”\n4、选中镜像文件，回车\n5、选中“Install CentOS 7”，按Tab键，修改启动命令后，回车\n\u0026gt; vmlinuz initrd=initrd.img linux dd quiet\n6、出现下图界面面，找到vfat文件格式的设备，记下设备名称（我这里是sdb1）\n7、重启电脑，按前面步骤回到第5步界面，选中“Install CentOS 7”,按Tab键，修改启动命令后，回车\nPS：/dev/sdb1为U盘设备路径，LMT为存放镜像的目录\n\u0026gt; vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdb1:/LMT/ quiet\n8、完成上述步骤后，就能进入系统安装界面\n","permalink":"https://water711.github.io/posts/2020-06-02-%E8%80%81%E6%AF%9B%E6%A1%83pe%E4%BB%A5iso%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F%E5%AE%89%E8%A3%85centos7null/","tags":null,"title":"老毛桃PE以ISO镜像模式安装CentOS7"},{"categories":["linux"],"contents":"1、插入带有NTFS文件格式的硬盘，并查看硬盘设备路径\n[root@NAS ~]# lsblk //列出所有块设备，会显示所有分区大小\n如果上面命令查看不出哪个是新插增硬盘，可使用下面命令\n[root@NAS ~]# fdisk -l //列出所有分区表，包含分区大小及文件系统\n2、安装NTFS分区的的驱动\n[root@NAS ~]# yum -y install ntfs-3g\n3、挂载NTFS格式分区\n[root@NAS ~]# mount /dev/sda1 /mnt/disk1\n","permalink":"https://water711.github.io/posts/2020-06-01-centos-%E6%8C%82%E8%BD%BDntfs%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA/","tags":null,"title":"Centos 挂载NTFS硬盘分区"},{"categories":["other"],"contents":"参考：https://blog.51cto.com/oyang/1107753\n1、打开虚拟机，选择“编辑虚拟机设置”\n2、弹出“虚拟机设置”窗口，点击“添加”\n3、弹出“添加硬件向导”，选择“硬盘”，点击“下一步”\n4、选择需要添加的磁盘，点击“下一步”\n5、选择添加U盘的序号，点击“下一步”\n注：如果不清楚哪个序号为U盘，可以通过“我的电脑”-\u0026gt;“管理”-\u0026gt;“磁盘管理”来查看序号\n6、点击“完成”\n7、选择“完成”后，可查看添加的信息是否准备，最后点击“确定”\n8、启动虚拟机并进入BIOS\n9、选择“BOOT”，在Hard Drive处回车，通过“-/+”移动新添加硬盘到最前面，按F10保存\n10、自动重启后，从U盘启动PE系统\n","permalink":"https://water711.github.io/posts/2020-06-01-vmware-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8u%E7%9B%98pe/","tags":null,"title":"VMware 虚拟机设置启动U盘PE"},{"categories":["other"],"contents":"参考：https://blog.51cto.com/oyang/1107753\n1、打开虚拟机，选择“编辑虚拟机设置”\n2、弹出“虚拟机设置”窗口，点击“添加”\n3、弹出“添加硬件向导”，选择“硬盘”，点击“下一步”\n4、选择需要添加的磁盘，点击“下一步”\n5、选择添加U盘的序号，点击“下一步”\n注：如果不清楚哪个序号为U盘，可以通过“我的电脑”-\u0026gt;“管理”-\u0026gt;“磁盘管理”来查看序号\n6、点击“完成”\n7、选择“完成”后，可查看添加的信息是否准备，最后点击“确定”\n8、启动虚拟机并进入BIOS\n9、选择“BOOT”，在Hard Drive处回车，通过“-/+”移动新添加硬盘到最前面，按F10保存\n10、自动重启后，从U盘启动PE系统\n","permalink":"https://water711.github.io/posts/2020-06-01-vmware-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8u%E7%9B%98penull/","tags":null,"title":"VMware 虚拟机设置启动U盘PE"},{"categories":["python"],"contents":"环境 Python 3.7 Windows 7 X64 （windows并不是官方支持的，但也许也能用） 官方文档 https://github.com/ageitgey/face_recognition/blob/master/README_Simplified_Chinese.md 一、安装第三方库及相关依赖 1、安装Visual Studio Build Tools（因为cmake依赖C++），安装时选择“C++生成工具”\n2、安装Cmake（因为dlib库需要cmake编译）\npip3 install cmake\n3、安装face_recognition和dlib\npip3 install face_recognition\n//安装安装face_recognition会自动安装dlib，如果安装下载时，多次超时中断，可以到PyPI上下载安装包（xxx.whl）或源码包（xxx.tar.gz），离线进行安装。\npip install dlib-19.19.0.whl 或 pip3 install dlib-19.19.0.tar.gz\n二、face_recognition 命令行工具 ![](http://hugo.caizhenwei.top//cf190ebbc1c551c0d40f36fcc5549d24.png)\nface_recognition - 在单张图片或一个图片文件夹中认出是谁的脸。\n#将A.png图片到known文件夹中去辨认出是谁的脸 F:\\face\u0026gt;face_recognition ./known ./check/A.png ./check/A.png,刘德华\n#将check目录中的人脸，逐个到known目录中辨认出是谁的脸 F:\\face\u0026gt;face_recognition ./known ./check ./check\\A.png,刘德华 ./check\\B.jpg,刘亦菲 ./check\\C.png,刘亦菲 //识别错误\n#调整人脸识别的容错率 #通过传入参数 \u0026ndash;tolerance 来实现这个功能，默认的容错率是0.6，容错率越低，识别越严格准确。 F:\\face\u0026gt;face_recognition \u0026ndash;tolerance 0.5 ./known ./check ./check\\A.png,刘德华 ./check\\B.jpg,刘亦菲 ./check\\C.png,unknown_person\n三、将网络摄像头画面中的人脸进行打码（需要安装OpenCV） 参考：https://github.com/ageitgey/face_recognition/blob/master/examples/blur_faces_on_webcam.py\n安装opencv\npip3 install opencv-python\nimport face_recognition import cv2\nThis is a demo of blurring faces in video. PLEASE NOTE: This example requires OpenCV (the `cv2` library) to be installed only to read from your webcam. OpenCV is *not* required to use the face_recognition library. It\u0026rsquo;s only required if you want to run this specific demo. If you have trouble installing it, try any of the other demos that don\u0026rsquo;t require it instead. Get a reference to webcam #0 (the default one) video_capture = cv2.VideoCapture(\u0026ldquo;rtsp://admin:admin888@192.168.1.240/stream1\u0026rdquo;)\nInitialize some variables face_locations = []\nwhile True: # Grab a single frame of video ret, frame = video_capture.read()\n# Resize frame of video to 1/4 size for faster face detection processing small\\_frame = cv2.resize(frame, (0, 0), fx=0.25, fy=0.25) # Find all the faces and face encodings in the current frame of video face\\_locations = face\\_recognition.face\\_locations(small\\_frame, model=\u0026quot;cnn\u0026quot;) # Display the results for top, right, bottom, left in face\\_locations: # Scale back up face locations since the frame we detected in was scaled to 1/4 size top \\*= 4 right \\*= 4 bottom \\*= 4 left \\*= 4 # Extract the region of the image that contains the face face\\_image = frame\\[top:bottom, left:right\\] # Blur the face image face\\_image = cv2.GaussianBlur(face\\_image, (99, 99), 30) # Put the blurred face region back into the frame image frame\\[top:bottom, left:right\\] = face\\_image # Display the resulting image # cv2.resizeWindow(\u0026quot;Tracking\u0026quot;, 800,800) cv2.imshow('Video', frame) # Hit 'q' on the keyboard to quit! if cv2.waitKey(1) \u0026amp; 0xFF == ord('q'): break Release handle to the webcam video_capture.release() cv2.destroyAllWindows()\n运行效果：\n四、实时检测识别网络摄像头中的人脸（需要安装OpenCV） 安装opencv\npip3 install opencv-python\n参考：https://github.com/ageitgey/face_recognition/blob/master/examples/facerec_from_webcam_faster.py\nimport face_recognition import cv2 import numpy as np\n从rtsp地址中打开一个网络摄像头 video_capture = cv2.VideoCapture(\u0026ldquo;rtsp://admin:admin888@192.168.1.240/stream2\u0026rdquo;)\n加载第1个图片，返回图片中每个人脸128个维度的编码列表 obama_image = face_recognition.load_image_file(\u0026ldquo;obama.png\u0026rdquo;) obama_face_encoding = face_recognition.face_encodings(obama_image)[0]\n加载第2个图片，返回图片中每个人脸128个维度的编码列表 me_image = face_recognition.load_image_file(\u0026ldquo;me.jpg\u0026rdquo;) me_face_encoding = face_recognition.face_encodings(me_image)[0]\n创建已知的人脸编码及人名的数组 known_face_encodings = [ obama_face_encoding, me_face_encoding ] known_face_names = [ \u0026ldquo;obama\u0026rdquo;, \u0026ldquo;me\u0026rdquo; ]\n初始化变量 face_locations = [] face_encodings = [] face_names = [] process_this_frame = True\nwhile True: # 从摄像头视频中抓取一帧图像 ret, frame = video_capture.read()\n# 将帧的大小调整为1/4，以加快人脸识别速度 small\\_frame = cv2.resize(frame, (0, 0), fx=0.25, fy=0.25) #将图像从opencv默认的BGR颜色，转换为RGB颜色（face\\_recognition使用RGB） rgb\\_small\\_frame = small\\_frame\\[:, :, ::-1\\] # 每隔一帧处理一次视频以节省时间 if process\\_this\\_frame: # Find all the faces and face encodings in the current frame of video # 查找当前帧的所有人脸位置和面部编码转换 face\\_locations = face\\_recognition.face\\_locations(rgb\\_small\\_frame) face\\_encodings = face\\_recognition.face\\_encodings(rgb\\_small\\_frame, face\\_locations) face\\_names = \\[\\] for face\\_encoding in face\\_encodings: ''' 循环面部编码列表，查看人脸是否在已知的人脸列表中 ''' matches = face\\_recognition.compare\\_faces(known\\_face\\_encodings, face\\_encoding) name = \u0026quot;Unknown\u0026quot; # # If a match was found in known\\_face\\_encodings, just use the first one. # if True in matches: # first\\_match\\_index = matches.index(True) # name = known\\_face\\_names\\[first\\_match\\_index\\] # Or instead, use the known face with the smallest distance to the new face face\\_distances = face\\_recognition.face\\_distance(known\\_face\\_encodings, face\\_encoding) best\\_match\\_index = np.argmin(face\\_distances) if matches\\[best\\_match\\_index\\]: name = known\\_face\\_names\\[best\\_match\\_index\\] face\\_names.append(name) process\\_this\\_frame = not process\\_this\\_frame # Display the results for (top, right, bottom, left), name in zip(face\\_locations, face\\_names): # Scale back up face locations since the frame we detected in was scaled to 1/4 size top \\*= 4 right \\*= 4 bottom \\*= 4 left \\*= 4 # Draw a box around the face cv2.rectangle(frame, (left, top), (right, bottom), (0, 0, 255), 2) # Draw a label with a name below the face cv2.rectangle(frame, (left, bottom - 35), (right, bottom), (0, 0, 255), cv2.FILLED) font = cv2.FONT\\_HERSHEY\\_DUPLEX cv2.putText(frame, name, (left + 6, bottom - 6), font, 1.0, (255, 255, 255), 1) # Display the resulting image cv2.imshow('Video', frame) # 按键盘 q 退出 if cv2.waitKey(1) \u0026amp; 0xFF == ord('q'): break 关闭摄像头句柄 video_capture.release() cv2.destroyAllWindows()\n运行效果：\n","permalink":"https://water711.github.io/posts/2020-05-31-python%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%BA%93face-recognition/","tags":null,"title":"Python人脸识别库Face Recognition"},{"categories":["python"],"contents":"环境 Python 3.7 Windows 7 X64 （windows并不是官方支持的，但也许也能用） 官方文档 https://github.com/ageitgey/face_recognition/blob/master/README_Simplified_Chinese.md 一、安装第三方库及相关依赖 1、安装Visual Studio Build Tools（因为cmake依赖C++），安装时选择“C++生成工具”\n2、安装Cmake（因为dlib库需要cmake编译）\npip3 install cmake\n3、安装face_recognition和dlib\npip3 install face_recognition\n//安装安装face_recognition会自动安装dlib，如果安装下载时，多次超时中断，可以到PyPI上下载安装包（xxx.whl）或源码包（xxx.tar.gz），离线进行安装。\npip install dlib-19.19.0.whl 或 pip3 install dlib-19.19.0.tar.gz\n二、face_recognition 命令行工具 ![](images/cf190ebbc1c551c0d40f36fcc5549d24.png)\nface_recognition - 在单张图片或一个图片文件夹中认出是谁的脸。\n#将A.png图片到known文件夹中去辨认出是谁的脸 F:\\face\u0026gt;face_recognition ./known ./check/A.png ./check/A.png,刘德华\n#将check目录中的人脸，逐个到known目录中辨认出是谁的脸 F:\\face\u0026gt;face_recognition ./known ./check ./check\\A.png,刘德华 ./check\\B.jpg,刘亦菲 ./check\\C.png,刘亦菲 //识别错误\n#调整人脸识别的容错率 #通过传入参数 \u0026ndash;tolerance 来实现这个功能，默认的容错率是0.6，容错率越低，识别越严格准确。 F:\\face\u0026gt;face_recognition \u0026ndash;tolerance 0.5 ./known ./check ./check\\A.png,刘德华 ./check\\B.jpg,刘亦菲 ./check\\C.png,unknown_person\n三、将网络摄像头画面中的人脸进行打码（需要安装OpenCV） 参考：https://github.com/ageitgey/face_recognition/blob/master/examples/blur_faces_on_webcam.py\n安装opencv\npip3 install opencv-python\nimport face_recognition import cv2\nThis is a demo of blurring faces in video. PLEASE NOTE: This example requires OpenCV (the `cv2` library) to be installed only to read from your webcam. OpenCV is *not* required to use the face_recognition library. It\u0026rsquo;s only required if you want to run this specific demo. If you have trouble installing it, try any of the other demos that don\u0026rsquo;t require it instead. Get a reference to webcam #0 (the default one) video_capture = cv2.VideoCapture(\u0026ldquo;rtsp://admin:admin888@192.168.1.240/stream1\u0026rdquo;)\nInitialize some variables face_locations = []\nwhile True: # Grab a single frame of video ret, frame = video_capture.read()\n# Resize frame of video to 1/4 size for faster face detection processing small\\_frame = cv2.resize(frame, (0, 0), fx=0.25, fy=0.25) # Find all the faces and face encodings in the current frame of video face\\_locations = face\\_recognition.face\\_locations(small\\_frame, model=\u0026quot;cnn\u0026quot;) # Display the results for top, right, bottom, left in face\\_locations: # Scale back up face locations since the frame we detected in was scaled to 1/4 size top \\*= 4 right \\*= 4 bottom \\*= 4 left \\*= 4 # Extract the region of the image that contains the face face\\_image = frame\\[top:bottom, left:right\\] # Blur the face image face\\_image = cv2.GaussianBlur(face\\_image, (99, 99), 30) # Put the blurred face region back into the frame image frame\\[top:bottom, left:right\\] = face\\_image # Display the resulting image # cv2.resizeWindow(\u0026quot;Tracking\u0026quot;, 800,800) cv2.imshow('Video', frame) # Hit 'q' on the keyboard to quit! if cv2.waitKey(1) \u0026amp; 0xFF == ord('q'): break Release handle to the webcam video_capture.release() cv2.destroyAllWindows()\n运行效果：\n四、实时检测识别网络摄像头中的人脸（需要安装OpenCV） 安装opencv\npip3 install opencv-python\n参考：https://github.com/ageitgey/face_recognition/blob/master/examples/facerec_from_webcam_faster.py\nimport face_recognition import cv2 import numpy as np\n从rtsp地址中打开一个网络摄像头 video_capture = cv2.VideoCapture(\u0026ldquo;rtsp://admin:admin888@192.168.1.240/stream2\u0026rdquo;)\n加载第1个图片，返回图片中每个人脸128个维度的编码列表 obama_image = face_recognition.load_image_file(\u0026ldquo;obama.png\u0026rdquo;) obama_face_encoding = face_recognition.face_encodings(obama_image)[0]\n加载第2个图片，返回图片中每个人脸128个维度的编码列表 me_image = face_recognition.load_image_file(\u0026ldquo;me.jpg\u0026rdquo;) me_face_encoding = face_recognition.face_encodings(me_image)[0]\n创建已知的人脸编码及人名的数组 known_face_encodings = [ obama_face_encoding, me_face_encoding ] known_face_names = [ \u0026ldquo;obama\u0026rdquo;, \u0026ldquo;me\u0026rdquo; ]\n初始化变量 face_locations = [] face_encodings = [] face_names = [] process_this_frame = True\nwhile True: # 从摄像头视频中抓取一帧图像 ret, frame = video_capture.read()\n# 将帧的大小调整为1/4，以加快人脸识别速度 small\\_frame = cv2.resize(frame, (0, 0), fx=0.25, fy=0.25) #将图像从opencv默认的BGR颜色，转换为RGB颜色（face\\_recognition使用RGB） rgb\\_small\\_frame = small\\_frame\\[:, :, ::-1\\] # 每隔一帧处理一次视频以节省时间 if process\\_this\\_frame: # Find all the faces and face encodings in the current frame of video # 查找当前帧的所有人脸位置和面部编码转换 face\\_locations = face\\_recognition.face\\_locations(rgb\\_small\\_frame) face\\_encodings = face\\_recognition.face\\_encodings(rgb\\_small\\_frame, face\\_locations) face\\_names = \\[\\] for face\\_encoding in face\\_encodings: ''' 循环面部编码列表，查看人脸是否在已知的人脸列表中 ''' matches = face\\_recognition.compare\\_faces(known\\_face\\_encodings, face\\_encoding) name = \u0026quot;Unknown\u0026quot; # # If a match was found in known\\_face\\_encodings, just use the first one. # if True in matches: # first\\_match\\_index = matches.index(True) # name = known\\_face\\_names\\[first\\_match\\_index\\] # Or instead, use the known face with the smallest distance to the new face face\\_distances = face\\_recognition.face\\_distance(known\\_face\\_encodings, face\\_encoding) best\\_match\\_index = np.argmin(face\\_distances) if matches\\[best\\_match\\_index\\]: name = known\\_face\\_names\\[best\\_match\\_index\\] face\\_names.append(name) process\\_this\\_frame = not process\\_this\\_frame # Display the results for (top, right, bottom, left), name in zip(face\\_locations, face\\_names): # Scale back up face locations since the frame we detected in was scaled to 1/4 size top \\*= 4 right \\*= 4 bottom \\*= 4 left \\*= 4 # Draw a box around the face cv2.rectangle(frame, (left, top), (right, bottom), (0, 0, 255), 2) # Draw a label with a name below the face cv2.rectangle(frame, (left, bottom - 35), (right, bottom), (0, 0, 255), cv2.FILLED) font = cv2.FONT\\_HERSHEY\\_DUPLEX cv2.putText(frame, name, (left + 6, bottom - 6), font, 1.0, (255, 255, 255), 1) # Display the resulting image cv2.imshow('Video', frame) # 按键盘 q 退出 if cv2.waitKey(1) \u0026amp; 0xFF == ord('q'): break 关闭摄像头句柄 video_capture.release() cv2.destroyAllWindows()\n运行效果：\n","permalink":"https://water711.github.io/posts/2020-05-31-python%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%BA%93face-recognitionnull/","tags":null,"title":"Python人脸识别库Face Recognition"},{"categories":["other"],"contents":"**场景：**适配不同的手机屏幕尺寸，让元素始终位于屏幕中央\n效果图：\n一、index.wxml 二、index.wxss .container{ display:flex; justify-content: center; align-items: center; }\n.box{ height:80px; width:80px; background-color:blue; }\n三、index.js /** * 生命周期函数\u0026ndash;监听页面加载 */ onLoad: function(options) { var that = this; wx.getSystemInfo({ success(res) { console.log(\u0026lsquo;可使用窗口高度:\u0026rsquo;, res.windowHeight) that.setData({ windowHeight: res.windowHeight }) } }) },\n","permalink":"https://water711.github.io/posts/2020-05-22-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%A0%B7%E5%BC%8F/","tags":null,"title":"微信小程序动态修改样式"},{"categories":["linux","python"],"contents":"1、安装python、nginx、django和uwsgi [root@server ~]# yum -y install python3 nginx gcc [root@server ~]# pip3 install django==2.0\n[root@liyu ~]# python3 -V Python 3.6.8 [root@liyu ~]# yum install python36-devel //安装对应Python版本的devel，编译uwsgi需要的依赖\n[root@server ~]# pip3 install uwsgi\n2、创建django项目 [root@server ~]# mkdir /web/ [root@server ~]# cd /web/ [root@server ~]# django-admin startproject test_project\n#允许所有主机访问 [root@server ~]# cd test_project/ [root@server test_project]# vim test_project/settings.py ALLOWED_HOSTS = [\u0026rsquo;*\u0026rsquo;]\n#开发环境下，可以直接使用下面命令来运行项目 [root@server ~]# python3 manage.py runserver 0.0.0.0:8000\n3、使用uwsgi启动django项目 #uwsgi命令行方式直接启动（测试） [root@web test_project]# uwsgi \u0026ndash;http :8000 \u0026ndash;module test_project.wsgi //test_project.wsgi表示test_project目录下的wsgi.py文件\n#uwsgi使用配置文件方式启动django项目 [root@web test_project]# vim django-uwsgi.ini [uwsgi]\nchdir = /web/test_project module = test_project.wsgi http-socket = :8000 master = True processes = 4 threads = 1 vacuum = true\nbackend run uwsgi daemonize = %(chdir)/log/uwsgi-8000.log log-maxsize = 1024000000 pidfile = %(chdir)/pid/uwsgi-8000.pid [root@web test_project]# mkdir log pid #创建日志和pid目录 [root@web test_project]# uwsgi \u0026ndash;ini django-uwsgi.ini #uwsgi读取配置文件并启动 [root@web ~]# ss -lanp | grep 8000 #查看端口是否正常监听 [root@web ~]# cat pid/uwsgi-8000.pid #查看进程号\n4、配置nginx，实现反向代理 [root@web ~]# cp /etc/nginx/nginx.conf{,bak} #备份nginx配置文件 [root@web ~]# vim /etc/nginx/nginx.conf http { \u0026hellip;\u0026hellip; upstream uwsgi { server 127.0.0.1:8000; }\nserver { listen 80; server\\_name .test.com; charset utf-8; access\\_log /var/log/nginx/nginx-uwsgi.log; location / { proxy\\_pass http://uwsgi; } } } [root@web ~]# systemctl restart nginx\n5、收集django项目中的静态文件 [root@web test_project]# vim test_project/settings.py #指定静态文件存放路径 STATIC_ROOT = os.path.join(BASE_DIR, \u0026lsquo;static/\u0026rsquo;) #把静态文件收集到STATIC_ROOT [root@web test_project]# python3 manage.py collectstatic\n6、nginx配置静态文件路由 [root@server ~]# vim /etc/nginx/nginx.conf server { listen 80; ...... location /static { alias /web/test\\_project/static; } } [root@server ~]# systemctl restart nginx\n","permalink":"https://water711.github.io/posts/2020-05-09-%E4%BD%BF%E7%94%A8uwsgi%E5%92%8Cnginx%E6%9D%A5%E9%83%A8%E7%BD%B2%E5%9F%BA%E4%BA%8Edjango%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8/","tags":null,"title":"使用uWSGI和Nginx来部署基于Django的Web服务器"},{"categories":["python"],"contents":"1、下载源码 wget https://www.python.org/ftp/python/3.8.2/Python-3.8.2.tgz tar xf Python-3.8.2.tgz cd Python-3.8.2/\n2、安装编译所需依赖 yum install -y gcc openssl-devel zlib-devel libffi-devel sqlite-devel\n3、编译 ./configure prefix=/usr/local/python3 make -j8 \u0026amp;\u0026amp; make install\n#如果gcc版本\u0026gt;=8.1.0，在编译时可以添加优化选项\u0026ndash;enable-optimizations ./configure prefix=/usr/local/python3 \u0026ndash;enable-optimizations make -j8 \u0026amp;\u0026amp; make install\n4、将python的bin目录添加到环境变量 export PATH=$PATH:/usr/local/python3/bin/ echo export PATH=$PATH:/usr/local/python3/bin/ \u0026raquo; /etc/profile\n","permalink":"https://water711.github.io/posts/2020-05-08-centos7%E5%AE%89%E8%A3%85python3/","tags":null,"title":"Centos7源码安装python3"},{"categories":["python"],"contents":"方法一、使用命令添加配置 \u0026gt; pip config set global.index-url http://pypi.douban.com/simple/ Writing to C:\\Users\\admin\\AppData\\Roaming\\pip\\pip.ini\npip config set install.trusted-host pypi.douban.com Writing to C:\\Users\\admin\\AppData\\Roaming\\pip\\pip.ini\n方法二：修改全局配置文件 Windows： C:\\Users\\用户名\\AppData\\Roaming\\pip\\pip.ini\nLinux： ~/.pip/pip.conf\n[global] index-url = http://pypi.douban.com/simple\n[install] trusted-host = pypi.douban.com\n","permalink":"https://water711.github.io/posts/2020-04-22-%E6%B7%BB%E5%8A%A0pip%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E4%B8%8B%E8%BD%BD%E6%BA%90/","tags":null,"title":"添加pip全局配置，使用国内下载源"},{"categories":["python"],"contents":" $ pipenv install Traceback (most recent call last): File \u0026ldquo;d:\\python37\\lib\\runpy.py\u0026rdquo;, line 193, in _run_module_as_main \u0026ldquo;__main__\u0026rdquo;, mod_spec) \u0026hellip;\u0026hellip; File \u0026ldquo;d:\\python37\\lib\\site-packages\\pipenv\\vendor\\shellingham\\nt.py\u0026rdquo;, line 78, in _iter_process info = {\u0026rsquo;executable\u0026rsquo;: str(pe.szExeFile.decode(\u0026lsquo;utf-8\u0026rsquo;))} UnicodeDecodeError: \u0026lsquo;utf-8\u0026rsquo; codec can\u0026rsquo;t decode byte 0xcc in position 0: invalid continuation byte\n解决方法：\n在报错信息里，找到报错的文件及代码位置\n我这边的文件是d:\\python37\\lib\\site-packages\\pipenv\\vendor\\shellingham\\nt.py，代码位置在第78行\ninfo = {\u0026rsquo;executable\u0026rsquo;: str(pe.szExeFile.decode(\u0026lsquo;utf-8\u0026rsquo;))}\n修改为\ninfo = {\u0026rsquo;executable\u0026rsquo;: str(pe.szExeFile.decode(\u0026lsquo;gbk\u0026rsquo;))}\n","permalink":"https://water711.github.io/posts/2020-04-11-window%E4%BD%BF%E7%94%A8pipenv-install%E5%87%BA%E7%8E%B0unicodedecodeerror/","tags":null,"title":"window使用pipenv install出现UnicodeDecodeError"},{"categories":["python"],"contents":"Python版本：3.7\n浏览器：Chrome 79.0.3\n一、下载Selenium浏览器驱动（WebDriver） 下载地址：http://npm.taobao.org/mirrors/chromedriver/\n（下载与浏览器版本对应的驱动，并将驱动放到python程序所在目录）\n二、获取网站cookie 1、chrome浏览器安装第三方扩展EditThisCookie\n2、手动输入账号密码登录网站，使用EditThisCookie导出cookies\n3、将cookie（列表）转换成json文件\n# -*- coding : utf-8 -*- import json\ncookies = [ { \u0026ldquo;domain\u0026rdquo;: \u0026ldquo;.51cto.com\u0026rdquo;, \u0026ldquo;name\u0026rdquo;: \u0026ldquo;gr_user_id\u0026rdquo;, \u0026ldquo;value\u0026rdquo;: \u0026ldquo;ea0dbdab-1233-4454-a237-1ba0bd7c406e\u0026rdquo;, \u0026ldquo;id\u0026rdquo;: 1 }, { \u0026ldquo;domain\u0026rdquo;: \u0026ldquo;.51cto.com\u0026rdquo;, \u0026ldquo;name\u0026rdquo;: \u0026ldquo;Hm_lpvt_110fc9b2e1cae4d110b7959ee4f27e3b\u0026rdquo;, \u0026ldquo;value\u0026rdquo;: \u0026ldquo;168979366982\u0026rdquo;, \u0026ldquo;id\u0026rdquo;: 2 }, \u0026hellip;\u0026hellip; ]\nwith open(\u0026ldquo;cookie.json\u0026rdquo;, \u0026ldquo;w\u0026rdquo;) as f: json.dump(cookies,f) print(\u0026ldquo;已保存为json文件\u0026hellip;\u0026rdquo;)\n三、使用cookie自动登录网站 from selenium import webdriver import json\n#打开浏览器 driver = webdriver.Chrome()\n#访问网址 driver.get(\u0026ldquo;https://www.51cto.com/\u0026quot;)\n#最大化浏览器窗口 driver.maximize_window()\n#从json文件中载入cookie,并转换回列表 with open(\u0026lsquo;cookie.json\u0026rsquo;, \u0026lsquo;r\u0026rsquo;) as f: cookies = json.load(f)\n#添加cookies到当前浏览器 for cookie in cookies: driver.add_cookie(cookie)\n#刷新当前网页 driver.refresh()\n","permalink":"https://water711.github.io/posts/2020-03-29-pythonselenium-%E4%BD%BF%E7%94%A8cookie%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E7%BD%91%E7%AB%99/","tags":null,"title":"Python+Selenium 使用cookie实现自动登录网站"},{"categories":["other"],"contents":" 一、配置Fiddler允许远端设备连接 Tools-\u0026gt; Options-\u0026gt;Connections，勾选\u0026quot;Allow remote computers to connect\u0026quot; （修改后需重启Fiddler）\n二、配置抓取https请求 Tools-\u0026gt; Options-\u0026gt;Connections，勾选\u0026quot;Capture HTTPS CONNECTs\u0026quot;、\u0026ldquo;Decrypt HTTPS traffic\u0026rdquo;\n三、手机设置代理IP IP和端口号为Fiddler所在电脑的IP和Fiddler端口号\n四、手机安装根证书 1、苹果手机使用自带Safari浏览器，打开http://IP:8888\n五、手机设置信任证书 设置-\u0026gt;通用-\u0026gt;关于本机-\u0026gt;证书信任设置\n","permalink":"https://water711.github.io/posts/2020-03-23-%E9%85%8D%E7%BD%AEfiddler%E5%AE%9E%E7%8E%B0%E8%8B%B9%E6%9E%9C%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85/","tags":null,"title":"配置Fiddler实现苹果手机抓包"},{"categories":["python"],"contents":"将data:image/base64转换成图片 import base64\nvalue=\u0026ldquo;qeBQAAAABJ\u0026hellip;\u0026hellip;RU5ErkJggg==\u0026rdquo; #填写base64编码 img = base64.b64decode(value) fh = open(\u0026ldquo;pic.jpg\u0026rdquo;,\u0026ldquo;wb\u0026rdquo;) fh.write(img)\n将图片转换成data:image/base64 import base64\nwith open(\u0026ldquo;pic.jpg\u0026rdquo;,\u0026ldquo;rb\u0026rdquo;) as f: base64_data = base64.b64encode(f.read()) print(base64_data)\nbase64编码 iVBORw0KGgoAAAANSUhEUgAAAH4AAAB+CAMAAADV/VW6AAAC91BMVEUAAACgekagekagekagekagekagekagekagekagekagekagekagekagekagekb//v7//v6he0f+/v7+/f3t5dvp39Ojfkyqh1j7+fb28u308Or+/fz59/T59vL07+i/pYH+/f39/Pv8+/n49vHx6+Lv6eHo39LZybTSv6bOup/Ap4TQvqS/poPOup6vjmL9/Pv8+/n7+ff7+fbz7ujw6uLv6eDr49jj18jl2szh1MPTwane0L3YybPGr5C5nXb//v77+ff59/Py7eXs5Nrl2szp4NTh1cTh1cS5nXetjWClgU/49fH39PD18ezVxK7Rv6WujmGtjF/9/Pv8+/r6+Pbg08LHsZL8+/n9/Pv49vL7+fb28u3///+duvaat/OcufWWs++kwf2rxv+YtfGiv/uUse2RruqgvfmZtvKwyf+PrOifvPiMqeWNquaOq+eoxP+mw/+tx/+Vsu6TsOy1zf+JpuKLqOSuyP+QremKp+Oyy/+IpeGHpOD9/f/k7P3u9P77/P/8+vejvvX9/PmlwPfj6/y8z/f5+/+gu/P68u7p7/u0yvf89PD75Of09/7w9f24z/3L2/v79vL56+m4zv/3+f7P3fvB0/qnwvnX4vikvve5zfXp8P3m7v3b5vzf6PvX4/vF1vq5zvepwfX9+PT76ej34eL319/7/P7J2Pm80Pmvx/jI1/Wxx/XgyfL58Oz46Ob43eL2y93xxtu80f/Dzf/y9v7S4Pupw/itxPS3vPGkuvH10PDEvO3uyOXnweDYt9n9/v/r8f2lwPnS3vesvfa/0fTQxPKtuvL50/Cdt+6js+v73ujXwOj1zOfNt+GdqN+1rd3ivNzOtNu6zP/Iyv2zy/yow/vZzPq4zPbszvL77On70ufPvOfnxOWmruTcvuHvxd+hqN7hvNq7rNrlvNnIzf6xwvvgzvnIxfflzfW3yvKzx++lve6qtu7wzOuZr+n72eicrOT24+OOpuHFs9+Upt+KpN+rqt320NyzuO26sN/XuNpRZOGQAAAAXHRSTlMAAgYKFQ4RHyMbFyctKjH++jP284SBNijVs6Lvyb+qNfHu4smTjYtkWVZJRkRDLOfm2NKypJiPe2xjXFlPOzH73NOZlX51dF8/PDLDvb1gUTkx7OrNak/r6dHPrPzWJTkAAA+JSURBVGjetJhZbI1BFMetvVerqVApLSqWJ2ktiYSoEol4IBFCIowqXTSllkqljV2paoMgRe37FmslqIZaGyEoHkRiXyJiidi3B2fmnO8738zccjXt/wVFfvP/n2Xm3ga1VUOvGtS7mKur/o9hoxsFUD0fQSc3NqSdoZ7YXnBTTfizejoBswkcEhLSxKsQEB2CT1DXcIVGcGhoaDOP4I/qEMYJ6g7ObAn2+Xx+qajYRPWrDyQPIY+AJ6AD1CEc2ICW4NghkdHD2vRoKZQ6dhrVtsvghCi/PAKdgA9QF3AwDr4Vu1tk2+4ikFqMje6TCEdQJ+AD1J5PcGUc2f2iO4m/qUW7yP5+6wB1AvfHDbJt24poNzhengAPgPxa0rHmCO87NEIEqZhB/ekAtQ6ArSt4n57if9SiQxwcAErAAdTKOjQcwIe0sTM+uvfHicrnd+7cqTxRdnztIusA0bF+HwXA/ODpjnXo9WEGeW3Z79tZs2dPBWVlZU2bljktM/Pxrad784VXrbpGqQo4BagFHaxHdYXxZuXvO1+dl5OXR3SAA14qNz39w62y5cKjngl2AMGXHa1rue89/zUnJw/geVNno3WAEx00a1bal32eOgwYBAFo/GDpFHxrj/X8su9zckBkHfAgsg50xKelXa/0RNArzg8F+A++N/j4th74iWoJR/PIx+TROtFB2dnJT/gAHUerAjA/aLq/Pwcf8ePZnDmOdxBZB4Fzsp6OdMAnp1Qucv9nVy8/WHpoM38CL7ljt+c6dIo+C9sOg8+VdPBO5kEp7/cJR+OgAYLiU88jvV8rN/eX3+ZIEVzhue0kHaTTUzIyHroVaB8fJN9D7+s23dEXcx3vXPYa6p4GdInPAFUcF6R2iUHwiY51H+LS931lOuCp5wmfS3S27phPAj3Kd/jB+Gc6Jx/xcq7unSdOdh1PHPIVG+CAlzq7xsk/yofz9xc8tp2kd4sRqEV3AQ5ScPLOyev0bOme+ElKEyaccRqgQ5jk6/Zt89D0MO+xAx06lB347J2sY/CEp6bP5uiTiA66ulag5PyFmHw7eth1Ye0FavdtRc8xkwe45p2Cz6auY/r48eM3HqMq9vVT+WvAU9P7/F3YO1rH6E26sesoePJOeNAV4sfA/tXLb0ev2i6CzvuF6fq8Z0oZu44HnuCKDppw/ahQGhVllN+OHgqf2EOgzgM8sHcaeHvXSTrhCT5lQnLKT+r/LlB+PX47+rBoop8A77zr0DovO0pep1PPEx29yzjO4vwPSDDjt6NPoOg/fUO42XWZvOd53nnbZCDc9Y4nekTXbxR1v4nnru9FTf9Mlh3n3cVz3QMmz4XX6SDav5HU/WTfNt9aoHDd2HT0TniiO9ZTtK5jOugqlj8mFvho3zYP9MQYWvRMV3D3gvd6R7y25+3k6Uc3hFI0LD/bPpn3hfWmia/2RO9az0K42XVMR7F3bzEw/pb92b5tPpZumpfGvGehdwl/W7pKgJbNP1TB6yYlGZMnFNMz3POcyTfsBzDflW74z/rbBujTMPi3FwWr9BrC6ZYh6XXnVrhp2efGw7aPH0kLh+hW15UKqf2rFqwUKoL72dx1euEdOm+AK4tw94T5qPm17GXbDybzOQjPweRBCE8vkuzL5clQ9oqqIgE6hHR709rrbwraHxOPqxfxnD3MfDsyT941OuCLVOBu121aBn/ehHgOnr270SN98hWsfh8zfcweHhlIX/MZ6YjnW+aydItNj01XKJuwkK9Ynnf+GfyA6JMnP8CHDzcfZy8brwste7XnEe95XbxDOlrHicsoEWILp4xwc+KIDjqLn31p9TCeLpueeM9+9+w69p67VIgi3jb4pi2Hf19ueedmYLpUKr58Wqvmo/Q5+zi6a7S647IBXYO/euf9JJUtx32bEFuJxHXXys741NRzgdJ3so9E/HODTpu2iswTneb9sBAlkrR463xHS6Xwt+sU26WnvopQoz/CSZ/7nl94z7x0N/rcUqg873nnRV14QYhdgD8lAkrhiS61R0gNYTxnH95RSK01Wp7o6VD6N0jXXlbQ/MUQ8/qA9GUUvIOfiKPfG9KXxdfww6nvjVvGeVgVAT5du+NUg8ES3ik7rPigVMEmqZ0FqIOnyTvBJ058rRCdufhc+tZ00TPcvd+BLt1XOSPnWfMrwb3Eo6yJYzjy1eJtFY7pM57feNWI15MHQe0ve29YHK7F8D+WuHQ4k0ln71IzVihGnIPnzgvHjbtc++4C8Ln0CboKetyiJ0HNV3n2vH7H2fSJD3Dv4uQDnjuvO355ZH5v4zys5NwX8CcpShk6b531umA6Nx3iZxzBD1xO7zF+BL5wywhvRA/8bdDJycbb5oDMXr/fadEHps/A3uvg9J513zyfbT7rUGlpFfC3RTTwRNoJPzpFuw7LwdYD0qfPVCaHhpv4sH7U+Gby/KI+JPmFiHcKL1byq7KwcLHUxo1LpDaALPr0SbvVez/cT3e+O3d9EP8L8TzvjM+G+EVJQQb1d/lWATrt3LBJW+dZ2pzKdAkH/HIB6gSTZ+DppfPY/vaA93ypkH63ry8uLli9RYAWFuNWl95FACGevU+apC69jgY+1L1wPiIevVvfmB0QmjbvorrLOLYv279//0JN8xGPcKCDjqm907wmfCYFz3XXvrvYtY3hJ3foN2yhp/KXLm3YcO+e6R2Ee6dGvN51IPOW2bVj28WSkpNb1hUbb1oed7Pn2fzMf+H/9G7er1EFQRxXsN97dxfFQ7FgIxYCKtEE84sVsVdUhLUregjigXBwYIlijyUoKtZYQUKiglGxYkPFhmJv6C8q/mD5D5zdmefs3tzhA8v8Zox+3nfazu57i4uMyDqqdzFBytkGjOmID+Cab/DNJb4lxZ48Dyb2cXh6sO5wzcaNG6vPcb3n6fMs/hc8BfjcsR9KmY/a2fPu2cWeqg1rg9CvrqyeZu2khHYR9xSYyfyJEt9PGXtEFcdwXmVW7tisXNt3SGgXgTf1jvR0Km3qvrcn6p6mjYeLXOns+QWVS/FXNu9dtnrvmav0ADUCLrQDGulgput19hlfH/HDlLHHebTPeXlGgW3Zcegwss4dqtyrtFXhIjPjt3TNz5ie35rxwZLjtcAVL2fcqeFsWOOeWdXsN4902Co5mXUsPplOP8VhTy85Gl+P8a1wvQ9y3j2kvqEHx51c3dpmQthrlutdZ/Wv9b1yuW37QTuLT6aTyS8GMkQuuH5rnHaCFdapON3sV69kOvZ5yHkcsa9Wk/ZdyjVbexroyTtKWzceN2iL1cQvwS3Wdwo8S0fPV2GKkeutijuoHbNbF9zC+deXO/TNIJ7jngQzZd9/PG2zcNTEXUZXSn2aLqxeVwM/PiB2UoDHH2n+Por73K2BnQZLzSYjeDJzhOsua9AeFzf4DxB2R7zZx14jOnue+rz+2Q74ZwetqZLXOEc6GGZee5/xnHt4oHiS4DzP6/99JeF5orZ7HVTg0utimSG6jb9oEKWY+C7eH4TBv+vUO84Rx52cF1PlOQUDrztSu72OXJ85aghFzi4nK/jviR5MlcchheQa5+ThwirIPiCz59n1lPMAT2aemOOVVl6kKWUe4rHrj+iIlY9wpANoMwTWqXfKOp6oseB25l5h05pO4l9R0+HQ28FvT94H+jysdzB9gLHO4HmFlfP8MqgNpLN2piM8swT312O177PxUPm06H2w38ssqISqsrSL6QLxB8H74HdXe8q4PknalyypMw1/gCcPV9D7vbDxAZtfyMHOtlL2Oj4ww/X9Gfy7ZwS3+zxrB/wPpa3EF0dL5P0ulHwYdwwx9LFDlGOcda52sFkrIPiB9sXkePa8hi95YnbX8SL2vXu05RfFsfTtNyPQc6pznFkxHAtuCzgJtROc1rgk47HoW9u+dw/2PPpc4K11VKoADxx3ppWnB+Cks6hd0jOGvv2I0lYW+N7GU+fpjvht1ouRq7CHRdQ0Pjm26MTfa9S7cU+ydDBc7Dp74kSdk88bhfwrHOOXVTul5/En9nTxbP9ZptuNPkP4OjzQ7kriES/k4y6//CuSwPKf08rJSvZ5Fn+PxHPiMZ7lF9O7nOyDChF3rDimO4E3BYfiif7C6IqVOeKl/GFtsPW9dauLO608PZATdVa967yrUNqKWTzihXza7VRcMPxpOc5t8s60uXqd4/oORVnipfzoQOSfYqHcaWdA3OWZFXcb8nyKpaN9UcZactpn4+ltUhOvWxx/9zLSRad14bTKAF50WsZ/XIV5F40I8eItqjcY8bH7cg8r4g4m+jynPOFPY+Db9PDFO1T5GtUf0Rb55ZdIu6w46Xmiy4KDtDuqjA01rmfxUj5kH7i/aCK91DlPFSe05z09MPQ0Saek36SM9WHX58Sz+8fEKf3P83SRt+Iw7FkVh3Cb3nkEuZ7FS/eb7I94Q1TAB+3TRadl8TLu1GkRzvQBwzzx6UpO95vqG6zI/5eEdqaLmZY8z+K3P6G4d5zsyQ93pHxc+IHfh/jl9xHP9Z5dcURPId6t97oTRO8GdJn1+fkF7YkfuyziLnJezPOEf3GEvhks8yIUeImX4Tf8QL86dlvQZc7zAs85fyfG2jVdul7iiY/xpwS4T3iiy6xLObMNtbrXCq1Xd0EPxS+NK7JTt0XSId9UHA8XjN9+cZVCa1Uk6CH5Y3oF/PLLuznrZM5TwXHcP1costbjbDrgw/O9YaPVrwi8243aHdfnnmlfHFVk8cIo5DzSSXxYvu4/BYVxFVjF5ZtWuYteh3StHIJONqBb1Bf00B+rNo740W6t7C+kb9naUbnbaevuVPBHyn3GeT70OkEP/aEwBCBR0kKxrX9z63mgHc2SXnfxdYx/dWAZOF5+JByerxMg4kV7FMeUZeWbvt36tDg7656+uge62XoOSXja8dDnmR6eTwlgHBDtPpoegDNx270H32pra2/V1r66+ONoRdbfdywZTtIFPQzfdYDvFXQvjqvQ1qkQ4fh5vqCH54MDdAZEfAjB4E6h2LF2QxNRz7dvZwh4SD45gB4g0bV9x9+xB5b0KNDK0e8s/Y+vpkQiHjzBmL5T80ZhyuiWmu2D2wHO0iU9PJ8fwLjAixYM71pYPHCCA453GtmndHLCsDHmAv6nD2BcAD7QjxAtSAzv3nVoacvCwiGlk8p6JIAc9ZANcPda1l+9EYaP4HtgUTQPzAeyDjgJF/C/8QDaBQ1+XYeLsOGdOEDzfTSC/5PbgOAFeAg2+JNGE5vgRP+rDwBmXYVsZozuQ4q7iP/uJmhDsEZs7mVQ/OV/eA8WUWxEluz/dAmY0P+QzY8gnuK/X8Zm3h+SfwKZYCG4mfqeBQAAAABJRU5ErkJggg==\n","permalink":"https://water711.github.io/posts/2020-03-02-dataimage-base64%E4%B8%8E%E5%9B%BE%E7%89%87%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/","tags":null,"title":"data:image/base64与图片互相转换"},{"categories":["linux"],"contents":"一、申请阿里云免费SSL证书 2021阿里云SSL免费证书购买地址又变了，为了解决免费证书近期存在的吊销、统计等问题，自2021年起，免费证书申请将切换到证书资源包下。\n1、 打开阿里云SSL证书选购页面，点击“选购证书”\n2、 商品类型选择“云盾证书资源包”\n3、 资源包规格选择“免费证书扩容包”\n4、 资源包个数选择“20”\n选择完毕后总配置费用为0元，然后点“立即购买”支付0元即可。\n二、控制台证书申请 1、登录到SSL证书管理控制台\n2、 选择左侧栏”证书资源包“\n3、点击“证书申请”\n4、下载证书\n证书绑定域名：填写你要申请SSL的域名，如www.xxx.com\n域名验证方式：如果你的域名在本账号下，可以选择自动DNS验证，阿里云系统会为你的域名添加_dnsauth的TXT解析记录；如果域名不在本账号下，可以选择手工DNS验证或文件验证。详细教程参考：阿里云SSL证书申请域名验证选择及操作流程\n联系人：填写联系人信息，可以新建也可以选择之前保存的\n所在地：根据实际情况选择即可\nCSR生成方式：CSR文件是您的公钥证书原始文件，包含了您的服务器信息和您的单位信息，需要提交给CA认证中心审核。建议默认即可，使用系统创建的CSR，避免因内容不正确而导致的审核失败。\n三、Nginx服务器上安装证书 1、创建cert目录，将下载的证书文件和密钥文件拷贝到cert目录\n[root@server ~]# mkdir /etc/nginx/cert\n2、修改虚拟主机配置文件\nserver { listen 80; server_name www.xxxx.com; root /data/web/; location / { index index.html index.htm; } }\nserver { listen 443 ssl; server_name www.xxxx.com; root /data/web/; index index.html index.htm; ssl_certificate /etc/nginx/cert/www.xxxx.com.pem; ssl_certificate_key /etc/nginx/cert/www.xxxx.com.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { index index.html index.htm; } }\n3、重新加载nginx配置文件\n[root@server ~]# systemctl reload nginx\n[root@server ~]# ss -lanp | grep 443 #查看443端口是否在监听\n4、防火墙放行443端口\n如果使用的是阿里云ECS服务器，进入ECS控制台安全组页面配置放行443端口\n5、浏览器访问https://域名\n如果网页地址栏出现小锁标志，表示证书安装成功\n申请阿里云免费SSL证书（旧已失效）\n1、打开阿里云官网，搜索SSL证书\n2、点击“选购证书”，选择免费版（个人）\n3、购买成功后，进入SSL证书管理控制台，进行申请和验证\n如果域名提供商在阿里云验证就简单了，只要选择自动DNS验证方式，那么证书审核通过之后会自动的添加一条域名解析记录\n如果域名在其他服务商那里，就要手动给域名添加一条DNS解析记录\n4、审核成功后，进入SSL证书控制台，下载证书\n5、下载后解压，得到证书和秘钥文件\n.pem：证书文件。\n.key：证书的密钥文件。（申请证书时如果未选择自动创建CRS，则下载的证书文件压缩包中不会包含.key文件，需要手动创建的密钥文件）\n","permalink":"https://water711.github.io/posts/2020-02-24-%E7%94%B3%E8%AF%B7%E9%98%BF%E9%87%8C%E4%BA%91%E5%85%8D%E8%B4%B9ssl%E8%AF%81%E4%B9%A6%E5%B9%B6%E9%83%A8%E7%BD%B2%E8%87%B3nginx%E6%9C%8D%E5%8A%A1%E5%99%A8/","tags":null,"title":"申请阿里云免费SSL证书并部署至Nginx服务器"},{"categories":["linux","other"],"contents":"环境： 服务端操作系统：Centos7\n客户端操作系统：Centos7、Win7\n一、NPS介绍 nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持tcp、udp流量转发，可支持任何tcp、udp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析等等……），此外还支持内网http代理、内网socks5代理、p2p等，并带有功能强大的web管理端。\ngithub文档：https://github.com/ehang-io/nps/blob/master/README_zh.md\n二、阿里云ECS安装NPS服务端 1、下载对应系统的软件压缩包\ngithub地址：https://github.com/ehang-io/nps/releases\n[root@ECS ~]# wget https://github.com/cnlh/nps/releases/download/v0.25.3/linux_amd64_server.tar.gz [root@ECS ~]# tar xvf linux_amd64_server.tar.gz -C nps_server/\n2、修改NPS配置文件\n[root@ECS ~]# vim nps_server/conf/nps.conf appname = nps runmode = dev bridge_type=tcp\nbridge_port=8074 #服务端客户端通信端口 bridge_ip=0.0.0.0 public_vkey=123 #客户端以配置文件模式启动时的密钥 log_level=7 web_username=admin #web界面管理账号 web_password=aassdd #web界面管理密码 web_port = 8811 #web管理端口 web_ip=0.0.0.0\n官方配置参数详细说明：https://ehang-io.github.io/nps/#/server_config\n3、安装并启动服务端\n首先前台启动，查看是否能正常运行\n./nps start\n前台运行成功后（ctrl+C 关闭），执行安装操作\n./nps install #安装后，web前端和配置文件位于/etc/nps/目录下,主程序在/usr/bin/nps\n4、阿里云ECS配置安全组策略（端口放行）\n放行NPS通信端口\n放行web管理端口\n三、配置windows客户端转发3389端口流量 1、浏览器访问NPS前端页面：http://域名或IP : 端口\n2、新增客户端\n点击客户端列表前面的+号，展开详细内容，查看客户端连接命令\n3、下载nps客户端软件 ，解压后进入cmd命令行，运行连接命令\n下载地址：https://github.com/ehang-io/nps/releases（注意版本要与服务端一致，否则可能会连接失败）\n4、注册到系统服务，开机自动启动\nnpc install -server=www.xxx.com:8074 -vkey=trr2r53jtqj8q2q -type=tcp\n5、客户端连接成功后，登录web页面，配置穿透服务\n新增tcp隧道（下面规则为：当访问服务端37123时，流量会转发到客户端id为7的3389端口）\n客户端id在客户端列表页面查看\n6、登录阿里云ECS配置安全组策略（放行端口37123）\n7、测试，输入NPS服务端IP和端口\n四、配置Linux客户端转发ssh端口流量 1、浏览器访问NPS前端页面：http://域名或IP : 端口\n2、新增客户端\n点击客户端列表前面的+号，展开详细内容，查看客户端连接命令\n3、下载nps客户端软件 ，解压并运行连接命令\n下载地址：https://github.com/ehang-io/nps/releases（注意版本要与服务端一致，否则可能会连接失败）\n[root@server nps]# ./npc -server=www.xxx.com:8074 -vkey=qaxs234jy1zz5n -type=tcp\n4、注册到系统服务(开机启动、守护进程)\n[root@server nps]# ./npc install -server=www.xxx.com:8074 -vkey=qaxs234jy1zz5n -type=tcp\n5、新增tcp隧道，即添加转发端口（下面规则为：当访问服务端8282端口时，流量会转发到客户端id为5的22端口）\n客户端id在客户端列表页面查看\n6、登录阿里云ECS配置安全组策略（放行端口8282）\n7、测试\n[root@test ~]# ssh -p8282 root@www.xxx.com\n五、配置P2P内网穿透 使用场景 点对点传输，可用于大文件传输的场景，如在内网架设NAS，流量不经过服务器转发\n要求 目标内网设备与访问端都需要运行npc，且二者NAT类型不能同时为对称型网络\n1、编辑服务器配置文件，开启p2p穿透\n[root@server ~]# vim /etc/nps/conf/nps.conf #p2p p2p_ip=\u0026lt;服务器公网IP，不要填域名，不要填127.0.0.1\u0026gt; p2p_port=\u0026lt;默认使用6000端口，可自行配置\u0026gt;\n重启nps [root@caizhenwei ~]# /usr/bin/nps stop [root@caizhenwei ~]# /usr/bin/nps start\n2、进入nps管理后台，添加一条P2P转发记录\n输入需要连接的客户端id\n内网目标输入127.0.0.1:3389（这里是指访问客户端id为9的3389端口）\n唯一验证密钥：作为目标端的身份标识。如果有多条p2p记录，请保证唯一验证密钥不要重复。\n3、添加P2P记录后，点击该记录前面加号，查看访问命令\n4、在访问端下载nps客户端，输入访问命令，连接后访问端通过访问本地 127.0.0.1:2000 来访问目标机器3389端口\n如果要修改访问端的本地默认端口2000，可在命令后添加\u0026quot;-local_port=xxx\u0026quot;来指定\n","permalink":"https://water711.github.io/posts/2020-02-19-%E9%98%BF%E9%87%8C%E4%BA%91ecs%E6%90%AD%E5%BB%BAnps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%9C%8D%E5%8A%A1/","tags":null,"title":"阿里云ECS搭建NPS内网穿透服务"},{"categories":["linux","zabbix"],"contents":" 一、开通腾讯云短信服务（需要实名认证） 官方文档：https://cloud.tencent.com/document/product/382/18071\n二、创建短信模板 短信模板内容中：{1}{2}{3}为发送信息时，需要传递的参数内容\n三、编写发送短信的Shell脚本 官方API接口文档：https://cloud.tencent.com/document/product/382/5976\n#!/bin/sh\ntime=`date +%s` appkey=bada123234534590d23403\nappid=123456789 random=$(($RANDOM*$RANDOM)) tem_id=123456 #模板ID\nmobile=$1 #手机号，从zabbix传入的第一个参数 message=$2 #告警信息，从zabbix传入的第二个参数 IFS=\u0026rsquo;;\u0026rsquo; #定义内部分隔符 arr=($message) #将message转化为数组，按;号分隔 event_time=${arr[0]} host_name=${arr[1]} event_name=${arr[2]}\nstr=\u0026ldquo;appkey=$appkey\u0026amp;random=$random\u0026amp;time=$time\u0026amp;mobile=$mobile\u0026rdquo; #腾讯定义的sig字段格式 sig=`echo -n $str | sha256sum | awk \u0026lsquo;{print $1}\u0026rsquo;` #加密后的sig字段\ncurl -i -X POST -H \u0026ldquo;\u0026lsquo;Content-type\u0026rsquo;:\u0026lsquo;application/json\u0026rsquo;\u0026rdquo; \\ -d \u0026lsquo;{ \u0026ldquo;ext\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;extend\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;params\u0026rdquo;: [\u0026quot;\u0026rsquo;$event_time\u0026rsquo;\u0026quot;, \u0026ldquo;\u0026rsquo;$host_name\u0026rsquo;\u0026rdquo;, \u0026ldquo;\u0026rsquo;$event_name\u0026rsquo;\u0026rdquo;], \u0026ldquo;sig\u0026rdquo;: \u0026ldquo;\u0026rsquo;$sig\u0026rsquo;\u0026rdquo;, \u0026ldquo;sign\u0026rdquo;: \u0026ldquo;xx公司\u0026rdquo;, \u0026ldquo;tel\u0026rdquo;: {\u0026ldquo;mobile\u0026rdquo;: \u0026ldquo;\u0026rsquo;$mobile\u0026rsquo;\u0026rdquo;, \u0026ldquo;nationcode\u0026rdquo;: \u0026ldquo;86\u0026rdquo;}, \u0026ldquo;time\u0026rdquo;: \u0026lsquo;$time\u0026rsquo;, \u0026ldquo;tpl_id\u0026rdquo;: \u0026lsquo;$tem_id\u0026rsquo; }\u0026rsquo; \\ https://yun.tim.qq.com/v5/tlssmssvr/sendsms?sdkappid=$appid'\u0026amp;'random=$random\n测试运行\n[root@zabbix ~]# sh send.sh 15012345678 \u0026ldquo;2020.02.18 16:54:20;FTP Server;Unavailable by ICMP ping\u0026rdquo; HTTP/1.1 200 OK Server: nginx Date: Tue, 18 Feb 2020 09:13:21 GMT Content-Type: application/json; charset=utf-8 Content-Length: 82 Connection: keep-alive Keep-Alive: timeout=86400 Access-Control-Allow-Origin: * Access-Control-Allow-Headers: X-Requested-With,Content-Type Access-Control-Allow-Methods: POST\n{\u0026ldquo;result\u0026rdquo;:0,\u0026ldquo;errmsg\u0026rdquo;:\u0026ldquo;OK\u0026rdquo;,\u0026ldquo;ext\u0026rdquo;:\u0026quot;\u0026quot;,\u0026ldquo;sid\u0026rdquo;:\u0026ldquo;2104:7301832515820172018179366\u0026rdquo;,\u0026ldquo;fee\u0026rdquo;:2}2020.02.18 16:54:20 FTP Server Unavailable by ICMP ping\n将脚本移动到Zabbix指定目录\n[root@zabbix ]# cat /etc/zabbix/zabbix_server.conf | grep AlertScriptsPath #查看zabbix配置文件，找到存放脚本的目录\n[root@zabbix ]# chmod +x send.sh [root@zabbix ]# mv send.sh /usr/lib/zabbix/alertscripts/\n四、配置Zabbix 1、创建报警媒介类型：管理-\u0026gt;报警媒介类型-\u0026gt;创建媒体类型\n2、为用户添加报警媒介：管理-\u0026gt;用户-\u0026gt;报警媒介-\u0026gt;添加\n类型：短信（报警媒介类型）\n收件人：收取短信的手机号码（对应{ALERT.SENDTO}变量，将传入脚本第1个参数）\n3、配置事件触发后的动作\n","permalink":"https://water711.github.io/posts/2020-02-18-zabbix%E9%80%9A%E8%BF%87%E7%9F%AD%E4%BF%A1%E5%91%8A%E8%AD%A6/","tags":null,"title":"Zabbix使用腾讯云短信进行告警"},{"categories":["linux"],"contents":" Oracle官方11g安装文档：https://docs.oracle.com/cd/E11882_01/install.112/e24326/toc.htm\n一、下载对应Oracle安装包 1、查看操作系统硬件架构类型\n[root@server ~]# uname -m x86_64\n2、官网下载对应安装包\nhttps://www.oracle.com/database/technologies/oracle-database-software-downloads.html#11g\n二、安装oracle所需依赖软件包 #64位系统yum默认不安装32位的包，修改yum.conf，同时安装32和64位包，安装完记得还原配置 [root@server ~]# echo \u0026lsquo;multilib_policy=all\u0026rsquo; \u0026raquo; /etc/yum.conf\n[root@server ~]# yum install \\ binutils* \\ compat-libcap* \\ compat-libstdc* \\ compat-libstdc* \\ gcc* \\ gcc-c++* \\ glibc* \\ ksh \\ libaio* \\ libgcc* \\ libstdc* \\ libXi* \\ libXtst* \\ make* \\ sysstat* \\ unixODBC* \\ elfutils-libelf*\n三、创建Oracle用户、组和安装目录 [root@server ~]# groupadd oinstall [root@server ~]# groupadd dba [root@server ~]# useradd -g oinstall -G dba oracle [root@server ~]# passwd oracle\n[root@server ~]# mkdir -p /u01/app/oracle [root@server ~]# chown -R oracle:oinstall /u01/app/ [root@server ~]# chmod -R 775 /u01/app/\n四、修改内核参数和调整资源限制 修改内核参数：\n[root@server ~]# vim /etc/sysctl.conf fs.aio-max-nr = 1048576 fs.file-max = 6815744 kernel.shmall = 2097152 kernel.shmmax = 536870912 kernel.shmmni = 4096 kernel.sem = 250 32000 100 128 net.ipv4.ip_local_port_range = 9000 65500 net.core.rmem_default = 262144 net.core.rmem_max = 4194304 net.core.wmem_default = 262144 net.core.wmem_max = 1048576\n[root@server ~]# /sbin/sysctl -p #重新加载内核参数\n调整oracle用户的系统资源限制\n[root@server ~]# vim /etc/security/limits.conf oracle soft nproc 2047 oracle hard nproc 16384 oracle soft nofile 4096 oracle hard nofile 65536 oracle soft stack 10240 oracle hard stack 32768 说明： soft nproc: 单个用户可用的最大进程数量(软限制) hard nproc： 单个用户可用的最大进程数量(硬限制) soft nofile：可打开的文件描述符的最大数(软限制) hard nofile：可打开的文件描述符的最大数(硬限制) soft stack: 堆栈(软限制) hard stack: 堆栈(硬限制) 当数量达到软限制的时候会出现报警，达到硬限制的时候才不会增加\n五、配置Oracle用户的环境变量 [root@server ~]# su - oracle\n[oracle@server ~]$ vi ~/.bash_profile ORACLE_BASE=/u01/app/oracle ORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1 ORACLE_SID=orcl export ORACLE_BASE ORACLE_HOME ORACLE_SID\n[oracle@server ~]$ source ~/.bash_profile #立即应用配置\n六、配置X11图形环境 概念：\nX Client：发送图形数据\nX Server：接收图形数据，输出到显示屏\nOracle服务器为X Client，安装以下包\n[root@oracle ~]# yum -y install xorg-x11-xauth\n本地主机为X Server：\n情况一：本地主机为windows，安装Xming（作为X Server）：下载地址和使用方法查看上一篇文章\nhttp://caizhenwei.top/linux/213.html\n情况二：本地主机为Linux（已安装图形化桌面），使用 ssh -X oracle@IP，登录服务器（-X ：使用X11转发图形，注意是大写X）\n七、解压并安装Oracel 11g 使用oracle用户解压：\n[oracle@server tmp]$ yum -y install unzip [oracle@server tmp]$ unzip linux.x64_11gR2_database_1of2.zip [oracle@server tmp]$ unzip linux.x64_11gR2_database_2of2.zip\n运行安装脚本：\n注意：下面操作需要使用oracel用户进行安装，而且不能使用root用户切换到oracle，要直接在xshell或putty中用oracle用户登录，否则x11图形转发会失效\n[oracle@server4 tmp]# cd database/ #进行安装包目录 [oracle@server4 database]# ./runInstaller #运行安装脚本\nStarting Oracle Universal Installer\u0026hellip;\nChecking Temp space: must be greater than 120 MB. Actual 35878 MB Passed Checking swap space: must be greater than 150 MB. Actual 2041 MB Passed Checking monitor: must be configured to display at least 256 colors \u0026raquo;\u0026gt; Could not execute auto check for display colors using command /usr/bin/xdpyinfo. Check if the DISPLAY variable is set. Failed \u0026laquo;\u0026laquo; #上面检查x11图形的DISPLAY变量失败，手动检查$DISPLAY变量是否存在，如果有输出localhost:x.0（x为任意数字），则输入y继续安装 Some requirement checks failed. You must fulfill these requirements before\ncontinuing with the installation,\nContinue? (y/n) [n] y #输入Y\n检查先决条件，semmni内核参数这里检查有误，实际的值为128，这里检测为0，忽略掉\n其它的Package检测失败，因为实际包的版本比这个要高，所以检测为Failed，这里确认所有包都装上后，点击右上角ignore all\n报错：Error in invoking target \u0026lsquo;agent nmhs\u0026rsquo;of makefile\n解决方法参考：https://blog.csdn.net/baidu_39459954/article/details/80624640\n#将$ORACLE_HOME//sysman/lib/ins_emagent.mk文件里的，$(MK_EMAGENT_NMECTL) 修改为 $(MK_EMAGENT_NMECTL) -lnnz11\n[oracle@server ~]$ cp $ORACLE_HOME/sysman/lib/ins_emagent.mk{,.bak} #备份文件 [oracle@server4 ~]$ sed -i \u0026rsquo;s/$(MK_EMAGENT_NMECTL)/$(MK_EMAGENT_NMECTL) -lnnz11/g\u0026rsquo; $ORACLE_HOME/sysman/lib/ins_emagent.mk #查找并替换\n修改完后点击Retry\n弹出提示框：手动使用root用户执行两个脚本\n[root@server ~]# sh /u01/app/oraInventory/orainstRoot.sh [root@server ~]# sh /u01/app/oracle/product/11.2.0/dbhome_1/root.sh\n执行脚本后，点击OK，完成安装\n八、创建数据库 将oracle的bin目录添加到环境变量\n[oracle@server ~]$ vi ~/.bash_profile export PATH=$PATH:$ORACLE_HOME/bin\n[oracle@oracle ~]$ source ~/.bash_profile #立即应用配置\n打开数据库创建向导\n[oracle@oracle ~]$ dbca\n安装过程请参考之前的文章\nhttp://caizhenwei.top/other/194.html#%E4%BA%8C%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93\n启动数据库实例\n[oracle@server ~]$ sqlplus / as sysdba\nSQL\u0026gt; startup ORACLE instance started.\n九、tip 1、Linux中安装完Oracle后，默认的 sqlplus 上下键和回退键是不能用的，需要安装 rlwrap 包才能上下键回看历史命令\n[root@server ~]# yum -y install rlwrap\n[root@oracle ~]# su - oracle\n[oracle@oracle ~]$ vim .bash_profile #在profile文件中配置命令别名，使oracle相关命令都支持回退和上下键 alias sqlplus=\u0026lsquo;rlwrap sqlplus\u0026rsquo; alias rman=\u0026lsquo;rlwrap rman\u0026rsquo; alias lsnrctl=\u0026lsquo;rlwrap lsnrctl\u0026rsquo;\n[oracle@oracle ~]$ source .bash_profile\n","permalink":"https://water711.github.io/posts/2020-02-16-centos7%E5%AE%89%E8%A3%85oracle-11g%E6%95%B0%E6%8D%AE%E5%BA%93/","tags":null,"title":"CentOS7安装Oracle 11g数据库"},{"categories":["linux"],"contents":"准备环境 Linux系统：Centos7\nSSH客户端工具：Putty和XShell\nXming下载地址： https://sourceforge.net/projects/xming/\nX Window System介绍：http://cn.linux.vbird.org/linux_basic/0590xwindow_1.php\n一、Windows下安装Xming软件（X Server） 安装运行后，在右下角系统托盘下查看并记录下Xming Server冒号后面数字\n二、CentOS7安装X11（X Client） [root@client ~]# yum -y install xorg-x11-xauth\n三、配置XShell转发Linux图形界面 右键点击会话属性\n选择SSH-\u0026gt;隧道，勾选“转发X11连接到（X），选择“X DISPLAY(D)”，输入localhost:0.0 （0.0为Windows右下角Xming后面数字）\n使用XShell连接Centos7，运行带有图形化界面的软件\n[root@client ~]# firefox\n四、配置Putty转发Linux图形界面 打开Putty，点击Connection-\u0026gt;SSH-\u0026gt;X11，勾选“启用X11转发”,X display location输入localhost:0.0 （0.0为Windows右下角Xming后面数字）\n使用XShell连p接Centos7，运行带有图形化界面的软件\n[root@client ~]# firefox\n","permalink":"https://water711.github.io/posts/2020-02-14-windows%E4%B8%8B%E4%BD%BF%E7%94%A8ssh%E8%BD%AC%E5%8F%91linux%E4%B8%8Bx11%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/","tags":null,"title":"Windows下使用ssh转发Linux下x11图形界面"},{"categories":["other"],"contents":" 一、准备实验环境 1、安装ENSP模拟器 v1.3.00.100\n2、物理机安装环回接口/网卡（运行：hdwwiz，运行硬件向导，环回网卡IP设置为192.168.0.10/24）\nhttps://jingyan.baidu.com/article/046a7b3eef6d69f9c27fa9ea.html\n3、ENSP连接物理机环回网卡\nhttps://jingyan.baidu.com/article/6f2f55a10ff227b5b93e6c02.html\n二、实验配置 1、添加防火墙USG6000，修改防火墙默认密码（原密码Admin@123，修改后admin@123）\nUsername:admin Password:Admin@123 The password needs to be changed. Change now? [Y/N]: y Please enter old password: Admin@123 Please enter new password: admin@123 Please confirm new password: admin@123\n2、防火墙管理接口开放ping、http、https访问\n#防火墙1管理接口开放ping、http、https [FW1]interface g0/0/0 [FW1-GigabitEthernet0/0/0]service-manage http permit [FW1-GigabitEthernet0/0/0]service-manage https permit [FW1-GigabitEthernet0/0/0]service-manage ping permit\n3、ENSP添加Cloud，Cloud绑定物理机环回接口，并连接防火墙g0/0/0接口\n使用浏览器访问防火墙管理页面：https://192.168.0.1:8443/\n4、添加两台路由器，模拟运营商网络\n#电信路由器 [china telecom]interface g0/0/0 [china telecom-GigabitEthernet0/0/0]ip address 101.1.1.1 30\n#联通路由器 [china unicom]interface g0/0/0 [china unicom-GigabitEthernet0/0/0]ip address 202.1.1.1 30\n5、配置外网IP地址（这里模拟接入两个运营商专线，GE1/0/6连接电信，GE1/0/5连接联通）\n浏览器访问防火墙管理地址：192.168.0.1，选择网络-\u0026gt;接口-\u0026gt;单击GE1/0/6 和 GE1/0/5\n6、配置防火墙多出口智能选路\n7、配置防火墙内网网关地址\ninterface GigabitEthernet1/0/0 ip address 10.1.1.1 255.255.255.0 service-manage ping permit\n8、配置防火墙安全策略\n测试\nPC1 \u0026gt; ping 10.1.1.1 PC1 \u0026gt; ping 101.1.1.2 PC1 \u0026gt; ping 202.1.1.2 ping 101.1.1.1 ping 202.1.1.1 结果：PC1能访问网关，防火墙能访问外网，但是PC1不能访问外网，因为还没有配置NAT\n9、配置NAT地址转换\n三、测试 1、添加一台路由模拟外网Web服务器\n2、配置Web服务器和静态路由\nWeb服务器配置：\ninterface GigabitEthernet0/0/0 ip address 1.1.1.1 255.255.255.252\ninterface GigabitEthernet0/0/1 ip address 2.2.2.1 255.255.255.252\ninterface LoopBack1 #添加环回接口，模拟服务器IP地址 ip address 3.3.3.3 255.255.255.255\nip route-static 0.0.0.0 0.0.0.0 2.2.2.2\n电信路由器配置：\ninterface GigabitEthernet0/0/0 ip address 101.1.1.1 255.255.255.252\ninterface GigabitEthernet0/0/1 ip address 1.1.1.2 255.255.255.252\nip route-static 3.3.3.3 255.255.255.255 1.1.1.1\n联通路由器配置：\ninterface GigabitEthernet0/0/0 ip address 202.1.1.1 255.255.255.252\ninterface GigabitEthernet0/0/1 ip address 2.2.2.2 255.255.255.252\nip route-static 0.0.0.0 0.0.0.0 202.1.1.2 ip route-static 3.3.3.3 255.255.255.255 2.2.2.1\n3、两台PC分别使用tracert追踪路由节点（验证多出口智能选路）\nPC1\u0026gt;tracert 3.3.3.3\ntraceroute to 3.3.3.3, 8 hops max (ICMP), press Ctrl+C to stop 1 * * * 2 101.1.1.1 47 ms 47 ms 46 ms #电信出口 3 3.3.3.3 47 ms 47 ms 62 ms\nPC2\u0026gt;tracert 3.3.3.3\ntraceroute to 3.3.3.3, 8 hops max (ICMP), press Ctrl+C to stop 1 * * * 2 202.1.1.1 46 ms 47 ms 47 ms #联通出口 3 3.3.3.3 47 ms 47 ms 46 ms\nPS：第一跳为防火墙地址，因为防火墙设备没有开启icmp不可达报文发送功能和icmp ttl超时报文发送功能；所以显示星号，可以使用下面命令开启 1.关闭tracert 防范攻击：undo firewall defend tracert enable 2.开启设备发送icmp不可达报文：icmp host-unreachable send 3.开启设备ICMP ttl 超时报文发送功能：icmp ttl-exceeded send\n","permalink":"https://water711.github.io/posts/2020-02-10-%E4%BD%BF%E7%94%A8ensp%E6%A8%A1%E6%8B%9F%E5%A4%9A%E8%BF%90%E8%90%A5%E5%95%86%E5%87%BA%E5%8F%A3%E6%99%BA%E8%83%BD%E9%80%89%E8%B7%AF/","tags":null,"title":"华为防火墙多运营商出口智能选路"},{"categories":["other"],"contents":"1、打开以下目录（win7系统） C:\\Users\\admin\\AppData\\Local\\Youdao\\YNote\\bgImage-10\n2、复制v开头的图片，修改文件名为c-xx.png 也可使用画图工具或PS，自定义图片颜色，拷贝到该目录，修改文件名为c-xx.png\n3、打开有道云笔记，在视图中选择纸张背景 ","permalink":"https://water711.github.io/posts/2020-01-15-%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%E4%BF%AE%E6%94%B9%E7%AC%94%E8%AE%B0%E8%83%8C%E6%99%AF/","tags":null,"title":"有道云笔记修改笔记背景"},{"categories":["zabbix"],"contents":"一、Zabbix服务端添加主机 #zabbix客户端在主动模式下，服务端接收数据需要开放10051端口 [root@zabbix1 ~]# firewall-cmd \u0026ndash;zone=public \u0026ndash;add-port=10051/tcp \u0026ndash;permanent success [root@zabbix1 ~]# firewall-cmd \u0026ndash;reload success\n二、安装 zabbix客户端 1、查看zabbix服务端版本\n[root@zabbix1 ~]# zabbix_server -V zabbix_server (Zabbix) 4.2.6\n2、官网下载zabbix客户端并解压（和服务端版本一致）\n地址：https://www.zabbix.com/cn/download_agents#tab:42\n3、修改zabbix客户端配置文件\n./conf/zabbix_agentd.conf LogFile=D:\\Program Files\\zabbix_agents-4.2.6\\zabbix_agentd.log #指定日志文件路径 Server=192.168.1.250 #zabbix服务端IP ListenPort=10250 #监听端口，默认为10050 ServerActive=192.168.1.250 #主动模式的ServerIP地址(agent主动上报数据到该服务器) 4、启动zabbix客户端\n\u0026gt; D:\ncd D:\\Program Files\\zabbix_agents-4.2.6\\bin #进入agents\\bin目录\nzabbix_agentd.exe -f -c \u0026ldquo;D:\\Program Files\\zabbix_agents-4.2.6\\conf\\zabbix_agentd.conf\u0026rdquo; #-f 前台运行 -c 指定配置文件 Starting Zabbix Agent [test]. Zabbix 4.2.6 (revision d3bb18bbc4). Press Ctrl+C to exit.\n服务端查看主机agent是否连接成功\n5、将zabbix客户端添加为系统服务\n\u0026gt; D:\ncd D:\\Program Files\\zabbix_agents-4.2.6\\bin #进入agents\\bin目录\nzabbix_agentd.exe -i -c \u0026ldquo;D:\\Program Files\\zabbix_agents-4.2.6\\conf\\zabbix_agentd.conf\u0026rdquo; #-i 安装为服务 -c 指定配置文件 zabbix_agentd.exe [6644]: service [Zabbix Agent] installed successfully zabbix_agentd.exe [6644]: event source [Zabbix Agent] installed successfully\nD:\\Program Files\\zabbix_agents-4.2.6\\bin\u0026gt;net start \u0026ldquo;zabbix agent\u0026rdquo; Zabbix Agent 服务正在启动 . Zabbix Agent 服务已经启动成功。\n三、监控windows用户登录成功事件 1、进入事件查看器，查看对应日志类型、事件ID，关键字\n2、服务端添加主机监控项\nkey：eventlog[Security, ,\u0026ldquo;Success Audit\u0026rdquo;, ,^4624$,,skip]\n","permalink":"https://water711.github.io/posts/2020-01-08-zabbix%E7%9B%91%E6%8E%A7windows%E6%97%A5%E5%BF%97/","tags":null,"title":"Zabbix监控windows日志"},{"categories":["linux"],"contents":"一、编写备份脚本 #!/usr/bin/bash\ndate=`date +%Y-%m-%d` #该变量用于备份文件命名 ftp_user=test ftp_pwd=\u0026lsquo;123456\u0026rsquo; ftp_ip=172.16.10.10\nfile_name=wp_$date.sql #数据库备份文件名 tar_file_name=wp_$date.tar.gzip #打包压缩后文件名\nmysqldump -utest -p123456 \u0026ndash;single-transaction \u0026ndash;triggers \u0026ndash;routines wordpress \u0026gt; $file_name #备份数据库 tar -czvf $tar_file_name $file_name \u0026ndash;remove-files #打包压缩备份文件，并删除源文件\n#由于FTP服务器不支持ssl，所以要关闭ssl，否则连接后会卡在“making data connection” lftp -e \u0026ldquo;set ftp:ssl-allow off;\u0026rdquo; $ftp_user:$ftp_pwd@$ftp_ip \u0026laquo;EOF cd Backup put ./$tar_file_name bye EOF\n二、配置定时任务 [root@server]# systemctl status crond #查看计划任务服务是否正常运行\n[root@server]# crontab -e #编辑定时任务 0 1 * * * /bin/bash /task/backup.sh # 每天1点整执行备份脚本\n","permalink":"https://water711.github.io/posts/2020-01-04-linux%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E4%B8%8A%E4%BC%A0ftp%E6%9C%8D%E5%8A%A1%E5%99%A8/","tags":null,"title":"Linux定时备份数据库并上传FTP服务器"},{"categories":["other"],"contents":"域服务器：192.168.1.130\nRemote App服务器：192.168.1.130\n服务器操作系统：Windows Server 2012 R2\n一、搭建域环境 1、安装域服务（添加角色和功能-\u0026gt;勾选 Active Directory域服务器）\n2、安装完成后，点击“将此服务器提升为域控制器”\n3、添加新林\n4、输入目录服务还原密码（需要满足密码复杂度要求）\n5、提示无法创建DNS委派，忽略，下一步\n6、默认，下一步\n7、指定AD DS数据库、日志和SYSVOL存放路径\n8、点击安装\n二、安装远程桌面服务 1、添加角色和功能-\u0026gt;勾选“远程桌面服务安装”\n2、选择快速启动（正式环境会选择标准部署，将RD连接代理、RDWeb访问以及RD会话主机部署在不同服务器上）\n3、选择基于会话的桌面部署\n4、钩选 允许自动重新服务器，点击部署\n远程桌面服务安装完成后，默认有120天的试用时间\n三、为Remote App添加程序 1、点击“远程桌面服务”\n2、点击QuickSessionCollection-\u0026gt;任务-\u0026gt;发布RemoteApp程序\n3、勾选你要发布到RemoteApp的程序\n四、远程访问RemoteApp的程序 1、客户端机器修改hosts文件，将域控制器的根域名、和FQDN完全限定域名（主机名+域名）和解析到域服务器/RemoteApp服务器IP地址\n#win7 hosts文件路径 C:\\Windows\\System32\\drivers\\etc\\hosts 192.168.1.130 test.com 192.168.1.130 WIN-71CA1NGO1FG.test.com\n2、客户端机器使用浏览器访问 https://192.168.1.130/RDWeb，输入域用户和密码\n3、登录后，点击需要使用的应用，输入域用户和密码\n启动服务器程序成功\n","permalink":"https://water711.github.io/posts/2020-01-03-%E5%BE%AE%E8%BD%AFremote-app%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%99%9A%E6%8B%9F%E5%8C%96/","tags":null,"title":"微软Remote App实现应用程序虚拟化"},{"categories":["python"],"contents":" 一、准备环境 1、安装Oracle 客户端（python、oracle客户端的位数要一致）\n2、安装Python第三方模块\npip3 install cx_Oracle xlsxwriter\n**cx_Oracle模块：**一个允许访问Oracle数据库并符合Python数据库API规范的模块。该模块目前针对Oracle客户端19c、18c、12c和11.2以及Python2.7、3.5、3.6、3.7和3.8进行了测试。\n**xlsxwriter模块：**编写Excel 2007+XLSX文件格式文件，可用于将文本、数字和公式写入多个工作表，并支持格式、图像、图表、页面设置、自动筛选、条件格式和许多其他功能。\n二、编写代码 # -*- coding: utf-8 -*-\nimport time import smtplib import cx_Oracle import xlsxwriter from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart from email.mime.application import MIMEApplication\ndef send_mail(): from_addr = \u0026ldquo;12345678@qq.com\u0026rdquo; #发件人 pwd = \u0026ldquo;zjjeiuwpaynojhgsdf\u0026rdquo; #授权码/密码 to_addr = \u0026ldquo;87654321@qq.com\u0026rdquo; #收件人\nmsg = MIMEMultipart() #实例化对象 msg\\[\u0026quot;Subject\u0026quot;\\] = \u0026quot;销售报表\u0026quot; #主题 msg\\[\u0026quot;From\u0026quot;\\] = from\\_addr msg\\[\u0026quot;To\u0026quot;\\] = to\\_addr part1 = MIMEText(\u0026quot;这里是邮件内容\u0026quot;) msg.attach(part1) # 添加附件 part2 = MIMEApplication(open(date + \u0026quot;.xlsx\u0026quot;, 'rb').read()) part2.add\\_header('Content-Disposition', 'attachment', filename=date + \u0026quot;.xlsx\u0026quot;) msg.attach(part2) # 连接smtp服务器，登录服务器并发送文本 smtp\\_server = \u0026quot;smtp.qq.com\u0026quot; server = smtplib.SMTP(smtp\\_server,25) server.login(from\\_addr,pwd) server.sendmail(from\\_addr,to\\_addr,msg.as\\_string()) # as\\_string（）把MIMEText变成一个str server.close() def write_xls(ret): workbook = xlsxwriter.Workbook(date + \u0026lsquo;.xlsx\u0026rsquo;) format_1 = workbook.add_format({\u0026lsquo;bold\u0026rsquo;: True, \u0026lsquo;font_size\u0026rsquo;: 16, \u0026lsquo;align\u0026rsquo;: \u0026lsquo;center\u0026rsquo;}) #添加样式1，格式为加粗、字体16号、居中 format_2 = workbook.add_format({\u0026lsquo;font_size\u0026rsquo;: 14, \u0026lsquo;align\u0026rsquo;: \u0026lsquo;center\u0026rsquo;}) #添加样式2，字体14号、居中 format_3 = workbook.add_format({\u0026lsquo;font_size\u0026rsquo;: 14, \u0026lsquo;align\u0026rsquo;: \u0026lsquo;center\u0026rsquo;, \u0026rsquo;num_format\u0026rsquo;: \u0026lsquo;yyyy-mm-dd hh:mm:ss\u0026rsquo;}) #添加样式3，字体14号、居中、格式化为时间日期\nworksheet = workbook.add\\_worksheet(\u0026quot;sheet1\u0026quot;) #添加工作表 worksheet.set\\_column('A:B', 30) #将A到B列的宽度设为30 worksheet.set\\_column('C:D', 40) #将C到D列的宽度设为40 #写入标题行 write(单元格，内容，样式) worksheet.write('A1', '会员手机号',format\\_1) worksheet.write('B1','商品名称',format\\_1) worksheet.write('C1','商品单价',format\\_1) worksheet.write('D1','购买时间',format\\_1) row = 1 #从第2行开始写入 col = 0 #从第1列开始写入 for record in ret: for s in record: #如果循环到第4列，将内容设置成样式3（日期格式） if col == 3: worksheet.write(row, col, s, format\\_3) continue #将内容写入到第row行，第col列,格式为样式2 worksheet.write(row, col, s, format\\_2) col+=1 row += 1 #行数加1 col = 0 #列数归0 workbook.close() date = time.strftime(\u0026rsquo;%Y-%m-%d\u0026rsquo;,time.localtime()) #获取当前日期，用于文件命名\nusername=\u0026ldquo;test\u0026rdquo; userpwd=\u0026ldquo;123456\u0026rdquo; host=\u0026ldquo;172.16.1.1\u0026rdquo; port=1521 dbname=\u0026ldquo;WEB\u0026rdquo;\ndsn=cx_Oracle.makedsn(host, port, dbname) connection=cx_Oracle.connect(username, userpwd, dsn, encoding = \u0026ldquo;UTF-8\u0026rdquo;, nencoding = \u0026ldquo;UTF-8\u0026rdquo;) cursor=connection.cursor()\nsql=\u0026lsquo;select * from sale\u0026rsquo; cursor.execute(sql)\nresult=cursor.fetchall() count=cursor.rowcount\nprint(\u0026ldquo;共查询到\u0026rdquo;, count, \u0026ldquo;记录\u0026rdquo;) print(\u0026quot;=====================\u0026quot;)\n#打印出查询结果 for row in result: print(row)\ncursor.close() connection.close()\nwrite_xls(result) #将查询结果写入Excel文件 send_mail() #发送邮件\n三、可能遇到的问题 A、运行报错 cx_Oracle.DatabaseError: DPI-1047: Cannot locate a 64-bit Oracle Client library:\nTraceback (most recent call last): File \u0026ldquo;C:\\Users\\Administrator\\Desktop\\movic_report.py\u0026rdquo;, line 78, in connection=cx_Oracle.connect(username, userpwd, dsn\u0026quot;) cx_Oracle.DatabaseError: DPI-1047: Cannot locate a 64-bit Oracle Client library: \u0026ldquo;The specified module could not be found\u0026rdquo;.\n原因：\n1、oracle客户端和python 位数不一致\n2、oracle客户端的bin目录没有加入系统环境变量中，导致找不到oracle相关库文件\n解决方法：\n1、安装相同位数的oracle客户端和python（同为32位或64位）\n2、将oracle客户端的bin目录加入到环境变量（或者 将 oci.dll，oraocci11.dll和oraociei11.dll库文件拷贝到python目录下lib-\u0026gt;site-packages里面）\nB、查询结果包含中文，报下面编码错误\nTraceback (most recent call last): File \u0026ldquo;E:\\oracle.py\u0026rdquo;, line 33, in cursor.execute(sql) UnicodeEncodeError: \u0026lsquo;ascii\u0026rsquo; codec can\u0026rsquo;t encode characters in position 35-39: ordinal not in range(128)\n解决方法：\n查看系统编码： import sys\nprint(sys.getdefaultencoding()) #输出utf8\n查看oracle数据库编码： select userenv(\u0026rsquo;language\u0026rsquo;) from dual; #结果为CHINESE_CHINA.AL32UTF8\n方法一： 手机设置系统环境变量NLS_LANG的值： windows下：右键计算机属性-\u0026gt;高级系统设置-\u0026gt;高级-\u0026gt;环境变量-\u0026gt;在系统变量下新建变量名：NLS_LANG，值为CHINESE_CHINA.AL32UTF8 Linux下：在/etc/profile文件末尾增加一行，export NLS_LANG=CHINESE_CHINA.AL32UTF8\n方法二： conn = cx_Oracle.connect(connectString, encoding = \u0026ldquo;UTF-8\u0026rdquo;, nencoding = \u0026ldquo;UTF-8\u0026rdquo;)\nC、查询的sql语句中，如果别名使用单引号，会报错，提示未找到要求的 FROM 关键字，但是where语句中，条件的值又只能使用单引号，不然会报错，提示 标识符无效\nsql = “SELECT USERID AS \u0026lsquo;列名\u0026rsquo; FROM EB_LOG WHERE USERID = \u0026lsquo;admin\u0026rsquo; ” #别名使用单引号，报错\nTraceback (most recent call last): File \u0026ldquo;E:\\oracle.py\u0026rdquo;, line 34, in cursor.execute(sql) cx_Oracle.DatabaseError: ORA-00923: 未找到要求的 FROM 关键字\nsql = \u0026lsquo;SELECT USERID AS \u0026ldquo;列名\u0026rdquo; FROM EB_LOG WHERE USERID = \u0026ldquo;admin\u0026rdquo;\u0026rsquo; #where条件的值使用双引号，报错\nTraceback (most recent call last): File \u0026ldquo;E:\\oracle.py\u0026rdquo;, line 33, in cursor.execute(sql) cx_Oracle.DatabaseError: ORA-00904: \u0026ldquo;U\u0026rdquo;: 标识符无效\n解决方法：\n#sql语句整体使用单引号，别名使用双引号，where条件的值使用单引号，并用反斜杠转义 sql = \u0026lsquo;SELECT EB_USERID AS \u0026ldquo;列名\u0026rdquo; from EB_LOG WHERE EB_USERID = \\\u0026lsquo;admin\\\u0026rsquo; '\n","permalink":"https://water711.github.io/posts/2020-01-02-pthon3%E5%AE%9E%E7%8E%B0oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%AF%BC%E5%87%BAexcel%E5%B9%B6%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/","tags":null,"title":"pthon3实现oracle数据库查询、导出EXCEL并邮件发送"},{"categories":["other"],"contents":"场景：通过windows计划任务，执行数据库备份脚本（批处理文件），每天定时备份数据库 问题：手动执行备份脚本，数据库是备份到脚本所在目录，但是通过计划任务执行脚本，数据库备份到了C:\\Windows\\System32目录下 解决方法： 在计划任务执行程序或脚本下面，超始于（可选）选项中，指定程序所在目录\n","permalink":"https://water711.github.io/posts/2020-01-02-windows%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%90%8E%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8D%E5%9C%A8%E7%A8%8B%E5%BA%8F%E6%89%80/","tags":null,"title":"windows计划任务，执行程序后，生成的文件不在程序所在目录"},{"categories":["other"],"contents":" 一、下载并安装Oracle Database 官网地址：https://www.oracle.com/technetwork/cn/database/enterprise-edition/downloads/index.html\n1、下载解压后，右键setup.exe，以管理员身份运行\n2、电子邮件可不填\n3、这里跳过软件更新\n4、我这里选择仅安装数据库软件（安装后再手动配置数据库），也可以选第一项在安装时创建数据库\n5、选择 单实例数据库安装\n6、选择语言\n7、我这里选择标准版\n8、输入安装目录\n9、执行安装\n10、安装完成\n二、创建数据库 1、在D盘下创建oradata和orats目录\n2、进行D:\\app\\Administrator\\product\\11.2.0\\dbhome_1\\BIN\\目录，右键以管理员身份运行dbca.bat\n3、默认选择“创建数据库”\n4、默认选择“一般用途或事务处理”\n5、输入数据库名和SID\n6、取消勾选“配置Enterprise Manager”，下一步\n7、输入管理口令\n8、选择数据库文件存放位置\n9、取消勾选“指定快速恢复区”\n10、默认不勾选“示例方案”，下一步\n11、指定分配给该数据库的内存大小\n12、调整最大连接进程数\n13、选择Unicode字符集\n14、修改日志大小和日志成员\n15、点击完成\n16、核对概要信息后，点击确定，开始创建\n三、配置Oracle Net Services 1、进行D:\\app\\Administrator\\product\\11.2.0\\dbhome_1\\BIN\\目录，右键以管理员身份运行netca.bat\n2、默认选择”监听程序配置“\n3、监听程序名，默认即可\n4、网络协议，默认TCP\n5、监听的端口号，默认1521\n6、是否配置另一个监听程序，选择“否”\n7、完成配置\n8、查看监听程序状态\nC:\\Users\\Administrator\u0026gt;lsnrctl status\n正在连接到 (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=WIN-71CA1NGO1FG)(PORT=1521))) LISTENER 的 STATUS 别名 LISTENER 版本 TNSLSNR for 64-bit Windows: Version 11.2.0.4.0 - Production 启动日期 30-12月-2019 21:41:23 正常运行时间 0 天 0 小时 59 分 1 秒 跟踪级别 off 安全性 ON: Local OS Authentication SNMP OFF 监听程序参数文件 D:\\app\\Administrator\\product\\11.2.0\\dbhome_1\\network\\admin\\listener.ora 监听程序日志文件 D:\\app\\Administrator\\diag\\tnslsnr\\WIN-71CA1NGO1FG\\listener\\alert\\log.xml 监听端点概要\u0026hellip; (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=WIN-71CA1NGO1FG)(PORT=1521))) (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(PIPENAME=\\\\.\\pipe\\EXTPROC1521ipc))) 服务摘要.. 服务 \u0026ldquo;CLRExtProc\u0026rdquo; 包含 1 个实例。 实例 \u0026ldquo;CLRExtProc\u0026rdquo;, 状态 UNKNOWN, 包含此服务的 1 个处理程序\u0026hellip; 服务 \u0026ldquo;WEBBS61XDB\u0026rdquo; 包含 1 个实例。 实例 \u0026ldquo;webbs61\u0026rdquo;, 状态 READY, 包含此服务的 1 个处理程序\u0026hellip; 服务 \u0026ldquo;webbs61\u0026rdquo; 包含 1 个实例。 实例 \u0026ldquo;webbs61\u0026rdquo;, 状态 READY, 包含此服务的 1 个处理程序\u0026hellip; 命令执行成功\n四、创建表空间 1、使用oracle sys管理员登陆（以操作系统权限认证）\nC:\\Users\\Administrator\u0026gt;sqlplus / as sysdba\nSQL*Plus: Release 11.2.0.4.0 Production on 星期一 12月 30 21:14:07 2019\nCopyright (c) 1982, 2013, Oracle. All rights reserved.\n连接到: Oracle Database 11g Release 11.2.0.4.0 - 64bit Production\nSQL\u0026gt;\n2、创建表空间\n#创建表空间 SQL\u0026gt; CREATE TABLESPACE \u0026ldquo;DATA01\u0026rdquo; 2 LOGGING 3 DATAFILE \u0026lsquo;D:\\orats\\DATA01_1.dbf\u0026rsquo; SIZE 5120M AUTOEXTEND ON NEXT 8192K MAXSIZE UNLIMITED, 4 \u0026lsquo;D:\\orats\\DATA01_2.dbf\u0026rsquo; SIZE 5120M AUTOEXTEND ON NEXT 8192K MAXSIZE UNLIMITED 5 EXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO;\n表空间已创建。\nSQL\u0026gt; CREATE TABLESPACE \u0026ldquo;INDEX01\u0026rdquo; 2 LOGGING 3 DATAFILE \u0026lsquo;D:\\orats\\INDEX01_1.dbf\u0026rsquo; SIZE 5120M AUTOEXTEND ON NEXT 8192K MAXSIZE UNLIMITED, 4 \u0026lsquo;D:\\orats\\INDEX01_2.dbf\u0026rsquo; SIZE 5120M AUTOEXTEND ON NEXT 8192K MAXSIZE UNLIMITED 5 EXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO;\n3、修改密码有效期\n#将密码有效期修改成“无限制” SQL\u0026gt; ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;\n配置文件已更改\n##提交上面的DML命令 SQL\u0026gt; COMMIT;\n提交完成。\n五、创建用户及授权 C:\\Users\\Administrator\u0026gt;sqlplus / as sysdba\n#创建数据库用户 SQL\u0026gt;create user 用户名 identified by 密码 default tablespace data01 temporary tablespace temp quota 0 on system quota unlimited on data01 quota unlimited on index01;\n用户已创建。\nSQL\u0026gt; Grant CONNECT,RESOURCE,dba TO 用户名; #授权用户connect、resource和dba权限\n授权成功。\nSQL\u0026gt; COMMIT;\n提交完成。\n六、备份Oracle数据库 #使用exp备份，owner为导出该用户所有者的权限和数据 D:\\backup\u0026gt;exp 用户名/密码@127.0.0.1/数据库名 owner=用户名 file=backup.dmp log=backup.log\n#下面为输出信息 Export: Release 11.2.0.4.0 - Production on 星期二 12月 31 09:45:46 2019\nCopyright (c) 1982, 2011, Oracle and/or its affiliates. All rights reserved.\n连接到: Oracle Database 11g Release 11.2.0.4.0 - 64bit Production 已导出 ZHS16GBK 字符集和 AL16UTF16 NCHAR 字符集 服务器使用 AL32UTF8 字符集 (可能的字符集转换)\n即将导出指定的用户\u0026hellip; . 正在导出 pre-schema 过程对象和操作 . 正在导出用户 WEBBS61 的外部函数库名 . 导出 PUBLIC 类型同义词 . 正在导出专用类型同义词 . 正在导出用户 WEBBS61 的对象类型定义 即将导出 WEBBS61 的对象\u0026hellip; . 正在导出数据库链接 . 正在导出序号 . 正在导出簇定义 . 即将导出 WEBBS61 的表通过常规路径\u0026hellip; . 正在导出同义词 . 正在导出视图 . 正在导出存储过程 . 正在导出运算符 . 正在导出引用完整性约束条件 . 正在导出触发器 . 正在导出索引类型 . 正在导出位图, 功能性索引和可扩展索引 . 正在导出后期表活动 . 正在导出实体化视图 . 正在导出快照日志 . 正在导出作业队列 . 正在导出刷新组和子组 . 正在导出维 . 正在导出 post-schema 过程对象和操作 . 正在导出统计信息 成功终止导出, 没有出现警告。\n七、恢复数据 D:\\backup\u0026gt;Imp 用户名/密码@127.0.0.1/数据库名 file=D:\\backup.DMP log=D:\\backup.LOG FROMUSER=用户名 grants=N ROWS=y commit=y\n#输出信息 连接到: Oracle Database 11g Release 11.2.0.4.0 - 64bit Production\n经由常规路径由 EXPORT:V11.02.00 创建的导出文件 已经完成 ZHS16GBK 字符集和 AL16UTF16 NCHAR 字符集中的导入 导入服务器使用 AL32UTF8 字符集 (可能的字符集转换) . 正在将 WEBBS61 的对象导入到 WEBBS61 . . 正在导入表 \u0026ldquo;XF_test1\u0026quot;导入了 5 行 . . 正在导入表 \u0026ldquo;XF_test2\u0026quot;导入了 10 行 成功终止导入, 没有出现警告。\n六、安装ORACLE客户端 官网下载地址：https://www.oracle.com/technetwork/cn/database/enterprise-edition/downloads/index.html\n1、下载解压后，右键setup.exe，以管理员身份运行\n2、选择管理员\n3、跳过软件更新\n4、选择语言\n5、指定安装位置\n6、安装\n7、数据库连接测试\nC:\\Users\\Administrator\u0026gt;sqlplus 用户名/密码@IP地址:端口/数据库名 as sysdba\nSQL*Plus: Release 11.2.0.4.0 Production on 星期二 12月 31 17:57:41 2019\n连接到: Oracle Database 11g Release 11.2.0.4.0 - 64bit Production\nSQL\u0026gt; show user; USER 为 \u0026ldquo;SYS\u0026rdquo; SQL\u0026gt;\n","permalink":"https://water711.github.io/posts/2019-12-31-oracle%E5%AE%89%E8%A3%85%E6%8E%88%E6%9D%83%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/","tags":null,"title":"oracle安装、授权、备份和恢复"},{"categories":["linux"],"contents":"需要搭建的服务： DHCP 服务器：配置为需要对 PXE 客户端请求进行响应的 DHCP 服务器或 DHCP 代理。 PXE 服务器：运行 TFTP 服务的服务器，可托管客户端将下载的 Windows PE 启动文件。 文件服务器：托管网络文件共享的服务器。\n（实际环境中，可以把上述服务部署在一台服务器上）\n一、配置DHCP服务 [root@PXE ~]# yum -y install dhcp\n[root@PXE ~]# vim /etc/dhcp/dhcpd.conf subnet 192.168.142.0 netmask 255.255.255.0 { range 192.168.142.100 192.168.142.200; next-server 192.168.142.241; #tftp-server 本机IP filename \u0026ldquo;pxelinux.0\u0026rdquo;; #指向的是ttp-server的根目录/var/lib/ftpboot\n[root@PXE ~]# dhcpd #检测语法 [root@PXE ~]# systemctl restart dhcpd [root@PXE ~]# systemctl enable dhcpd\n客户端机器从网卡启动测试：\n二、配置TFTP服务 [root@PXE ~]# yum -y install tftp-server [root@PXE ~]# yum -y install syslinux #操作系统的引导加载程序\n[root@PXE ~]# mount /dev/cdrom /mnt/ （插入centos7系统光盘并挂载） [root@PXE ~]# mkdir /var/lib/tftpboot/centos7 [root@PXE ~]# cp /mnt/images/pxeboot/initrd.img /var/lib/tftpboot/centos7/ #拷贝系统镜像里的initrd.img到tftp [root@PXE ~]# cp /mnt/images/pxeboot/vmlinuz /var/lib/tftpboot/centos7/ #拷贝系统镜像里的vmlinuz到tftp [root@PXE ~]# cp /usr/share/syslinux/menu.c32 /var/lib/tftpboot/ [root@PXE ~]# cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/\n#配置网络引导菜单 [root@PXE ~]# mkdir /var/lib/tftpboot/pxelinux.cfg/ [root@PXE ~]# vim /var/lib/tftpboot/pxelinux.cfg/default default menu.c32 prompt 0 timeout 300 ONTIMEOUT local\nmenu title ########## PXE Boot Menu ##########\nlabel 1 menu label ^1) Install CentOS 7 x64 with FTP kernel centos7/vmlinuz append initrd=centos7/initrd.img inst.stage2=ftp://192.168.142.241/centos7 inst.repo=ftp://192.168.142.241/centos7 #在xinetd守护进程服务中，开启tftp [root@PXE ~]# vim /etc/xinetd.d/tftp disable=no\n[root@PXE ~]# systemctl enable xinetd [root@PXE ~]# systemctl start xinetd [root@PXE ~]# ss -lanp | grep :69 #查看tftp端口是否有监听\n客户端机器从网卡启动测试：\n从DHCP服务器获取IP，并得到next -server IP地址，访问tftp服务器获取引导程序\n回车后加载vmlinuz（Linux 内核）和initrd.img（initial ramdisk映像） ，类似加载windows的PE微型系统\n因为还没有配置FTP服务，所以获取系统镜像文件失败\n三、配置FTP服务 [root@PXE ~]# yum -y install vsftpd [root@PXE ~]# mkdir /var/ftp/centos7 [root@PXE ~]# mount /dev/cdrom /var/ftp/centos7 #插入系统光盘并挂载安装源（也可直接复制光盘文件） [root@PXE ~]# systemctl start vsftpd [root@PXE ~]# systemctl enable vsftpd\n客户端机器从网卡启动测试：\n从DHCP服务器获取IP，并得到next -server IP地址，访问tftp服务器获取引导程序，加载vmlinuz和initrd.img，从FTP获取系统镜像文件\n自此，PXE服务端环境部署完成，客户端可通过网络加载系统映像并安装Centos7操作系统\n下面开始配置网络引导安装windows系统\n四、创建 Windows PE 映像 1、下载安装Windows 自动安装工具包 (AIK)\nhttps://www.microsoft.com/zh-cn/download/details.aspx?id=10333\n2、开始菜单-\u0026gt;程序-\u0026gt;Microsoft Windows AIK，以管理员身份运行“部署工具命令提示符”\n3、使用下面命令生成Window7_X64预安装环境（WinPE）网络引导映像（注意修改AIK程序路径）\ncopype amd64 C:\\winPE_amd64 copy \u0026ldquo;D:\\Program Files\\Windows AIK\\Tools\\PETools\\amd64\\winpe.wim\u0026rdquo; C:\\winpe_amd64\\ISO\\Sources\\Boot.wim copy \u0026ldquo;D:\\Program Files\\Windows AIK\\Tools\\amd64\\Imagex.exe\u0026rdquo; C:\\winpe_amd64\\ISO\\ oscdimg -n -bC:\\winpe_amd64\\etfsboot.com C:\\winpe_amd64\\ISO C:\\winpe_amd64\\winpe_amd64.iso\n4、将生成的C:\\winpe_amd64\\winpe_amd64.iso 镜像拷贝到PXE服务器/var/lib/tftpboot/win7x64/\n五、网络引导菜单加入windows选项 [root@PXE ~]# cp /usr/share/syslinux/memdisk /var/lib/tftpboot/win7x64/ #拷贝memdisk内核到tftp目录\n[root@PXE ~]# vim /var/lib/tftpboot/pxelinux.cfg/default label 2 menu label ^2) Install Windows 7 x64 KERNEL win7x64/memdisk #memdisk内核可以引导软盘映像、硬盘映像和一些ISO映像 INITRD win7x64/winpe_amd64.iso #PE映像 APPEND iso raw 六、拷贝windows系统镜像文件 [root@PXE ~]# mkdir /var/ftp/win7x64 [root@PXE ~]# mount /dev/cdrom /mnt/ #插入win7系统光盘并挂载 [root@PXE ~]# cp /mnt/ /var/ftp/win7x64 #拷贝光盘文件到ftp目录 [root@PXE ~]# yum -y install samba [root@PXE ~]# vim /etc/samba/smb.conf [global] map to guest = bad user [win7x64] path = /var/ftp/win7x64 guest ok = yes\n七、客户端从PXE启动PE并安装win7 启动PE系统后，映射共享文件夹，运行setup.exe执行系统安装\nnet user z: \\\\192.168.142.241\\win7x64 #映射共享文件到Z盘 z:setup.exe #执行安装程序\n","permalink":"https://water711.github.io/posts/2019-12-26-%E4%BD%BF%E7%94%A8pxe%E7%BD%91%E7%BB%9C%E5%BC%95%E5%AF%BC%E5%AE%89%E8%A3%85linux%E5%92%8Cwindows%E7%B3%BB%E7%BB%9F/","tags":null,"title":"使用PXE网络引导安装Linux和windows系统"},{"categories":["linux"],"contents":"博客原本部署在阿里云虚拟主机上，今年双11，购买了一台阿里云ECS服务器，现在开始做迁移\n一、备份网站空间及数据库 二、阿里云ECS部署LNMP环境 #安装nginx和mariadb [root@ecs]# yum -y install nginx mariadb mariadb-server [root@ecs]# systemctl start nginx mariadb [root@ecs]# systemctl enable nginx mariadb\n#EPEL源的php版本较低，安装第三方源 [root@ecs]# rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm [root@ecs]# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm\n[root@ecs]# yum -y install php56w php56w-fpm php56w-mysql php56w-gd [root@ecs]# systemctl start php-fpm [root@ecs]# systemctl enable php-fpm\n#把nginx主配置文件的server段注释掉 [root@ecs]# vim /etc/nginx/nginx.conf\nserver { listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } \u0026hellip;\u0026hellip;. } } #配置nginx虚拟主机 [root@ecs]# vim /etc/nginx/conf.d/caizhenwei.conf\nupstream php { server unix:/tmp/php-cgi.socket; server 127.0.0.1:9000; }\nserver { server_name caizhenwei.top; root /usr/share/nginx/wordpress; index index.php;\nlocation / { try\\_files $uri $uri/ /index.php?$args; #wordpress伪静态 } location ~ \\\\.php$ { #NOTE: You should have \u0026quot;cgi.fix\\_pathinfo = 0;\u0026quot; in php.ini include fastcgi.conf; fastcgi\\_intercept\\_errors on; fastcgi\\_pass php; } location ~\\* \\\\.(js|css|png|jpg|jpeg|gif|ico)$ { expires max; log\\_not\\_found off; } }\n三、导入网站及数据库 #导入网站 [root@ecs]# unzip -d /usr/share/nginx/wordpress web_bakcup.zip #解压备份好的网站，到指定目录 [root@ecs]# chown -R nginx:nginx /usr/share/nginx/wordpress #修改网站目录属主和属组\n#修改php-fpm运行的用户和组（因为使用这个源安装的php，默认是以apache用户运行的，如果不修改为nginx用户，会因为权限问题无法上传文件） [root@ecs]# vim /etc/php-fpm.d/www.conf\nuser = nginx group = nginx\n#导入数据库 [root@ecs]# mysql -uroot -p MariaDB [(none)]\u0026gt; CREATE DATABASE `wordpress` DEFAULT CHARACTER SET utf8; #创建数据库 MariaDB [(none)]\u0026gt; use wordpress MariaDB [(none)]\u0026gt; source /tmp/backup.sql #导入数据库\nMariaDB [(none)]\u0026gt; grant all on wordpress.* to \u0026lsquo;user\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; identified by \u0026lsquo;123456\u0026rsquo;; #授权数据库用户 MariaDB [(none)]\u0026gt; flush privileges; #刷新授权表\n四、修改wordpress配置文件 [root@ecs]# vim wordpress/wp-config.php\n/** WordPress数据库的名称 */ define(\u0026lsquo;DB_NAME\u0026rsquo;, \u0026lsquo;wordpress\u0026rsquo;);\n/** MySQL数据库用户名 */ define(\u0026lsquo;DB_USER\u0026rsquo;, \u0026lsquo;user\u0026rsquo;);\n/** MySQL数据库密码 */ define(\u0026lsquo;DB_PASSWORD\u0026rsquo;, \u0026lsquo;123456\u0026rsquo;);\n五、将域名解析到新服务器IP地址，至此，wordpress迁移完成 六、升级wordpress最新版 由于近段时间，国内无法正常访问wordpress官网，所以不能通过wordpress后台更新，只能手动下载wordpress更新\n步骤：\n1、备份网站，下载最新版wordpress\n2、删除网站根目录下的wp-includes和wp-admin文件夹\n3、解压最新版的WordPress，删除里面的wp-content文件夹，把新版wordpress上传并覆盖到网站目录\n[root@ecs]# wget https://wordpress.org/wordpress-5.3.1-zh_CN.zip [root@ecs]# unzip wordpress-5.3.1-zh_CN.zip #解压 [root@ecs]# rm -rf ./wordpress-5.3.1/wp-content/ #解压后删除里面的wp-content目录\n[root@ecs]# cd /usr/share/nginx/wordpress/ #进入网站目录 [root@ecs]# rm -rf ./wordpress/wp-includes/ ./wordpress/wp-admin/ #删除网站wp-includes、wp-admin目录 [root@ecs]# /bin/cp -rf /root/wordpress/* /usr/share/nginx/wordpress/ #把新版wordpress上传并覆盖到博客网站目录\n浏览器访问：http://域名/wp-admin/upgrade.php\n七、搭建FTP服务，用于方便上传或下载网站文件 #安装并配置ftp [root@ecs]# yum -y install vsftpd [root@ecs]# vim /etc/vsftpd/vsftpd.conf anonymous_enable=NO #关闭匿名访问 chroot_local_user=YES #限制用户只能访问为其配置的目录（用户主目录不能再有写权限）\n[root@ecs]# vim /etc/pam.d/vsftpd #auth required pam_shells.so #将这行注释，不检查用户shell的有效性\n#新建用户，并把网站目录设为用户家目录 [root@ecs]# mkdir -p /webdata/wordpress/htdocs/ #创建目录 [root@ecs]# useradd -s /sbin/nologin -d /webdata/wordpress/ ftpuser #创建用户并指定其家目录 [root@ecs]# passwd ftpuser #设置ftp用户密码\n#将网站文件移动到FTP用户家目录下的htdocs [root@ecs]# mv ./wordpress/* /webdata/wordpress/htdocs/ #移动网站 [root@ecs]# vim /etc/nginx/conf.d/caizhenwei.conf #修改nginx配置文件的网站根目录\n#修改网站目录属主和个别目录写权限 [root@ecs]# chown -R ftpuser:ftpuser /webdata/wordpress/ #修改ftp用户家目录属主 [root@ecs]# chown a-w /webdata/wordpress/ #从2.3.5之后，vsftpd增强了安全检查，如果用户被限定在了其主目录下，则该用户的主目录不能再具有写权限 [root@ecs]# chmod -R 777 /webdata/wordpress/htdocs/wp-content/uploads/ #修改上传目录写权限 [root@ecs]# chmod -R 777 /webdata/wordpress/htdocs/wp-content/themes/yusi1.0/cache/ #修改缩略图缓存目录写权限\n#启动vsftpd服务 [root@ecs]# systemctl restart vsftpd.service [root@ecs]# systemctl enable vsftpd.service\n","permalink":"https://water711.github.io/posts/2019-12-21-wordpress%E7%BD%91%E7%AB%99%E8%BF%81%E7%A7%BB/","tags":null,"title":"Wordpress网站迁移"},{"categories":["python"],"contents":"Python代码： # -*- coding:utf-8 -*-\nimport threading import subprocess import time from queue import Queue import xlrd import msvcrt\n定义工作线程 WORD_THREAD = 50\n将从excel表中读取ip并加入队列 IP_QUEUE = Queue() workbook = xlrd.open_workbook(\u0026ldquo;IP.xls\u0026rdquo;) table = workbook.sheets()[0]\nfor row in range(1, table.nrows): ip = table.cell(row, 0).value name = table.cell(row, 1).value IP_QUEUE.put([ip,name])\n定义一个执行 ping 的函数 def ping_ip(): while not IP_QUEUE.empty(): ip = IP_QUEUE.get() res = subprocess.call(\u0026lsquo;ping -n 2 -w 5 %s\u0026rsquo; % ip[0],stdout=subprocess.PIPE) # linux 系统将 \u0026lsquo;-n\u0026rsquo; 替换成 \u0026lsquo;-c\u0026rsquo; # 打印运行结果 # print(ip[0],True if res == 0 else False) if res == 0: print(ip[0],ip[1],\u0026ldquo;有响应\u0026rdquo;) else: print(ip[0],ip[1],\u0026ldquo;无响应\u0026rdquo;) ip.append(\u0026ldquo;不通\u0026rdquo;) result.append(ip)\nif __name__ == \u0026lsquo;__main__\u0026rsquo;: print(\u0026ldquo;从文件读取\u0026rdquo;,table.nrows-1,\u0026ldquo;个IP地址\u0026rdquo;)\nthreads = \\[\\] result = \\[\\] start\\_time = time.time() for i in range(WORD\\_THREAD): thread = threading.Thread(target=ping\\_ip) thread.start() threads.append(thread) for thread in threads: thread.join() print(\u0026quot;--------------------------------------\u0026quot;) print(\u0026quot;-------检测结果(只显示fail设备)--------\u0026quot;) print(\u0026quot;--------------------------------------\u0026quot;) if len(result) != 0: for i in result: print(i) print('\\\\n') print('程序运行耗时：%s' % (time.time() - start\\_time),'秒') while True: if ord(msvcrt.getch()) in \\[113, 81\\]: #按键盘q退出循环 break excel文件模板： ","permalink":"https://water711.github.io/posts/2019-11-25-python-%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96ip%E5%9C%B0%E5%9D%80-%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%AB%E6%8F%8F/","tags":null,"title":"python 从文件读取IP地址 并实现多线程扫描"},{"categories":["python"],"contents":"python27版本，使用pip安装包，报错 Could not install packages due to an EnvironmentError: [Errno 0]\n重装python后，并将pip更新到最新版本，还是报错\n弄了一晚上，结果发现是之前修改了cmd命令行窗口的默认编码，导致安装包失败\nC:\\Users\\admin\u0026gt;pip install opencv-python\nDEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python n\u0026rsquo;t be maintained after that date. A future version of pip will drop support for Python 2.7. More detail support in pip, can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-sup Collecting opencv-python WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connecti adTimeoutError(\u0026ldquo;HTTPSConnectionPool(host=\u0026lsquo;files.pythonhosted.org\u0026rsquo;, port=443): Read timed out. (read time ckages/d7/7e/3aa5d122bd446252bf4d1e39f1ac8a945e46d6572bf241fc503da963d92c/opencv_python-4.1.1.26-cp27-cp l Downloading https://files.pythonhosted.org/packages/d7/7e/3aa5d122bd446252bf4d1e39f1ac8a945e46d6572bf2 /opencv_python-4.1.1.26-cp27-cp27m-win_amd64.whl (39.0MB) |ERROR: Could not install packages due to an EnvironmentError: [Errno 0] Error\n解决方法： 将命令行窗口编码修改为GBK，命令行下输入 chcp 936\n","permalink":"https://water711.github.io/posts/2019-11-04-windows%E4%B8%8B%E4%BD%BF%E7%94%A8pip%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%B1%E8%B4%A5%E6%8F%90%E7%A4%BAcould-not-install-packages-due-to-an-environmenterror-errno-0-error/","tags":null,"title":"windows下使用pip安装包失败，提示Could not install packages due to an EnvironmentError: [Errno 0] Error"},{"categories":["other"],"contents":" 一、安装OpenCV 打开OpenCV官网，下载对应系统的opencv，并解压到任意位置\n解压./opencv/build/java目录下有以下文件\n二、Eclipse加载OpenCV库 官方配置文档：https://docs.opencv.org/2.4/doc/tutorials/introduction/java_eclipse/java_eclipse.html\n1、启动eclipse并从菜单中选择 Window –\u0026gt; Preferences\n在左边导航窗口选择 Java –\u0026gt; Build Path –\u0026gt; User Libraries，点击New，并为你的library输入一个名称，例如：OpenCV-4.1.1\n2、选中新建的user libraries，点击 Add External JARs\u0026hellip;\n选择opencv的jar包\n3、选中 Native library location，点击Edit\n4、选择对应opencv库文件所在文件夹，32位系统选择X86，64位系统选择X64\n现在已经配置好opencv了，下面新建一个java项目，测试一下opencv是否能正常使用\n三、新建项目测试OpenCV Eclipse新建项目后，右键项目，点击 Build Path–\u0026gt;Add Libraries\u0026hellip;\n选择User Library\n勾选opencv\n创建一个新的Java文件，使用以下代码运行测试：\nimport org.opencv.core.Core; import org.opencv.core.CvType; import org.opencv.core.Mat;\npublic class opencvTest { public static void main( String[] args ) { System.loadLibrary( Core.NATIVE_LIBRARY_NAME ); Mat mat = Mat.eye( 3, 3, CvType.CV_8UC1 ); System.out.println( \u0026ldquo;mat = \u0026quot; + mat.dump() ); } }\n运行结果\nmat = [ 1, 0, 0; 0, 1, 0; 0, 0, 1]\n四、打开摄像头，按原分辨率显示 使用RTSP流媒体打开摄像头\nimport org.opencv.core.Mat; import org.opencv.core.Core; import org.opencv.highgui.HighGui; import org.opencv.videoio.VideoCapture;\npublic class opencvTest {\nstatic { System.loadLibrary(Core.NATIVE\\_LIBRARY\\_NAME); } public static void main(String\\[\\] args) { System.load(\u0026quot;D:/Program Files/opencv/build/bin/opencv\\_videoio\\_ffmpeg411\\_64.dll\u0026quot;); //加载opencv\\_ffmpeg400\\_64.dll，要不然是无法解码 VideoCapture cap = new VideoCapture(\u0026quot;rtsp://192.168.104.130/user=admin\u0026amp;password=admin\u0026amp;channel=1\u0026quot;); while(cap.isOpened()){ boolean flag; Mat image = new Mat(); flag = cap.read(image); if(!flag){ System.out.println(\u0026quot;--- not able to get image ---\u0026quot;); break; } HighGui.imshow(\u0026quot;video\u0026quot;, image); HighGui.waitKey(10); } System.out.println(\u0026quot;--- video capture closed ---\u0026quot;); } }\n五、打开摄像头，显示在固定大小的窗口 import org.opencv.core.Mat; import org.opencv.core.Core; import org.opencv.videoio.VideoCapture; import org.opencv.core.Size; import org.opencv.highgui.HighGui; import org.opencv.imgproc.Imgproc;\npublic class opencvTest {\nstatic { System.loadLibrary(Core.NATIVE\\_LIBRARY\\_NAME); } public static void main(String\\[\\] args) { System.load(\u0026quot;D:/Program Files/opencv/build/bin/opencv\\_videoio\\_ffmpeg411\\_64.dll\u0026quot;); //加载opencv\\_ffmpeg400\\_64.dll，要不然是无法解码 VideoCapture vc = new VideoCapture(); boolean isOpen = vc.open(\u0026quot;rtsp://192.168.104.130/user=admin\u0026amp;password=admin\u0026amp;channel=1\u0026quot;); System.out.println(\u0026quot;isOpen=\u0026quot;+isOpen); Mat mat = new Mat(); String winName = \u0026quot;showFrame\u0026quot;; //窗口名称 int height = 600,width = 800; //定义窗口宽和高 HighGui.namedWindow(winName); HighGui.resizeWindow(winName, width, height); while(vc.read(mat)){\tMat dst = new Mat(); Imgproc.resize(mat, dst, new Size(width,height)); // 重置窗口大小 HighGui.imshow(winName, dst); //显示窗口 int key = HighGui.waitKey(1); // 调用waitkey方法，否则无法显示 } HighGui.destroyAllWindows(); vc.release(); } }\n六、打开摄像头并截取一帧画面 import org.opencv.core.Mat; import org.opencv.core.Core; import org.opencv.imgcodecs.Imgcodecs; import org.opencv.videoio.VideoCapture;\npublic class opencvTest {\nstatic { System.loadLibrary(Core.NATIVE\\_LIBRARY\\_NAME); } public static void main(String\\[\\] args) { System.load(\u0026quot;D:/Program Files/opencv/build/bin/opencv\\_videoio\\_ffmpeg411\\_64.dll\u0026quot;); //加载opencv\\_ffmpeg400\\_64.dll，要不然是无法解码 VideoCapture vc = new VideoCapture(); String rtsp = \u0026quot;rtsp://192.168.104.160/user=admin\u0026amp;password=admin\u0026amp;channel=15.0\u0026quot;; VideoCapture camera = new VideoCapture(rtsp); Mat mat = new Mat(); camera.read(mat); String filename = \u0026quot;test.png\u0026quot;; Imgcodecs.imwrite(filename, mat); //保存画面到当前项目目录下 camera.release(); } }\n七、判断摄像头是否黑屏 import org.opencv.core.Mat; import java.io.File; import org.opencv.core.Core; import org.opencv.imgcodecs.Imgcodecs; import org.opencv.videoio.VideoCapture;\npublic class opencvTest {\nstatic { System.loadLibrary(Core.NATIVE\\_LIBRARY\\_NAME); } private static void read\\_camera() { VideoCapture camera = new VideoCapture(\u0026quot;rtsp://192.168.104.130/user=admin\u0026amp;password=admin123\u0026amp;channel=1\u0026quot;); Mat mat = new Mat(); camera.read(mat); String filename = \u0026quot;test.png\u0026quot;; Imgcodecs.imwrite(filename, mat); camera.release(); } public static void main(String\\[\\] args) { System.load(\u0026quot;D:/Users/Administrator/Desktop/opencv/build/bin/opencv\\_videoio\\_ffmpeg411\\_64.dll\u0026quot;); File file = new File(\u0026quot;test.png\u0026quot;); opencvTest.read\\_camera(); //获取摄像头画面，并保存为test.png //如果文件大小不超过60000字节（60Kb），则判断摄像头黑屏 if (file.length() \u0026gt; 60000) { System.out.println(\u0026quot;摄像头正常\u0026quot;); }else { System.out.println(\u0026quot;摄像头黑屏\u0026quot;); } } }\n","permalink":"https://water711.github.io/posts/2019-10-29-java%E4%BD%BF%E7%94%A8opencv%E9%80%9A%E8%BF%87rtsp%E6%B5%81%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4/","tags":null,"title":"JAVA使用opencv通过RTSP流打开摄像头"},{"categories":["other"],"contents":"一、什么是jar包 jar包就是别人已经写好的一些类，然后将这些类进行打包，你可以将这些jar包引入你的项目中，然后就可以直接使用这些jar包中的类和属性以及方法。\n二、如何下载jar包 包所在的官网下载 百度或谷歌，搜索包名 第三方jar包仓库下载（例如：https://mvnrepository.com/） 三、Eclipse如何使用jar包 1、在项目下，新建lib目录，把jar包拷贝到该目录\n2、选择项目，右键点击jar包 -\u0026gt; Build Path -\u0026gt; Add to Build Path\n","permalink":"https://water711.github.io/posts/2019-10-24-eclipse%E4%B8%AD%E4%BD%BF%E7%94%A8jar%E5%8C%85/","tags":null,"title":"Eclipse中使用jar包"},{"categories":["linux"],"contents":"一、查看系统时区/时间 #方法一： [root@server1 ~]# timedatectl Local time: Tue 2019-09-17 05:14:47 CST Universal time: Mon 2019-09-16 21:14:47 UTC //世界协调时间 RTC time: Sun 2019-10-13 06:17:36 //BIOS硬件时钟(Real Time Clock） Time zone: Asia/Shanghai (CST, +0800) //时区 NTP enabled: n/a //是否启用NTP服务 NTP synchronized: no //NTP时间是否已同步 RTC in local TZ: no //BIOS硬件时间是否与系统时间同步 DST active: n/a\n#方法二： [root@server1 ~]# date Sun Oct 13 14:40:33 CST 2019\n二、设置系统时区 [root@server1 ~]# timedatectl set-timezone Asia/Shanghai //设置时区为上海东8区\n[root@server1 ~]# timedatectl list-timezones //列出所有时区\n三、设置系统时间 #方法一： [root@server1 ~]# timedatectl set-time \u0026ldquo;2019-10-13 14:32:35\u0026rdquo;\n#方法二： [root@server1 ~]# date -s \u0026ldquo;2019-10-13 14:32:35\u0026rdquo;\n四、将硬件时间同步为系统时间 #方法一： [root@server1 ~]# timedatectl set-local-rtc 1\n[root@server1 ~]# timedatectl Local time: Sun 2019-10-13 14:34:32 CST Universal time: Sun 2019-10-13 06:34:32 UTC RTC time: Sun 2019-10-13 14:34:32 Time zone: Asia/Shanghai (CST, +0800) NTP enabled: n/a NTP synchronized: no RTC in local TZ: yes //同步后，该项已打开为YES DST active: n/a\n#方法二： [root@server1 ~]# hwclock -w\n五、使用NTP同步时间 [root@server1 ~]# timedatectl set-ntp 1 #开启NTP Failed to set ntp: NTP not supported.\n[root@server1 ~]# yum -y install ntp #如果像上面提示NTP not supported，先安装NTP\n[root@server1 ~]# vim /etc/ntp.conf server ntp.aliyun.com #server 1.centos.pool.ntp.org iburst #server 2.centos.pool.ntp.org iburst #server 3.centos.pool.ntp.org iburst\n[root@server1 ~]# systemctl start ntpd 相当于 timedatectl set-ntp 1 [root@server1 ~]# systemctl enable ntpdate\n","permalink":"https://water711.github.io/posts/2019-10-13-centos7%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4-%E6%97%B6%E5%8C%BA/","tags":null,"title":"Centos7设置系统时间/时区"},{"categories":["python"],"contents":"源代码 import cv2,os\nurl = \u0026lsquo;rtsp://192.168.104.130/user=admin\u0026amp;password=admin\u0026amp;channel=1\u0026rsquo; cap = cv2.VideoCapture(url) ret, frame = cap.read() cv2.imwrite(\u0026ldquo;E:/test.png\u0026rdquo;, frame) cap.release() cv2.destroyAllWindows()\n在使用PyInstaller打包上面python程序后，执行exe程序出现以下错误，获取的frame为0字节\nlibpng warning:Image width is zero in IHDR libpng warning:Image height is zero in IHDR libpng error:Invalid IHDR data\n解决方法： 进入Python37\\Lib\\site-packages\\cv2 目录下，把后缀名为dll的文件拷贝到exe程序目录下\n","permalink":"https://water711.github.io/posts/2019-10-06-pyinstaller%E6%89%93%E5%8C%85python%E7%A8%8B%E5%BA%8F%E5%90%8Ecv2-videocapture%E8%8E%B7%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4%E7%94%BB%E7%94%BB%E5%A4%B1%E8%B4%A5/","tags":null,"title":"PyInstaller打包python程序后，cv2.VideoCapture()获取摄像头画画失败"},{"categories":["python"],"contents":"在Windows下，我们可以使用内建的msvcrt库，实现按任意键继续或退出\n一、获取按键对应的ASCII 值 import msvcrt print(ord(msvcrt.getch()))\nsvcrt 中的 getch() 方法，作用是获取一个按键响应并返回对应的字符。\nord 将获得的字符转换为 ASCII 数值，例如捕获按键“q”将得到数值113，按键“Q”将得到数值81\n二、利用while死循环，当msvcrt捕获到指定的按键，中断循环 import msvcrt\nprint(\u0026ldquo;Press \u0026lsquo;q\u0026rsquo; to exit\u0026hellip;\u0026rdquo;)\nwhile True: if ord(msvcrt.getch()) in [81, 113]: break\nLinux下实现方式请查看以下文章：\nhttps://www.jb51.net/article/90845.htm\n","permalink":"https://water711.github.io/posts/2019-10-06-python%E5%AE%9E%E7%8E%B0%E6%8C%89%E4%BB%BB%E6%84%8F%E9%94%AE%E7%BB%A7%E7%BB%AD%E6%88%96%E9%80%80%E5%87%BA/","tags":null,"title":"Python3实现按任意键继续或退出"},{"categories":["linux","zabbix"],"contents":"一、安装配置snmptrapd [root@zabbix1 ~]# yum install -y net-snmp net-snmp-utils net-snmp-perl [root@zabbix1 ~]# vim /etc/snmp/snmptrapd.conf authCommunity log,execute,net public #设置团体名 traphandle default /usr/sbin/snmptthandler #设置snmptt为trap接收器，此时还没安装snmptt\n[root@zabbix1 ~]# systemctl start snmptrapd [root@zabbix1 ~]# systemctl enable snmptrapd\n#防火墙开放snmp trap端口 [root@zabbix1 ~]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-port=162/udp [root@zabbix1 ~]# firewall-cmd \u0026ndash;reload\n#测试 设备打开snmptrap，设置接收主机IP和团体名,手动触发告警,查看是否接收到告警信息 [root@zabbix1 ~]# tail -F /var/log/messages\n二、更改snmptrapd日志路径 snmptrapd接收到的log默认会到/var/log/messages里面，但如果snmptrapd设备较多，会产生大量日志，会干扰我们平时查看系统日志信息，所以我们要把snmptrapd的日志信息单独存放\n-L：日志选项。支持的输出方式有标准错误（e），标准输出（o），文件（f），syslog（s）。\n-Ls：输出到系统日志文件\n-Lf：输出到指定文件\n#新建日志文件存放目录 [root@zabbix1 ~]# mkdir /var/log/snmptrap/\n#修改systemd服务文件 [root@zabbix1 ~]# vim /usr/lib/systemd/system/snmptrapd.service\n[Service] Type=notify #Environment=OPTIONS=\u0026quot;-Lsd\u0026quot; #注释该行 EnvironmentFile=-/etc/sysconfig/snmptrapd #ExecStart=/usr/sbin/snmptrapd $OPTIONS -f\nExecStart=/usr/sbin/snmptrapd -Lf /var/log/snmptrap/snmptrap.log -f #指定snmptrapd日志存放位置 ExecReload=/bin/kill -HUP $MAINPID\n[root@zabbix1 ~]# systemctl daemon-reload #修改systemd文件后，要重新加载 [root@zabbix1 ~]# systemctl restart snmptrapd.service\n三、安装配置snmptt [root@zabbix1 ~]# yum -y install epel-release [root@zabbix1 ~]# yum -y install perl-Sys-Syslog snmptt //snmptt需要Perl Syslog module支持\n[root@zabbix1 ~]# vim /etc/snmp/snmptt.ini date_time_format= %Y/%m/%d %H:%M:%S net_snmp_perl_enable = 1 translate_log_trap_oid = 2 （0：显示数字OID，1：显示OID名称，2：显示OID所属模块名及其名称） log_file = /var/log/snmptt/snmptt.log（默认即可）\n自定义trap格式化规则\n[root@zabbix1 ~]# cp /etc/snmp/snmptt.conf{ , .bak} #备份配置文件 [root@zabbix1 ~]# vim /etc/snmp/snmptt.conf EVENT Linkdown .1.3.6.1.6.3.1.1.5.3 \u0026ldquo;Status Events\u0026rdquo; Warning FORMAT ZBXTRAP $aA LinkDown on interface $4. Admin state: $2. Operational state: $3\nEVENT Linkup .1.3.6.1.6.3.1.1.5.4 \u0026ldquo;Status Events\u0026rdquo; Normal FORMAT ZBXTRAP $aA Linkup on interface $4. Admin state: $2. Operational state: $3\nEVENT general .* \u0026ldquo;General event\u0026rdquo; Unknown FORMAT ZBXTRAP $aA $1\n[root@zabbix1 ~]# systemctl restart snmptt [root@zabbix1 ~]# tail -F /var/log/snmptt/snmptt.log\n四、Zabbix上配置SNMP监控 [root@zabbix1 ~]# vim /etc/zabbix/zabbix_server.conf StartSNMPTrapper=1 #Zabbix开启SNMPTrapper SNMPTrapperFile=/var/log/snmptt/snmptt.log #修改SNMPTrapper文件路径\n[root@zabbix1 ~]# systemctl restart zabbix-server\n添加一台主机\n添加一个ITEM，匹配包含关键字“LinkDown”的SNMP trap日志信息（Key格式为SNMPTrap[regexp]）\n添加另一个ITEM，所有未被SNMPTrap[regexp]匹配到的，都匹配到该ITEM\n五、使用Zabbix自带模板，监控华为交换机 新建主机，并设置主机SNMP团体名（添加一个宏，{$SNMP_COMMUNITY} -\u0026gt; public）\n为主机添加一个模板\n添加模板后自动生成相关ITEM\n","permalink":"https://water711.github.io/posts/2019-10-05-zabbix_%E9%85%8D%E7%BD%AEsnmptrap/","tags":null,"title":"Zabbix_配置snmptrap监控交换机"},{"categories":["linux","zabbix"],"contents":"一、安装配置snmptrapd [root@zabbix1 ~]# yum install -y net-snmp net-snmp-utils net-snmp-perl [root@zabbix1 ~]# vim /etc/snmp/snmptrapd.conf authCommunity log,execute,net public #设置团体名 traphandle default /usr/sbin/snmptthandler #设置snmptt为trap接收器，此时还没安装snmptt\n[root@zabbix1 ~]# systemctl start snmptrapd [root@zabbix1 ~]# systemctl enable snmptrapd\n#防火墙开放snmp trap端口 [root@zabbix1 ~]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-port=162/udp [root@zabbix1 ~]# firewall-cmd \u0026ndash;reload\n#测试 设备打开snmptrap，设置接收主机IP和团体名,手动触发告警,查看是否接收到告警信息 [root@zabbix1 ~]# tail -F /var/log/messages\n二、更改snmptrapd日志路径 snmptrapd接收到的log默认会到/var/log/messages里面，但如果snmptrapd设备较多，会产生大量日志，会干扰我们平时查看系统日志信息，所以我们要把snmptrapd的日志信息单独存放\n-L：日志选项。支持的输出方式有标准错误（e），标准输出（o），文件（f），syslog（s）。\n-Ls：输出到系统日志文件\n-Lf：输出到指定文件\n#新建日志文件存放目录 [root@zabbix1 ~]# mkdir /var/log/snmptrap/\n#修改systemd服务文件 [root@zabbix1 ~]# vim /usr/lib/systemd/system/snmptrapd.service\n[Service] Type=notify #Environment=OPTIONS=\u0026quot;-Lsd\u0026quot; #注释该行 EnvironmentFile=-/etc/sysconfig/snmptrapd #ExecStart=/usr/sbin/snmptrapd $OPTIONS -f\nExecStart=/usr/sbin/snmptrapd -Lf /var/log/snmptrap/snmptrap.log -f #指定snmptrapd日志存放位置 ExecReload=/bin/kill -HUP $MAINPID\n[root@zabbix1 ~]# systemctl daemon-reload #修改systemd文件后，要重新加载 [root@zabbix1 ~]# systemctl restart snmptrapd.service\n三、安装配置snmptt [root@zabbix1 ~]# yum -y install epel-release [root@zabbix1 ~]# yum -y install perl-Sys-Syslog snmptt //snmptt需要Perl Syslog module支持\n[root@zabbix1 ~]# vim /etc/snmp/snmptt.ini date_time_format= %Y/%m/%d %H:%M:%S net_snmp_perl_enable = 1 translate_log_trap_oid = 2 （0：显示数字OID，1：显示OID名称，2：显示OID所属模块名及其名称） log_file = /var/log/snmptt/snmptt.log（默认即可）\n自定义trap格式化规则\n[root@zabbix1 ~]# cp /etc/snmp/snmptt.conf{ , .bak} #备份配置文件 [root@zabbix1 ~]# vim /etc/snmp/snmptt.conf EVENT Linkdown .1.3.6.1.6.3.1.1.5.3 \u0026ldquo;Status Events\u0026rdquo; Warning FORMAT ZBXTRAP $aA LinkDown on interface $4. Admin state: $2. Operational state: $3\nEVENT Linkup .1.3.6.1.6.3.1.1.5.4 \u0026ldquo;Status Events\u0026rdquo; Normal FORMAT ZBXTRAP $aA Linkup on interface $4. Admin state: $2. Operational state: $3\nEVENT general .* \u0026ldquo;General event\u0026rdquo; Unknown FORMAT ZBXTRAP $aA $1\n[root@zabbix1 ~]# systemctl restart snmptt [root@zabbix1 ~]# tail -F /var/log/snmptt/snmptt.log\n四、Zabbix上配置SNMP监控 [root@zabbix1 ~]# vim /etc/zabbix/zabbix_server.conf StartSNMPTrapper=1 #Zabbix开启SNMPTrapper SNMPTrapperFile=/var/log/snmptt/snmptt.log #修改SNMPTrapper文件路径\n[root@zabbix1 ~]# systemctl restart zabbix-server\n添加一台主机\n添加一个ITEM，匹配包含关键字“LinkDown”的SNMP trap日志信息（Key格式为SNMPTrap[regexp]）\n添加另一个ITEM，所有未被SNMPTrap[regexp]匹配到的，都匹配到该ITEM\n五、使用Zabbix自带模板，监控华为交换机 新建主机，并设置主机SNMP团体名（添加一个宏，{$SNMP_COMMUNITY} -\u0026gt; public）\n为主机添加一个模板\n添加模板后自动生成相关ITEM\n","permalink":"https://water711.github.io/posts/2019-10-05-zabbix_%E9%85%8D%E7%BD%AEsnmptrapnull/","tags":null,"title":"Zabbix_配置snmptrap监控交换机"},{"categories":["linux"],"contents":"Usage: tcpdump [-aAbdDefhHIJKlLnNOpqStuUvxX#] [ -B size ] [ -c count ] [ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ] [ -i interface ] [ -j tstamptype ] [ -M secret ] [ \u0026ndash;number ] [ -Q|-P in|out|inout ] [ -r file ] [ -s snaplen ] [ \u0026ndash;time-stamp-precision precision ] [ \u0026ndash;immediate-mode ] [ -T type ] [ \u0026ndash;version ] [ -V file ] [ -w file ] [ -W filecount ] [ -y datalinktype ] [ -z postrotate-command ] [ -Z user ] [ expression ]\ntcpdump常用参数 -i 指定监听的网络接口； -c 指定抓包数量，抓到数量后停止 -w 抓包时直接写入文件，不显示出来 -n 将主机名转换成IP显示 -nn 将主机名转换成IP、服务名转换成端口号显示 -v 输出比较详细的信息\n使用案例 #过滤主机 tcpdump -i eth1 host 192.168.1.1 tcpdump -i eth1 src host 192.168.1.1 tcpdump -i eth1 dst host 192.168.1.1\n#过滤端口 tcpdump -i eth1 port 25 tcpdump -i eth1 src port 25 tcpdump -i eth1 dst port 25\n#过滤协议 tcpdump -i eth1 arp tcpdump -i eth1 ip tcpdump -i eth1 tcp tcpdump -i eth1 udp tcpdump -i eth1 icmp\n未完待续。。。\n","permalink":"https://water711.github.io/posts/2019-10-01-tcpdump%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/","tags":null,"title":"tcpdump常用参数及使用案例"},{"categories":["other"],"contents":"在主题的functions.php文件最后面添加以下代码 //编辑器增加字体格式和字体大小按钮 function add_editor_buttons($buttons) { $buttons[] = \u0026lsquo;fontselect\u0026rsquo;; $buttons[] = \u0026lsquo;fontsizeselect\u0026rsquo;; return $buttons; } add_filter(\u0026ldquo;mce_buttons_2\u0026rdquo;, \u0026ldquo;add_editor_buttons\u0026rdquo;);\n//自定义字体格式 function custum_fontfamily($initArray){ $initArray[\u0026lsquo;font_formats\u0026rsquo;] = \u0026ldquo;微软雅黑=\u0026lsquo;微软雅黑\u0026rsquo;;宋体=\u0026lsquo;宋体\u0026rsquo;;黑体=\u0026lsquo;黑体\u0026rsquo;;仿宋=\u0026lsquo;仿宋\u0026rsquo;;楷体=\u0026lsquo;楷体\u0026rsquo;;隶书=\u0026lsquo;隶书\u0026rsquo;;幼圆=\u0026lsquo;幼圆\u0026rsquo;;Arial=\u0026lsquo;Arial\u0026rsquo;;\u0026rdquo;; return $initArray; } add_filter(\u0026rsquo;tiny_mce_before_init\u0026rsquo;, \u0026lsquo;custum_fontfamily\u0026rsquo;);\n编辑器其它功能按钮 剪切（cut） 复制（copy） 粘贴（paste） 撤销（undo） 重做（redo） 居中（justifycenter） 加粗（bold） 斜体（italic） 左对齐（justifyleft） 右对齐（justfyright） 两端对齐（justfyfull） 插入超链接（link） 取消超链接（unlink） 插入图片（image） 清除格式（removeformat） 下划线（underline） 删除线（strikethrough） 锚文本（anchor） 新建文本（newdocument） 字体颜色（forecolor） 字体背景色（backcolor） 格式选择（formmatselect） 字体选择（fontselect） 字号选择（fontsizeselect） 样式选择（styleselect） 无序列表（bullist） 编号列表（numlist） 减少缩进（outdent） 缩进（indent） 帮助（wp_help） 打开HTML代码编辑器（code） 水平线（hr） 清除冗余代码（cleanup） 上标（sub） 下标（sup） 特殊符号（charmap） 插入more标签（wp_more） 插入分页标签（wp_page） 隐藏按钮显示开关（wp_adv） 隐藏按钮区起始部分（wp_adv_start） 隐藏按钮区结束部分（wp_adv_end） 拼写检查（spellchecker）\n//编辑器增加按钮方法：在主题的functions.php文件最后面添加以下代码（如果已有add_editor_buttons函数，直接在函数体内增加按钮） function add_editor_buttons($buttons) { $buttons[] = \u0026lsquo;fontselect\u0026rsquo;; //增加字体按钮 $buttons[] = \u0026lsquo;bold\u0026rsquo;; //增加加粗按钮 return $buttons; } add_filter(\u0026ldquo;mce_buttons_2\u0026rdquo;, \u0026ldquo;add_editor_buttons\u0026rdquo;); //mce_buttons_2表示在编辑器第二行增加按钮\n","permalink":"https://water711.github.io/posts/2019-10-01-wordpress%E7%BC%96%E8%BE%91%E5%99%A8%E6%A0%8F%E5%A2%9E%E5%8A%A0%E5%AD%97%E4%BD%93%E5%92%8C%E5%A4%A7%E5%B0%8F/","tags":["wordpress"],"title":"WordPress编辑器栏增加字体和大小"},{"categories":["linux","zabbix"],"contents":"环境： zabbix1：192.168.1.241（Master）\nzabbix2：192.168.1.242（Slave）\nzabbix：192.168.1.240（虚拟IP）\n配置hosts文件 [root@Zabbix1 ~]# vim /etc/hosts 192.168.1.241 zabbix1 192.168.1.242 zabbix2 192.168.1.240 zabbix\n一、安装Zabbix #安装Zabbix仓库 [root@Zabbix1 ~]# rpm -Uvh https://repo.zabbix.com/zabbix/4.2/rhel/7/x86_64/zabbix-release-4.2-2.el7.noarch.rpm [root@Zabbix1 ~]# yum clean all\n#安装Zabbix server，Web前端，agent，数据库 [root@Zabbix1 ~]# yum -y install zabbix-server-mysql zabbix-web-mysql zabbix-agent mariadb mariadb-server\n#初始化并创建数据库 [root@Zabbix1 ~]# systemctl enable mariadb [root@Zabbix1 ~]# systemctl start mariadb [root@Zabbix1 ~]# mysql_secure_installation [root@Zabbix1 ~]# mysql -uroot -p MariaDB [(none)]\u0026gt; create database zabbix character set utf8 collate utf8_bin; MariaDB [(none)]\u0026gt; grant all privileges on zabbix.* to zabbix@localhost identified by \u0026lsquo;password\u0026rsquo;; MariaDB [(none)]\u0026gt; grant all privileges on zabbix.* to zabbix@192.168.1.240 identified by \u0026lsquo;password\u0026rsquo;; MariaDB [(none)]\u0026gt; quit;\n#导入初始架构和数据到zabbix数据库（这步zabbix2不用操作） [root@Zabbix1 ~]# zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix\n#配置Zabbix server [root@Zabbix1 ~]# sed -i \u0026lsquo;/# DBPassword=/cDBPassword=password\u0026rsquo; /etc/zabbix/zabbix_server.conf #指定数据库密码\n#配置前端PHP时区 [root@Zabbix1 ~]# sed -ri \u0026lsquo;/.*?php_value date/c\\php_value date.timezone Asia/Shanghai\u0026rsquo; /etc/httpd/conf.d/zabbix.conf //设置时区为上海\n#关闭Selinux和配置防火墙 [root@Zabbix1 ~]# setenforce 0 //临时关闭Selinux [root@Zabbix1 ~]# sed -i /^SELINUX=/cSELINUX=disabled /etc/selinux/config //永久关闭Selinux [root@Zabbix1 ~]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-service=http [root@Zabbix1 ~]# firewall-cmd \u0026ndash;reload\n#启动Zabbix相关服务 [root@Zabbix1 ~]# systemctl restart zabbix-server zabbix-agent httpd [root@Zabbix1 ~]# systemctl enable zabbix-server zabbix-agent httpd\n二、部署keepalived #两台机器安装keepalived [root@Zabbix1 ~]# yum -y install keepalived\n[root@Zabbix1 ~]# vim /etc/keepalived/keepalived.conf ! Configuration File for keepalived\nglobal_defs { router_id zabbix1 }\nvrrp_script zabbix_chk { script \u0026ldquo;/etc/keepalived/zabbix_check.sh\u0026rdquo; interval 5 }\nvrrp_instance VI_1 { state MASTER interface eth0 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.1.240 } track_script { zabbix_chk } notify_master \u0026ldquo;/etc/keepalived/zabbix.sh start\u0026rdquo; #指定当切换到master时，启动zabbix-server notify_backup \u0026ldquo;/etc/keepalived/zabbix.sh stop\u0026rdquo; #指定当切换到backup时，停止zabbix-server(防止两台机器同时运行zabbix-server,导致主从同步失败) notify_fault \u0026ldquo;/etc/keepalived/zabbix.sh stop\u0026rdquo; #当前节点出现故障,停止zabbix-server }\n[root@Zabbix2 ~]# vim /etc/keepalived/keepalived.conf ! Configuration File for keepalived\nglobal_defs { router_id zabbix2 }\nvrrp_instance VI_1 { state BACKUP interface eth0 virtual_router_id 51 priority 50 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.1.240 }\nnotify_master \u0026ldquo;/etc/keepalived/zabbix.sh start\u0026rdquo; #指定当切换到master时，启动zabbix-server notify_backup \u0026ldquo;/etc/keepalived/zabbix.sh stop\u0026rdquo; #指定当切换到backup时，停止zabbix-server notify_fault \u0026ldquo;/etc/keepalived/zabbix.sh stop\u0026rdquo; #当前节点出现故障,停止zabbix-server }\n服务状态检测脚本（只配置在zabbix1上）\n[root@Zabbix1 ~]# vim /etc/keepalived/zabbix_check.sh #!/bin/bash\nzabbix_server_status1=$(ps -C zabbix_server \u0026ndash;no-heading|wc -l)\nif [ \u0026ldquo;${zabbix_server_status1}\u0026rdquo; = \u0026ldquo;0\u0026rdquo; ]; then systemctl restart zabbix_server.service sleep 2\nzabbix_server_status2=$(ps -C zabbix_server \u0026ndash;no-heading|wc -l) if [ \u0026ldquo;${zabbix_server_status2}\u0026rdquo; = \u0026ldquo;0\u0026rdquo; ]; then exit 1 fi fi\nmariadb_status1=$(ps -C mysqld \u0026ndash;no-heading|wc -l)\nif [ \u0026ldquo;${mariadb_status1}\u0026rdquo; = \u0026ldquo;0\u0026rdquo; ]; then systemctl restart mariadb.service sleep 2\nmariadb_status2=$(ps -C mysqld \u0026ndash;no-heading|wc -l) if [ \u0026ldquo;${mariadb_status2}\u0026rdquo; = \u0026ldquo;0\u0026rdquo; ]; then exit 1 fi fi\nhttpd_status1=$(ps -C httpd \u0026ndash;no-heading|wc -l)\nif [ \u0026ldquo;${httpd_status1}\u0026rdquo; = \u0026ldquo;0\u0026rdquo; ]; then systemctl restart httpd.service sleep 2\nhttpd_status2=$(ps -C httpd \u0026ndash;no-heading|wc -l) if [ \u0026ldquo;${httpd_status2}\u0026rdquo; = \u0026ldquo;0\u0026rdquo; ]; then exit 1 fi fi\n[root@Zabbix1 ~]# chmod +x /etc/keepalived/zabbix_check.sh\nnotify脚本\n[root@Zabbix1 ]# vim /etc/keepalived/zabbix.sh #!/bin/bash case \u0026ldquo;$1\u0026rdquo; in start) systemctl start zabbix-server ;; stop) systemctl stop zabbix-server ;; esac\n[root@Zabbix1 ]# chmod +x /etc/keepalived/zabbix.sh\n防火墙配置允许VRRP组播\n[root@Zabbix1 ~]# firewall-cmd \u0026ndash;direct \u0026ndash;permanent \u0026ndash;add-rule ipv4 filter INPUT 0 \u0026ndash;in-interface eth0 \u0026ndash;destination 224.0.0.18 \u0026ndash;protocol vrrp -j ACCEPT [root@Zabbix1 ~]# firewall-cmd \u0026ndash;reload\n[root@Zabbix1 ~]# systemctl restart keepalived.service\n[root@Zabbix1 ~]# systemctl enable keepalived.service\n三、配置mariadb数据库主主同步 防火墙开放数据库端口\n[root@Zabbix1 ~]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-port=3306/tcp [root@Zabbix1 ~]# firewall-cmd \u0026ndash;reload\nzabbix1上操作 #备份原有配置 [root@Zabbix1 ~]# cp /etc/my.cnf{,.bak}\n#编辑zabbix1的my.cnf文件 [root@Zabbix1 ~]# vim /etc/my.cnf [mysqld] datadir=/var/lib/mysql socket=/var/lib/mysql/mysql.sock symbolic-links=0\nserver-id=241 #保证每个服务器不一样，这里以IP最后一位来区分 log-bin=mysql-bin #开启bin日志 auto-increment-increment = 2 #步进值auto_imcrement。一般有n台主MySQL就填n auto-increment-offset = 1 #起始值。一般填第n台主MySQL。此时为第一台主MySQL binlog_format = mixed #设置binlog格式为mixed sync_binlog=1 #事务特性每1次事务提交 binlog-do-db=zabbix #同步的据库名 binlog-ignore-db=mysql #不同步数据库名 binlog-ignore-db=sys binlog-ignore-db=performance_schema binlog-ignore-db=information_schema replicate-do-db=zabbix #需要复制的数据库\nreplicate-ignore-db=mysql #不需要复制的数据库 replicate-ignore-db=sys replicate-ignore-db=performance_schema replicate-ignore-db=information_schema\n[mysqld_safe] log-error=/var/log/mariadb/mariadb.log pid-file=/var/run/mariadb/mariadb.pid\n#重启mariadb [root@Zabbix1 ~]# systemctl restart mariadb.service\n#登录MariaDB控制台，授权同步用户，用于zabbix2上同步数据 [root@Zabbix1 ~]# mysql -uroot -p MariaDB [(none)]\u0026gt; GRANT REPLICATION SLAVE ON *.* TO \u0026lsquo;zabbix242\u0026rsquo;@\u0026lsquo;192.168.1.242\u0026rsquo; IDENTIFIED BY \u0026lsquo;zabbix242\u0026rsquo;; MariaDB [(none)]\u0026gt; FLUSH PRIVILEGES; MariaDB [(none)]\u0026gt; exit\n#备份zabbix库 [root@Zabbix1 ~]# mysqldump -uroot -p zabbix \u0026ndash;single-transaction \u0026ndash;master-data=1 \u0026ndash;flush-logs \u0026gt; zabbix.sql\n#把备份文件拷贝到zabbix2机器上 [root@Zabbix1 ~]# scp zabbix.sql zabbix2:/root/\nzabbix2上操作 #备份原有配置 [root@Zabbix2 ~]# cp /etc/my.cnf{,.bak}\n#编辑zabbix2的my.cnf文件 [root@Zabbix2 ~]# vim /etc/my.cnf [mysqld] datadir=/var/lib/mysql socket=/var/lib/mysql/mysql.sock symbolic-links=0 server-id=242 #保证每个服务器不一样 log-bin=mysql-bin #开启bin日志 auto-increment-increment = 2 #步进值auto_imcrement。一般有n台主MySQL就填n auto-increment-offset = 2 #起始值。一般填第n台主MySQL。此时为第一台主MySQL binlog_format = mixed #设置binlog格式为mixed sync_binlog=1 #事务特性每1次事务提交 binlog-do-db=zabbix #同步的据库名 binlog-ignore-db=mysql #不同步数据库名 binlog-ignore-db=sys binlog-ignore-db=performance_schema binlog-ignore-db=information_schema replicate-do-db=zabbix #需要复制的数据库\nreplicate-ignore-db=mysql #不需要复制的数据库 replicate-ignore-db=sys replicate-ignore-db=performance_schema replicate-ignore-db=information_schema\n[mysqld_safe] log-error=/var/log/mariadb/mariadb.log pid-file=/var/run/mariadb/mariadb.pid\n#重启mariadb [root@Zabbix2 ~]# systemctl restart mariadb.service\n#登录MariaDB控制台 [root@Zabbix2 ~]# mysql -uroot -p\n#指定Master信息 MariaDB [(none)]\u0026gt; CHANGE MASTER TO MASTER_HOST=\u0026lsquo;192.168.1.241\u0026rsquo;, MASTER_USER=\u0026lsquo;zabbix242\u0026rsquo;, MASTER_PASSWORD=\u0026lsquo;zabbix242\u0026rsquo;;\n#导入zabbix1备份的数据库 MariaDB [(none)]\u0026gt; use zabbix MariaDB [zabbix]\u0026gt; set sql_log_bin=0; #临时关闭二进制日志 MariaDB [zabbix]\u0026gt; source /root/zabbix.sql\n#启动SLAVE MariaDB [zabbix]\u0026gt; START SLAVE;\n#检查主从复制是否配置成功（Slave_IO_Running和Slave_SQL_Running是否为YES） MariaDB [zabbix]\u0026gt; SHOW SLAVE STATUS\\G;\n接下来配置zabbix2到zabbix1 主从配置（即可实现主主同步）\nzabbix2上操作 #授权用户，用于zabbix1上同步数据 MariaDB [zabbix]\u0026gt; GRANT REPLICATION SLAVE ON *.* TO \u0026lsquo;zabbix241\u0026rsquo;@\u0026lsquo;192.168.1.241\u0026rsquo; IDENTIFIED BY \u0026lsquo;zabbix241\u0026rsquo;; MariaDB [(none)]\u0026gt; FLUSH PRIVILEGES;\n#显示master状态，记录一下File和Position的值 MariaDB [zabbix]\u0026gt; show master status; +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | mysql-bin.000001 | 1743933 | zabbix | mysql,sys,performance_schema,information_schema | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\nzabbix1上操作 #配置主从同步（zabbix2主，zabbix1从） MariaDB [(none)]\u0026gt; CHANGE MASTER TO MASTER_HOST=\u0026lsquo;192.168.1.242\u0026rsquo;, MASTER_USER=\u0026lsquo;zabbix241\u0026rsquo;, MASTER_PASSWORD=\u0026lsquo;zabbix241\u0026rsquo;, MASTER_LOG_FILE=\u0026lsquo;mysql-bin.000001\u0026rsquo;, MASTER_LOG_POS=1743933; MariaDB [(none)]\u0026gt; START SLAVE;\n#检查主从复制是否配置成功（Slave_IO_Running和Slave_SQL_Running是否为YES） MariaDB [zabbix]\u0026gt; SHOW SLAVE STATUS\\G;\n四、浏览器输入虚拟IP，配置数据库连接 五、zabbix前端文件及配置，主备同步（rsync +inotify） #安装文件同步组件 [root@Zabbix1 ~]# yum -y install epel-release [root@Zabbix1 ~]# yum -y install rsync inotify-tools\n#配置ssh秘钥登录 [root@Zabbix1 ~]# ssh-keygen //生成秘钥 [root@Zabbix1 ~]# ssh-copy-id zabbix2 //发送公钥到zabbix2，实现免密码远程登录\n[root@Zabbix1 ~]# ssh-keygen //生成秘钥 [root@Zabbix1 ~]# ssh-copy-id zabbix1 //发送公钥到zabbix1，实现免密码远程登录\n#网站及配置文件首次同步 [root@Zabbix1 ~]# rsync -rdvLzP \u0026ndash;delete /usr/share/zabbix/ zabbix2:/usr/share/zabbix/ [root@Zabbix1 ~]# rsync -rdvLzP \u0026ndash;delete /etc/zabbix/ zabbix2:/etc/zabbix/\n#通过inotify监控文件系统变化并自动同步文件 [root@Zabbix1 ~]# vim rsync.sh source_path_1=/usr/share/zabbix/ source_path_2=/etc/zabbix/ log_file=/var/log/rsync_client.log\ninotify_fun1(){ /usr/bin/inotifywait -mrq \u0026ndash;timefmt \u0026lsquo;%Y/%m/%d-%H:%M:%S\u0026rsquo; \u0026ndash;format \u0026lsquo;%T %w %f\u0026rsquo; \\ -e modify,delete,create,move,attrib ${source_path_1} \\ | while read file do rsync -rvLzP \u0026ndash;delete ${source_path_1} zabbix2:${source_path_1}\ndone }\ninotify_fun2(){ /usr/bin/inotifywait -mrq \u0026ndash;timefmt \u0026lsquo;%Y/%m/%d-%H:%M:%S\u0026rsquo; \u0026ndash;format \u0026lsquo;%T %w %f\u0026rsquo; \\ -e modify,delete,create,move,attrib ${source_path_2} \\ | while read file do rsync -rdvLzP \u0026ndash;delete ${source_path_2} zabbix2:${source_path_2} done }\ninotify_fun1 \u0026raquo; ${log_file} 2\u0026gt;\u0026amp;1 \u0026amp; inotify_fun2 \u0026raquo; ${log_file} 2\u0026gt;\u0026amp;1 \u0026amp;\n#将脚本设置为开机启动 [root@Zabbix1 ~]# cp rsync.sh /etc/init.d/ [root@Zabbix1 ~]# chmod +x /etc/rc.d/rc.local [root@Zabbix1 ~]# echo \u0026ldquo;sh /etc/init.d/rsync.sh\u0026rdquo; \u0026raquo; /etc/rc.d/rc.local\n","permalink":"https://water711.github.io/posts/2019-09-30-%E6%90%AD%E5%BB%BAzabbix%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/","tags":null,"title":"搭建Zabbix高可用架构"},{"categories":["linux"],"contents":"环境：\nMaster主机：zabbix1\nSlave主机：zabbix2\n主从同步的数据库：zabbix\n一、备份Master数据库 [root@Zabbix1 ~]# mysqldump -uroot -p zabbix \u0026ndash;single-transaction \u0026ndash;master-data=1 \u0026ndash;flush-logs \u0026gt; zabbix.sql #拷贝到slave机器 [root@Zabbix1 ~]# scp zabbix.sql zabbix2:/root/zabbix.sql\n二、导入主库并重新同步 [root@Zabbix2 ~]# mysql -uroot -p mysql\u0026gt; stop slave; mysql\u0026gt; reset slave; mysql\u0026gt; use zabbix mysql\u0026gt; set sql_log_bin=0; #临时关闭bin_log，加快恢复速度 mysql\u0026gt; source /root/zabbix.sql #恢复数据库\n因为备份数据库时，指定了\u0026ndash;master-data=1，备份文件会记录备份时的master_log_file和log_pos，并在mysql 控制台下使用source + 备份文件名 恢复，所以不用再使用CHANGE MASTER TO指定文件和位置 mysql\u0026gt; start slave;\nmysql\u0026gt; show slave status \\G;\n","permalink":"https://water711.github.io/posts/2019-09-28-mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E5%90%8C%E6%AD%A5%E5%A4%B1%E8%B4%A5%E5%90%8E%E9%87%8D%E5%81%9A%E4%B8%BB%E4%BB%8E/","tags":null,"title":"mysql主从数据不一致，同步失败后重做主从"},{"categories":["linux"],"contents":"实验环境：\nServer1：192.168.200.10\nServer2：192.168.200.20\n虚拟IP： 192.168.200.30\n[root@server1 ~]# yum -y install httpd keepalived\n[root@server1 ~]# vim /etc/keepalived/keepalived.conf global_defs { router_id Server1\n}\nvrrp_script http_chk { script \u0026ldquo;/etc/keepalived/httpd_check.sh\u0026rdquo; //脚本路径 interval 3 //脚本执行的间隔 }\nvrrp_instance VI_1 { state MASTER\ninterface ens33\nvirtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.200.30\n} track_script { http_chk //调用脚本 } }\n[root@server2 ~]# vim /etc/keepalived/keepalived.conf global_defs { router_id Server2 }\nvrrp_script http_chk { script \u0026ldquo;/etc/keepalived/httpd_check.sh\u0026rdquo; //脚本路径 interval 3 //脚本执行的间隔 }\nvrrp_instance VI_1 { state BACKUP interface ens33 virtual_router_id 51\npriority 50\nadvert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.200.30\n} track_script { http_chk //调用脚本 } }\n[root@server1 ~]# systemctl start httpd keepalived\n[root@server1 ~]# systemctl enable httpd keepalived\n一、检测脚本1 [root@Server1]# vim /etc/keepalived/httpd_check.sh #!/bin/bash httpd_status=`ps -C httpd \u0026ndash;no-header | wc -l` if [ $httpd_status -eq 0 ];then systemctl restart keepalived fi\n[root@Server1]# systemctl restart keepalived\n测试\n#目前虚拟IP在Server1上 [root@Server1]# systemctl stop httpd\n#停止httpd服务后，虚拟IP漂移到Server2上 [root@Server2]# ip a\n#查看Server1上的keepalived服务状态，显示failed [root@Server1]# systemctl status keepalived\n#启动httpd服务后，keepalived服务仍然显示failed [root@Server1]# systemctl start httpd\nSep 26 18:33:27 zabbix1 systemd: Stopping The Apache HTTP Server\u0026hellip; Sep 26 18:33:28 zabbix1 systemd: Stopped The Apache HTTP Server. Sep 26 18:33:28 zabbix1 Keepalived[43676]: Stopping Sep 26 18:33:28 zabbix1 systemd: Stopping LVS and VRRP High Availability Monitor\u0026hellip; Sep 26 18:33:28 zabbix1 Keepalived_vrrp[43678]: VRRP_Instance(VI_1) sent 0 priority Sep 26 18:33:28 zabbix1 Keepalived_vrrp[43678]: VRRP_Instance(VI_1) removing protocol VIPs. Sep 26 18:33:28 zabbix1 Keepalived_healthcheckers[43677]: Stopped Sep 26 18:33:29 zabbix1 Keepalived_vrrp[43678]: Stopped Sep 26 18:33:29 zabbix1 systemd: Stopped LVS and VRRP High Availability Monitor. Sep 26 18:33:29 zabbix1 Keepalived[43676]: Stopped Keepalived v1.3.5 (03/19,2017), git commit v1.3.5-6-g6fa32f2 Sep 26 18:33:29 zabbix1 systemd: Starting LVS and VRRP High Availability Monitor\u0026hellip; Sep 26 18:33:29 zabbix1 Keepalived[44036]: Starting Keepalived v1.3.5 (03/19,2017), git commit v1.3.5-6-g6fa32f2 Sep 26 18:33:29 zabbix1 Keepalived[44036]: Opening file \u0026lsquo;/etc/keepalived/keepalived.conf\u0026rsquo;. Sep 26 18:33:29 zabbix1 systemd: PID file /var/run/keepalived.pid not readable (yet?) after start. Sep 26 18:33:30 zabbix1 Keepalived[44037]: Starting Healthcheck child process, pid=44038 Sep 26 18:33:30 zabbix1 Keepalived[44037]: Starting VRRP child process, pid=44039 Sep 26 18:33:30 zabbix1 systemd: Started LVS and VRRP High Availability Monitor. Sep 26 18:33:30 zabbix1 Keepalived_healthcheckers[44038]: Opening file \u0026lsquo;/etc/keepalived/keepalived.conf\u0026rsquo;. Sep 26 18:33:30 zabbix1 Keepalived_vrrp[44039]: Registering Kernel netlink reflector Sep 26 18:33:30 zabbix1 Keepalived_vrrp[44039]: Registering Kernel netlink command channel Sep 26 18:33:30 zabbix1 Keepalived_vrrp[44039]: Registering gratuitous ARP shared channel Sep 26 18:33:30 zabbix1 Keepalived_vrrp[44039]: Opening file \u0026lsquo;/etc/keepalived/keepalived.conf\u0026rsquo;. Sep 26 18:33:30 zabbix1 Keepalived_vrrp[44039]: WARNING - default user \u0026lsquo;keepalived_script\u0026rsquo; for script execution does not exist - please create. Sep 26 18:33:30 zabbix1 Keepalived_vrrp[44039]: SECURITY VIOLATION - scripts are being executed but script_security not enabled. Sep 26 18:33:30 zabbix1 Keepalived_vrrp[44039]: VRRP_Instance(VI_1) removing protocol VIPs. Sep 26 18:33:30 zabbix1 Keepalived_vrrp[44039]: Using LinkWatch kernel netlink reflector\u0026hellip; Sep 26 18:33:30 zabbix1 Keepalived_vrrp[44039]: VRRP sockpool: [ifindex(2), proto(112), unicast(0), fd(10,11)] Sep 26 18:33:30 zabbix1 Keepalived[44037]: Stopping Sep 26 18:33:30 zabbix1 systemd: Stopping LVS and VRRP High Availability Monitor\u0026hellip; Sep 26 18:33:30 zabbix1 Keepalived_healthcheckers[44038]: Stopped Sep 26 18:33:31 zabbix1 Keepalived_vrrp[44039]: Stopped Sep 26 18:33:31 zabbix1 Keepalived[44037]: Stopped Keepalived v1.3.5 (03/19,2017), git commit v1.3.5-6-g6fa32f2 Sep 26 18:33:31 zabbix1 systemd: Stopped LVS and VRRP High Availability Monitor.\n总结：该检测脚本在httpd服务停止后，会使keepalived服务进入failed状态，VIP会漂移，但httpd服务恢复后，keepalived服务仍然为failed状态，要手动重启keepalived恢复active状态\n二、检测脚本2 [root@Server1]# vim /etc/keepalived/httpd_check.sh #!/bin/bash httpd_status=`ps -C httpd \u0026ndash;no-header | wc -l` if [ $httpd_status -eq 0 ];then systemctl stop keepalived #此处把restart改为stop fi\n[root@Server1]# systemctl restart keepalived\n测试\n#目前虚拟IP在Server1上 [root@Server1]# systemctl stop httpd\n#停止httpd服务后，虚拟IP漂移到Server2上 [root@Server2]# ip a\n#查看Server1上的keepalived服务状态，显示inactive(dead)状态 [root@Server1]# systemctl status keepalived\n#启动httpd服务后，keepalived服务仍然显示inactive(dead)状态 [root@Server1]# systemctl start httpd\nSep 26 18:43:26 zabbix1 systemd: Stopping The Apache HTTP Server\u0026hellip; Sep 26 18:43:27 zabbix1 systemd: Stopped The Apache HTTP Server. Sep 26 18:43:30 zabbix1 Keepalived[44415]: Stopping Sep 26 18:43:30 zabbix1 systemd: Stopping LVS and VRRP High Availability Monitor\u0026hellip; Sep 26 18:43:30 zabbix1 Keepalived_vrrp[44417]: VRRP_Instance(VI_1) sent 0 priority Sep 26 18:43:30 zabbix1 Keepalived_vrrp[44417]: VRRP_Instance(VI_1) removing protocol VIPs. Sep 26 18:43:30 zabbix1 Keepalived_healthcheckers[44416]: Stopped Sep 26 18:43:31 zabbix1 Keepalived_vrrp[44417]: Stopped Sep 26 18:43:31 zabbix1 systemd: Stopped LVS and VRRP High Availability Monitor. Sep 26 18:43:31 zabbix1 Keepalived[44415]: Stopped Keepalived v1.3.5 (03/19,2017), git commit v1.3.5-6-g6fa32f2\n总结：该检测脚本在httpd服务停止后，会使keepalived服务进入inactive不活动状态，VIP会漂移，但httpd服务恢复后，keepalived服务仍然为inactive不活动状态，要手动重启keepalived恢复active状态\n三、检测脚本3 [root@Server1]# vim /etc/keepalived/httpd_check.sh #!/bin/bash httpd_status=`ps -C httpd \u0026ndash;no-header | wc -l` if [ $httpd_status -eq 0 ];then sleep 5 #此处把停止keepalived服务，改成sleep，时间要大于脚本interval时间 fi\n[root@Server1]# systemctl restart keepalived\n测试\n#目前虚拟IP在Server1上 [root@Server1]# systemctl stop httpd\n#停止httpd服务后，虚拟IP漂移到Server2上 [root@Server2]# ip a\n#查看Server1上的keepalived服务状态，仍然为active活动状态 [root@Server1]# systemctl status keepalived\n#启动httpd服务后，虚拟IP重新回到Server1上 [root@Server1]# systemctl start httpd [root@Server1]# ip a\nSep 26 20:39:38 zabbix1 systemd: Stopping The Apache HTTP Server\u0026hellip; Sep 26 20:39:39 zabbix1 systemd: Stopped The Apache HTTP Server. Sep 26 20:39:43 zabbix1 Keepalived_vrrp[50621]: VRRP_Script(http_chk) timed out Sep 26 20:39:43 zabbix1 Keepalived_vrrp[50621]: /etc/keepalived/httpd_check.sh exited due to signal 15 Sep 26 20:39:43 zabbix1 Keepalived_vrrp[50621]: VRRP_Instance(VI_1) Entering FAULT STATE Sep 26 20:39:43 zabbix1 Keepalived_vrrp[50621]: VRRP_Instance(VI_1) removing protocol VIPs. Sep 26 20:39:43 zabbix1 Keepalived_vrrp[50621]: VRRP_Instance(VI_1) Now in FAULT state Sep 26 20:39:46 zabbix1 Keepalived_vrrp[50621]: /etc/keepalived/httpd_check.sh exited due to signal 15 Sep 26 20:39:49 zabbix1 Keepalived_vrrp[50621]: /etc/keepalived/httpd_check.sh exited due to signal 15 Sep 26 20:39:52 zabbix1 Keepalived_vrrp[50621]: /etc/keepalived/httpd_check.sh exited due to signal 15 Sep 26 20:41:16 zabbix1 systemd: Starting The Apache HTTP Server\u0026hellip; Sep 26 20:41:16 zabbix1 httpd: AH00558: httpd: Could not reliably determine the server\u0026rsquo;s fully qualified domain name, using 192.168.1.241. Set the \u0026lsquo;ServerName\u0026rsquo; directive globally to suppress this message Sep 26 20:41:16 zabbix1 systemd: Started The Apache HTTP Server. Sep 26 20:41:19 zabbix1 Keepalived_vrrp[50621]: /etc/keepalived/httpd_check.sh exited due to signal 15 Sep 26 20:41:19 zabbix1 Keepalived_vrrp[50621]: VRRP_Script(http_chk) succeeded Sep 26 20:41:19 zabbix1 Keepalived_vrrp[50621]: VRRP_Instance(VI_1) Entering BACKUP STATE Sep 26 20:41:20 zabbix1 Keepalived_vrrp[50621]: VRRP_Instance(VI_1) forcing a new MASTER election Sep 26 20:41:21 zabbix1 Keepalived_vrrp[50621]: VRRP_Instance(VI_1) Transition to MASTER STATE Sep 26 20:41:22 zabbix1 Keepalived_vrrp[50621]: VRRP_Instance(VI_1) Entering MASTER STATE Sep 26 20:41:22 zabbix1 Keepalived_vrrp[50621]: VRRP_Instance(VI_1) setting protocol VIPs. Sep 26 20:41:22 zabbix1 Keepalived_vrrp[50621]: Sending gratuitous ARP on eth0 for 192.168.1.240\n分析：脚本中加入sleep延时命令后，由于sleep时间大于脚本interval执行间隔时间，会导致脚本不能执行完成（日志显示VRRP_Script timed out），就被keepalived进程中止脚本（日志显示/etc/keepalived/httpd_check.sh exited due to signal 15），并且VRRP_Instance进入故障状态，从而转移VIP\n总结：该检测脚本在httpd服务停止后，keepalived服务仍然为活动状态，VIP会漂移，httpd服务恢复后，虚拟IP可重新回到Master角色Server1上\n四、检测脚本4 [root@Server1]# vim /etc/keepalived/httpd_check.sh #!/bin/bash httpd_status=`ps -C httpd \u0026ndash;no-header | wc -l` if [ $httpd_status -eq 0 ];then exit 1 fi\n[root@Server1]# systemctl restart keepalived\n测试\n#目前虚拟IP在Server1上 [root@Server1]# systemctl stop httpd\n#停止httpd服务后，虚拟IP漂移到Server2上 [root@Server2]# ip a\n#查看Server1上的keepalived服务状态，仍然为active活动状态 [root@Server1]# systemctl status keepalived\n#启动httpd服务后，虚拟IP重新回到Server1上 [root@Server1]# systemctl start httpd [root@Server1]# ip a\nSep 26 21:52:56 zabbix1 systemd: Stopping The Apache HTTP Server\u0026hellip; Sep 26 21:52:57 zabbix1 systemd: Stopped The Apache HTTP Server. Sep 26 21:52:59 zabbix1 Keepalived_vrrp[59277]: /etc/keepalived/httpd_check.sh exited with status 1 Sep 26 21:52:59 zabbix1 Keepalived_vrrp[59277]: VRRP_Script(http_chk) failed Sep 26 21:52:59 zabbix1 Keepalived_vrrp[59277]: VRRP_Instance(VI_1) Entering FAULT STATE Sep 26 21:52:59 zabbix1 Keepalived_vrrp[59277]: VRRP_Instance(VI_1) removing protocol VIPs. Sep 26 21:52:59 zabbix1 Keepalived_vrrp[59277]: VRRP_Instance(VI_1) Now in FAULT state Sep 26 21:53:02 zabbix1 Keepalived_vrrp[59277]: /etc/keepalived/httpd_check.sh exited with status 1 Sep 26 21:53:14 zabbix1 Keepalived_vrrp[59277]: /etc/keepalived/httpd_check.sh exited with status 1 Sep 26 21:53:38 zabbix1 Keepalived_vrrp[59277]: /etc/keepalived/httpd_check.sh exited with status 1 Sep 26 21:53:38 zabbix1 systemd: Starting The Apache HTTP Server\u0026hellip; Sep 26 21:53:38 zabbix1 httpd: AH00558: httpd: Could not reliably determine the server\u0026rsquo;s fully qualified domain name, using 192.168.1.241. Set the \u0026lsquo;ServerName\u0026rsquo; directive globally to suppress this message Sep 26 21:53:38 zabbix1 systemd: Started The Apache HTTP Server. Sep 26 21:53:41 zabbix1 Keepalived_vrrp[59277]: VRRP_Script(http_chk) succeeded Sep 26 21:53:41 zabbix1 Keepalived_vrrp[59277]: VRRP_Instance(VI_1) Entering BACKUP STATE Sep 26 21:53:42 zabbix1 Keepalived_vrrp[59277]: VRRP_Instance(VI_1) forcing a new MASTER election Sep 26 21:53:43 zabbix1 Keepalived_vrrp[59277]: VRRP_Instance(VI_1) Transition to MASTER STATE Sep 26 21:53:44 zabbix1 Keepalived_vrrp[59277]: VRRP_Instance(VI_1) Entering MASTER STATE Sep 26 21:53:44 zabbix1 Keepalived_vrrp[59277]: VRRP_Instance(VI_1) setting protocol VIPs. Sep 26 21:53:44 zabbix1 Keepalived_vrrp[59277]: Sending gratuitous ARP on eth0 for 192.168.1.240 Sep 26 21:53:44 zabbix1 Keepalived_vrrp[59277]: VRRP_Instance(VI_1) Sending/queueing gratuitous ARPs on eth0 for 192.168.1.240 Sep 26 21:53:44 zabbix1 Keepalived_vrrp[59277]: Sending gratuitous ARP on eth0 for 192.168.1.240 Sep 26 21:53:44 zabbix1 Keepalived_vrrp[59277]: Sending gratuitous ARP on eth0 for 192.168.1.240\n总结：该检测脚本在httpd服务停止后，脚本返回值为1，由于返回值为非0，keepalived则判断脚本执行失败，VRRP_Instance进入失败状态，VIP漂移，当httpd服务恢复后，虚拟IP重新回到Master角色Server1上\n","permalink":"https://water711.github.io/posts/2019-09-26-keepalived%E4%B9%8Bvrrp_script%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/","tags":null,"title":"keepalived之vrrp_script脚本分析"},{"categories":["linux"],"contents":"实验环境：\nServer1：192.168.200.10\nServer2：192.168.200.20\n虚拟IP： 192.168.200.30\n一、Keepalived实现简单的双机热备 #主机和备机安装httpd和keepalived [root@server1 ~]# yum -y install httpd keepalived\n#主机配置keepalived [root@server1 ~]# vim /etc/keepalived/keepalived.conf global_defs { router_id Server1 //设置router_id，名称要唯一，两台机器不能相同 }\nvrrp_instance VI_1 { state MASTER //定义本机的初始状态，MASTER为主机，BACKUP为备机 interface ens33 //指定运行VRRP的网卡名称 virtual_router_id 51 //VRRP路由ID，取值 1~255 ，同一组VRRP路由ID必须一致，该ID用于虚拟路由的MAC地址 priority 100 //优先级，值最大的将成为Master节点，取值 1~254 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.200.30 //虚拟IP，两台机器要一致 } }\n#备机配置keepalived [root@server2 ~]# vim /etc/keepalived/keepalived.conf global_defs { router_id Server2 //设置router_id，名称要唯一，两台机器不能相同 }\nvrrp_instance VI_1 { state BACKUP //定义本机的初始状态，MASTER为主机，BACKUP为备机 interface ens33 //指定运行VRRP的网卡名称 virtual_router_id 51 //VRRP路由ID，取值 1~255 ，同一组VRRP路由ID必须一致，该ID用于虚拟路由的MAC地址 priority 50 //优先级，值最大的将成为Master节点，取值 1~254 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.200.30 //虚拟IP，两台机器要一致 } }\n#两台机器启动httpd和keepalived [root@server1 ~]# systemctl start httpd keepalived\n[root@server1 ~]# systemctl enable httpd keepalived\n测试 #正常情况，虚拟IP在主机上 [root@server1 ~]# ip a 2: ens33: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 inet 192.168.200.10/24 brd 192.168.200.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.200.30/32 scope global ens33 valid_lft forever preferred_lft forever\n#模拟主机宕机 [root@server1 ~]# poweroff\n#虚拟IP切换到备机上 [root@server2 ~]# ip a 2: ens33: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 inet 192.168.200.20/24 brd 192.168.200.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet 192.168.200.30/32 scope global ens33 valid_lft forever preferred_lft forever\n二、Keepalived实现Web站点高可用 检查nginx服务是否启动，如果没启动尝试重启httpd，如果还是失败，则把关闭keepalived服务，让VIP飘到备机上\n[root@server1 ~]# vim /etc/keepalived/httpd_check.sh #!/bin/bash httpd_status1=`ps -C httpd \u0026ndash;no-header | wc -l` if [ $httpd_status1 -eq 0 ];then systemctl restart httpd sleep 3 httpd_status2=`ps -C httpd \u0026ndash;no-header | wc -l` if [ $httpd_status2 -eq 0 ];then systemctl stop keepalived fi fi\n#添加执行权限 [root@server1 ~]# chmod +x /etc/keepalived/httpd_check.sh\n注意：检测脚本写在vrrp_instance的前面，花括号前面要有空格，追踪trace_script写在vip的后面\n[root@server1 ~]# vim /etc/keepalived/keepalived.conf global_defs { router_id Server1 }\nvrrp_script httpd_chk { script \u0026ldquo;/etc/keepalived/httpd_check.sh\u0026rdquo; //指定检测脚本文件 interval 2 //每隔2秒钟执行一次检测脚本 }\nvrrp_instance VI_1 { state MASTER interface ens33 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.200.30 } track_script { httpd_chk //指定vrrp_script名称 } }\n[root@server1 ~]# systemctl restart keepalived\n[root@server2 ~]# vim /etc/keepalived/keepalived.conf global_defs { router_id Server2 }\nvrrp_script httpd_chk { script \u0026ldquo;/etc/keepalived/httpd_check.sh\u0026rdquo; interval 2 }\nvrrp_instance VI_1 { state BACKUP interface ens33 virtual_router_id 51 priority 80 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.200.30 } track_script { httpd_chk } }\n[root@server1 ~]# systemctl restart keepalived\n测试 #模拟主机的httpd服务异常关闭 [root@server1 ~]# systemctl stop httpd\n#几秒后查看httpd状态，正常应该被keepalive检测脚本重新启动httpd服务 [root@server1 ~]# systemctl status httpd\n#模拟主机的httpd服务异常关闭并且无法启动 [root@server1 ~]# mv /etc/httpd/conf/httpd.conf{,.bak} [root@server1 ~]# systemctl stop httpd\n#查看虚拟IP是否飘到备机上 [root@server2 ~]# ip a [root@server2 ~]# systemctl status httpd\n三、Web高可用并实现网站文件主备同步（rsync +inotify） #安装文件同步组件 [root@server1 ~]# yum -y install epel-release [root@server1 ~]# yum -y install rsync inotify-tools\n#配置hosts [root@server1 ~]# vim /etc/hosts 192.168.200.10 server1 192.168.200.20 server2\n#配置ssh秘钥登录 [root@server1 ~]# ssh-keygen //生成秘钥 [root@server1 ~]# ssh-copy-id server2 //发送公钥到server2，实现免密码远程登录\n[root@server2 ~]# ssh-keygen //生成秘钥 [root@server2 ~]# ssh-copy-id server1 //发送公钥到server1，实现免密码远程登录\n#关闭防火墙和Selinux [root@server1 ~]# systemctl stop firewalld [root@server1 ~]# systemctl disable firewalld [root@server1 ~]# sed -ri /^SELINUX/C\\SELINUX=disabled\u0026rsquo; /etc/selinux/config [root@server1 ~]# setenforce 0\n#server1上新建一个首页 [root@server1]# echo \u0026ldquo;this is server1 page\u0026rdquo; \u0026gt; /var/www/html/index.html\n#把首页同步到server2 [root@server1 ~]# rsync -rvLzP /var/www/html/ server2:/var/www/html/\n#验证首页是否同步到server2 [root@server2 ~]# cat /var/www/html/index.html this is server1 page\n通过inotify监控文件系统变化并自动同步文件 [root@server1]# vim rsync.sh source_path=/var/www/html/ log_file=/var/log/rsync_client.log\ninotify_fun(){ /usr/bin/inotifywait -mrq \u0026ndash;timefmt \u0026lsquo;%Y/%m/%d-%H:%M:%S\u0026rsquo; \u0026ndash;format \u0026lsquo;%T %w %f\u0026rsquo; \\ -e modify,delete,create,move,attrib ${source_path} \\ | while read file do rsync -rvLzP /var/www/html/ zabbix2:/var/www/html/\ndone }\ninotify_fun \u0026raquo; ${log_file} 2\u0026gt;\u0026amp;1 \u0026amp;\n[root@server1 ~]# chmod +x rsync.sh [root@server1 ~]# ./rsync.sh\n#把脚本设置为开机启动 [root@server1 ~]# cp rsync.sh /etc/init.d/ [root@server1 ~]# chmod +x /etc/rc.d/rc.local [root@server1 ~]# echo \u0026ldquo;sh /etc/init.d/rsync.sh\u0026rdquo; \u0026raquo; /etc/rc.d/rc.local\n测试\n#修改server1首页内容 [root@server1 ~]# echo \u0026ldquo;this is test2\u0026rdquo; \u0026gt; /var/www/html/index.html\n#验证server2首页内容 [root@server2 ~]# cat /var/www/html/index.html this is test2\n#server1网站目录下新建文件 [root@server1 ~]# touch /var/www/html/index.php\n#验证server2网站目录内容 [root@server2 ~]# ls /var/www/html/ index.html index.php\n","permalink":"https://water711.github.io/posts/2019-09-25-keepalived%E5%85%A5%E9%97%A8-%E5%AE%9E%E7%8E%B0httpd%E9%AB%98%E5%8F%AF%E7%94%A8/","tags":null,"title":"keepalived入门-实现httpd高可用"},{"categories":["linux"],"contents":"正向代理和反向代理的区别： 正向代理：代理服务器为客户端去收发请求，隐藏真实客户端\n反向代理：代理服务器为服务端收发请求，隐藏真实服务端\n需求一：隐藏真实网站服务器，由代理服务器去访问内部网站服务器，提高了内部服务器安全性 1、安装nginx\n[root@server1 ~]# yum -y install epel-release //安装EPEL源 [root@server1 ~]# yum -y install nginx [root@server1 ~]# systemctl start nginx [root@server1 ~]# systemctl enable nginx\n2、配置防火墙\n[root@server1 ~]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-service=http success [root@server1 ~]# firewall-cmd \u0026ndash;reload success\n3、配置反向代理\n[root@server1 ~]# vim /etc/nginx/nginx.conf\n注释掉默认主机 server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } [root@server1 ~]# vim /etc/nginx/conf.d/proxy.conf\n新建代理主机 server { listen 80; index index.html index.php;\nlocation / { proxy_pass http://192.168.1.248 //指定被代理的主机IP include proxy_params; //包含代理参数文件 } }\n[root@server1 ~]# vim /etc/nginx/proxy_params\n配置代理参数 proxy_redirect default; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_connect_timeout 30; proxy_send_timeout 60; proxy_read_timeout 60;\nproxy_buffer_size 32k; proxy_buffering on; proxy_buffers 4 128k; proxy_busy_buffers_size 256k; proxy_max_temp_file_size 256k;\n[root@server1 ~]# systemctl reload nginx\n需求二：实现负载均衡，由代理服务器去随机访问后端服务器 1、模拟后端多台服务器\n#模拟三个站点，为了显示负载均衡效果，网站内容各不相同 [root@server1]# mkdir /usr/share/nginx/html/{node1,node2,node3} [root@server1]# echo \u0026ldquo;this is node1\u0026rdquo; \u0026gt; /usr/share/nginx/html/node1/index.html [root@server1]# echo \u0026ldquo;this is node2\u0026rdquo; \u0026gt; /usr/share/nginx/html/node2/index.html [root@server1]# echo \u0026ldquo;this is node3\u0026rdquo; \u0026gt; /usr/share/nginx/html/node3/index.html\n#配置虚拟主机 [root@server1 ]# vim /etc/nginx/conf.d/site.conf server { listen 81; index index.html; root /usr/share/nginx/html/node1/; } server{ listen 82; index index.html; root /usr/share/nginx/html/node2/; } server{ listen 83; index index.html; root /usr/share/nginx/html/node3/; }\n2、配置防火墙和selinux\n#防火墙放行81，82，83端口 [root@server1 conf.d]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-port=81/tcp success [root@server1 conf.d]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-port=82/tcp success [root@server1 conf.d]# firewall-cmd \u0026ndash;permanent \u0026ndash;add-port=83/tcp success [root@server1 conf.d]# firewall-cmd \u0026ndash;reload\n#关闭selinux安全子系统，因为nginx使用80以外的端口会被selinux拒绝 [root@server1 ]# setenforce 0\n3、配置反向代理实现负载均衡\n[root@server1 ~]# vim /etc/nginx/nginx.conf\n注释掉默认主机 server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } [root@server1 ~]# vim /etc/nginx/conf.d/proxy.conf #新建upstream虚拟服务池，里面包含负载均衡使用到的所有主机 upstream node{ server 192.168.200.20:81; server 192.168.200.20:82; server 192.168.200.20:83; }\nserver { listen 80;\nlocation / { proxy\\_pass http://node; //代理指向upstream虚拟服务池 include proxy\\_params; } }\n[root@server1 ~]# vim /etc/nginx/proxy_params\n配置代理参数 proxy_redirect default; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_connect_timeout 30; proxy_send_timeout 60; proxy_read_timeout 60;\nproxy_buffer_size 32k; proxy_buffering on; proxy_buffers 4 128k; proxy_busy_buffers_size 256k; proxy_max_temp_file_size 256k;\n[root@server1 ~]# systemctl reload nginx\n","permalink":"https://water711.github.io/posts/2019-09-06-nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","tags":null,"title":"Nginx反向代理与负载均衡"},{"categories":["linux"],"contents":"需求：内网环境下，无法访问外网，如何更新系统以及安装项目所需软件？ 一、找一台可以联网的机器，安装操作系统（一般最小化安装，和内网机器一致）缓存所需软件包 1、开启yum缓存\n[root@host1 ~]# vim /etc/yum.conf [main] cachedir=/var/cache/yum/$basearch/$releasever //此处为缓存路径 keepcache=1 //设为1，则开启yum缓存 [root@host1 ~]# yum clean all\n2、更新系统（缓存更新包）\n[root@host1 ~]# yum -y update\n3、缓存制作yum仓库所需软件\n[root@host1 ~]# yum -y install createrepo vsftpd\n4、缓存项目所需要的软件包\n[root@host1 ~]# yum -y install ncurses ncurses-devel openssl-devel bison gcc gcc-c++ make\n5、插入U盘或移动硬盘，把yum缓存下来的软件包，拷贝出来\n[root@host1 ~]# dmesg //查看U盘设备名称 [root@host1 ~]# mount /dev/sdb /mnt/usb //挂载 [root@host1 ~]# mkdir /mnt/usb/repo [root@host1 ~]# find /var/cache/yum/ -name \u0026ldquo;*.rpm\u0026rdquo; -exec cp -rf {} /mnt/usb/repo \\; //搜索rpm包并复制到U盘\n二、内网环境下，部署yum仓库 1、安装vsftpd，把软件包拷贝到/var/ftp目录下\n[root@repo ~]# rpm -ivh vsftpd-3.0.2-25.el7.x86_64.rpm [root@repo ~]# cp -rf /mnt/usb/repo /var/ftp/ [root@repo ~]# systemctl start vsftpd [root@repo ~]# systemctl enable vsftpd\n2、安装repodata，并创建repodata索引文件\n[root@repo ~]# rpm -ivh createrepo-0.9.9-28.el7.noarch.rpm [root@repo ~]# createrepo /var/ftp/repo\n三、内网环境，找一台机器测试 1、备份原有仓库文件，配置私有yum仓库\n[root@test ~]# mv /etc/yum.repos.d/{*.repo,bak/} //备份repo文件 [root@test ~]# vi /etc/yum.repos.d/private.repo [myrepo] name=private_repo baseurl=ftp://192.168.1.90 gpgcheck=0 enable=1 [root@test ~]# yum clean all [root@test ~]# yum repolist\n2、更新系统并安装软件\n[root@test ~]# yum -y update [root@test ~]# yum -y install ncurses ncurses-devel openssl-devel bison gcc gcc-c++ make\n","permalink":"https://water711.github.io/posts/2019-09-03-%E5%86%85%E7%BD%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAyum%E4%BB%93%E5%BA%93/","tags":null,"title":"内网环境搭建YUM仓库"},{"categories":["python","zabbix"],"contents":"Zabbix API官方文档： https://www.zabbix.com/documentation/4.0/zh/manual/api\n1、向 api_jsonrpc.php 发送HTTP_POST 登录请求，获取身份验证令牌\n# -*- coding:utf-8 -*- import json import requests\nurl = \u0026lsquo;http://172.10.10.2/zabbix/api_jsonrpc.php\u0026rsquo; post_headers = {\u0026lsquo;Content-Type\u0026rsquo;: \u0026lsquo;application/json\u0026rsquo;} post_data = { \u0026ldquo;jsonrpc\u0026rdquo; : \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;method\u0026rdquo; : \u0026ldquo;user.login\u0026rdquo;, \u0026ldquo;params\u0026rdquo; : { \u0026ldquo;user\u0026rdquo; : \u0026ldquo;Admin\u0026rdquo;, \u0026ldquo;password\u0026rdquo; : \u0026ldquo;zabbix\u0026rdquo; }, \u0026ldquo;id\u0026rdquo; : 1 }\nret = requests.post(url, data = json.dumps(post_data), headers = post_headers) print(ret.text)\n输出结果：\n{ \u0026ldquo;jsonrpc\u0026rdquo;:\u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;result\u0026rdquo;:\u0026ldquo;da336b04d376d914bf06bd2192c4ce3f\u0026rdquo;, #身份验证令牌 \u0026ldquo;id\u0026rdquo;:1 }\n2、查询所有主机的信息\nurl = \u0026lsquo;http://172.10.10.2/zabbix/api_jsonrpc.php\u0026rsquo; post_headers = {\u0026lsquo;Content-Type\u0026rsquo;: \u0026lsquo;application/json\u0026rsquo;} post_data = { \u0026ldquo;jsonrpc\u0026rdquo;: \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;method\u0026rdquo;: \u0026ldquo;host.get\u0026rdquo;, \u0026ldquo;params\u0026rdquo;: { \u0026ldquo;output\u0026rdquo;: [ \u0026ldquo;hostid\u0026rdquo;, \u0026ldquo;host\u0026rdquo; ], \u0026ldquo;selectInterfaces\u0026rdquo;: [ \u0026ldquo;interfaceid\u0026rdquo;, \u0026ldquo;ip\u0026rdquo; ] }, \u0026ldquo;id\u0026rdquo;: 2, \u0026ldquo;auth\u0026rdquo;: \u0026ldquo;da336b04d376d914bf06bd2192c4ce3f\u0026rdquo; #这是第一步获取的身份验证令牌 }\nret = requests.post(url, data = json.dumps(post_data), headers = post_headers) print(ret.text)\n输出结果：\n{ \u0026ldquo;jsonrpc\u0026rdquo;: \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;result\u0026rdquo;: [ { \u0026ldquo;hostid\u0026rdquo;: \u0026ldquo;10084\u0026rdquo;, \u0026ldquo;host\u0026rdquo;: \u0026ldquo;Zabbix server\u0026rdquo;, \u0026ldquo;interfaces\u0026rdquo;: [ { \u0026ldquo;interfaceid\u0026rdquo;: \u0026ldquo;1\u0026rdquo;, \u0026ldquo;ip\u0026rdquo;: \u0026ldquo;127.0.0.1\u0026rdquo; } ] } ], \u0026ldquo;id\u0026rdquo;: 2 }\n3、获取主机组信息\nurl = \u0026lsquo;http://172.10.10.2/zabbix/api_jsonrpc.php\u0026rsquo; post_headers = {\u0026lsquo;Content-Type\u0026rsquo;: \u0026lsquo;application/json\u0026rsquo;} post_data = { \u0026ldquo;jsonrpc\u0026rdquo;: \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;method\u0026rdquo;: \u0026ldquo;hostgroup.get\u0026rdquo;, \u0026ldquo;params\u0026rdquo;: { \u0026ldquo;output\u0026rdquo;: \u0026ldquo;extend\u0026rdquo;, \u0026ldquo;filter\u0026rdquo;: { \u0026ldquo;name\u0026rdquo;: [ \u0026ldquo;Linux servers\u0026rdquo; ] } }, \u0026ldquo;auth\u0026rdquo;: \u0026ldquo;da336b04d376d914bf06bd2192c4ce3f\u0026rdquo;, \u0026ldquo;id\u0026rdquo;: 1 }\nret = requests.post(url, data = json.dumps(post_data), headers = post_headers) print(ret.text)\n输出结果：\n{ \u0026ldquo;jsonrpc\u0026rdquo;: \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;result\u0026rdquo;: [ { \u0026ldquo;groupid\u0026rdquo;: \u0026ldquo;2\u0026rdquo;, \u0026ldquo;name\u0026rdquo;: \u0026ldquo;Linux servers\u0026rdquo;, \u0026ldquo;internal\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;flags\u0026rdquo;: \u0026ldquo;0\u0026rdquo; } ], \u0026ldquo;id\u0026rdquo;: 1 }\n4、获取模版信息\nurl = \u0026lsquo;http://172.10.10.2/zabbix/api_jsonrpc.php\u0026rsquo; post_headers = {\u0026lsquo;Content-Type\u0026rsquo;: \u0026lsquo;application/json\u0026rsquo;} post_data = { \u0026ldquo;jsonrpc\u0026rdquo;: \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;method\u0026rdquo;: \u0026ldquo;template.get\u0026rdquo;, \u0026ldquo;params\u0026rdquo;: { \u0026ldquo;output\u0026rdquo;: \u0026ldquo;extend\u0026rdquo;, \u0026ldquo;filter\u0026rdquo;: { \u0026ldquo;host\u0026rdquo;: [ \u0026ldquo;Template OS Linux\u0026rdquo; ] } }, \u0026ldquo;auth\u0026rdquo;: \u0026ldquo;dfba5d41dc9b46d6525f70af13631cb6\u0026rdquo;, \u0026ldquo;id\u0026rdquo;: 1 }\nret = requests.post(url, data = json.dumps(post_data), headers = post_headers) print(ret.text)\n输出结果：\n{ \u0026ldquo;jsonrpc\u0026rdquo;: \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;result\u0026rdquo;: [ { \u0026ldquo;proxy_hostid\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;host\u0026rdquo;: \u0026ldquo;Template OS Linux\u0026rdquo;, \u0026ldquo;status\u0026rdquo;: \u0026ldquo;3\u0026rdquo;, \u0026ldquo;disable_until\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;error\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;available\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;errors_from\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;lastaccess\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;ipmi_authtype\u0026rdquo;: \u0026ldquo;-1\u0026rdquo;, \u0026ldquo;ipmi_privilege\u0026rdquo;: \u0026ldquo;2\u0026rdquo;, \u0026ldquo;ipmi_username\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;ipmi_password\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;ipmi_disable_until\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;ipmi_available\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;snmp_disable_until\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;snmp_available\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;maintenanceid\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;maintenance_status\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;maintenance_type\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;maintenance_from\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;ipmi_errors_from\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;snmp_errors_from\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;ipmi_error\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;snmp_error\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;jmx_disable_until\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;jmx_available\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;jmx_errors_from\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;jmx_error\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;name\u0026rdquo;: \u0026ldquo;Template OS Linux\u0026rdquo;, \u0026ldquo;flags\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;templateid\u0026rdquo;: \u0026ldquo;10001\u0026rdquo;, \u0026ldquo;description\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;tls_connect\u0026rdquo;: \u0026ldquo;1\u0026rdquo;, \u0026ldquo;tls_accept\u0026rdquo;: \u0026ldquo;1\u0026rdquo;, \u0026ldquo;tls_issuer\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;tls_subject\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;tls_psk_identity\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;tls_psk\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;proxy_address\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;auto_compress\u0026rdquo;: \u0026ldquo;1\u0026rdquo; } ], \u0026ldquo;id\u0026rdquo;: 1 }\n5、创建主机\nurl = \u0026lsquo;http://172.10.10.2/zabbix/api_jsonrpc.php\u0026rsquo; post_headers = {\u0026lsquo;Content-Type\u0026rsquo;: \u0026lsquo;application/json\u0026rsquo;} post_data = { \u0026ldquo;jsonrpc\u0026rdquo;: \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;method\u0026rdquo;: \u0026ldquo;host.create\u0026rdquo;, \u0026ldquo;params\u0026rdquo;: { \u0026ldquo;host\u0026rdquo;: \u0026ldquo;Linux server\u0026rdquo;, \u0026ldquo;interfaces\u0026rdquo;: [ { \u0026ldquo;type\u0026rdquo;: 1, \u0026ldquo;main\u0026rdquo;: 1, \u0026ldquo;useip\u0026rdquo;: 1, \u0026ldquo;ip\u0026rdquo;: \u0026ldquo;192.168.3.1\u0026rdquo;, \u0026ldquo;dns\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;port\u0026rdquo;: \u0026ldquo;10050\u0026rdquo; } ], \u0026ldquo;groups\u0026rdquo;: [ { \u0026ldquo;groupid\u0026rdquo;: \u0026ldquo;2\u0026rdquo; #填写第3步获取的组ID } ], \u0026ldquo;templates\u0026rdquo;: [ { \u0026ldquo;templateid\u0026rdquo;: \u0026ldquo;10001\u0026rdquo; #填写第4步获取的模板ID } ], \u0026ldquo;macros\u0026rdquo;: [ { \u0026ldquo;macro\u0026rdquo;: \u0026ldquo;{$USER_ID}\u0026rdquo;, \u0026ldquo;value\u0026rdquo;: \u0026ldquo;123321\u0026rdquo; } ], \u0026ldquo;inventory_mode\u0026rdquo;: 0, \u0026ldquo;inventory\u0026rdquo;: { \u0026ldquo;macaddress_a\u0026rdquo;: \u0026ldquo;01234\u0026rdquo;, \u0026ldquo;macaddress_b\u0026rdquo;: \u0026ldquo;56768\u0026rdquo; } }, \u0026ldquo;auth\u0026rdquo;: \u0026ldquo;dfba5d41dc9b46d6525f70af13631cb6\u0026rdquo;, \u0026ldquo;id\u0026rdquo;: 1 }\nret = requests.post(url, data = json.dumps(post_data), headers = post_headers) print(ret.text)\n输出结果：\n{ \u0026ldquo;jsonrpc\u0026rdquo;: \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;result\u0026rdquo;: { \u0026ldquo;hostids\u0026rdquo;: [ \u0026ldquo;10264\u0026rdquo; ] }, \u0026ldquo;id\u0026rdquo;: 1 }\n","permalink":"https://water711.github.io/posts/2019-06-20-%E4%BD%BF%E7%94%A8python%E8%B0%83%E7%94%A8zabbixapi/","tags":null,"title":"使用Python调用Zabbix API"},{"categories":["python","zabbix"],"contents":"Zabbix API官方文档： https://www.zabbix.com/documentation/4.0/zh/manual/api\n1、向 api_jsonrpc.php 发送HTTP_POST 登录请求，获取身份验证令牌\n# -*- coding:utf-8 -*- import json import requests\nurl = \u0026lsquo;http://172.10.10.2/zabbix/api_jsonrpc.php\u0026rsquo; post_headers = {\u0026lsquo;Content-Type\u0026rsquo;: \u0026lsquo;application/json\u0026rsquo;} post_data = { \u0026ldquo;jsonrpc\u0026rdquo; : \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;method\u0026rdquo; : \u0026ldquo;user.login\u0026rdquo;, \u0026ldquo;params\u0026rdquo; : { \u0026ldquo;user\u0026rdquo; : \u0026ldquo;Admin\u0026rdquo;, \u0026ldquo;password\u0026rdquo; : \u0026ldquo;zabbix\u0026rdquo; }, \u0026ldquo;id\u0026rdquo; : 1 }\nret = requests.post(url, data = json.dumps(post_data), headers = post_headers) print(ret.text)\n输出结果：\n{ \u0026ldquo;jsonrpc\u0026rdquo;:\u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;result\u0026rdquo;:\u0026ldquo;da336b04d376d914bf06bd2192c4ce3f\u0026rdquo;, #身份验证令牌 \u0026ldquo;id\u0026rdquo;:1 }\n2、查询所有主机的信息\nurl = \u0026lsquo;http://172.10.10.2/zabbix/api_jsonrpc.php\u0026rsquo; post_headers = {\u0026lsquo;Content-Type\u0026rsquo;: \u0026lsquo;application/json\u0026rsquo;} post_data = { \u0026ldquo;jsonrpc\u0026rdquo;: \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;method\u0026rdquo;: \u0026ldquo;host.get\u0026rdquo;, \u0026ldquo;params\u0026rdquo;: { \u0026ldquo;output\u0026rdquo;: [ \u0026ldquo;hostid\u0026rdquo;, \u0026ldquo;host\u0026rdquo; ], \u0026ldquo;selectInterfaces\u0026rdquo;: [ \u0026ldquo;interfaceid\u0026rdquo;, \u0026ldquo;ip\u0026rdquo; ] }, \u0026ldquo;id\u0026rdquo;: 2, \u0026ldquo;auth\u0026rdquo;: \u0026ldquo;da336b04d376d914bf06bd2192c4ce3f\u0026rdquo; #这是第一步获取的身份验证令牌 }\nret = requests.post(url, data = json.dumps(post_data), headers = post_headers) print(ret.text)\n输出结果：\n{ \u0026ldquo;jsonrpc\u0026rdquo;: \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;result\u0026rdquo;: [ { \u0026ldquo;hostid\u0026rdquo;: \u0026ldquo;10084\u0026rdquo;, \u0026ldquo;host\u0026rdquo;: \u0026ldquo;Zabbix server\u0026rdquo;, \u0026ldquo;interfaces\u0026rdquo;: [ { \u0026ldquo;interfaceid\u0026rdquo;: \u0026ldquo;1\u0026rdquo;, \u0026ldquo;ip\u0026rdquo;: \u0026ldquo;127.0.0.1\u0026rdquo; } ] } ], \u0026ldquo;id\u0026rdquo;: 2 }\n3、获取主机组信息\nurl = \u0026lsquo;http://172.10.10.2/zabbix/api_jsonrpc.php\u0026rsquo; post_headers = {\u0026lsquo;Content-Type\u0026rsquo;: \u0026lsquo;application/json\u0026rsquo;} post_data = { \u0026ldquo;jsonrpc\u0026rdquo;: \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;method\u0026rdquo;: \u0026ldquo;hostgroup.get\u0026rdquo;, \u0026ldquo;params\u0026rdquo;: { \u0026ldquo;output\u0026rdquo;: \u0026ldquo;extend\u0026rdquo;, \u0026ldquo;filter\u0026rdquo;: { \u0026ldquo;name\u0026rdquo;: [ \u0026ldquo;Linux servers\u0026rdquo; ] } }, \u0026ldquo;auth\u0026rdquo;: \u0026ldquo;da336b04d376d914bf06bd2192c4ce3f\u0026rdquo;, \u0026ldquo;id\u0026rdquo;: 1 }\nret = requests.post(url, data = json.dumps(post_data), headers = post_headers) print(ret.text)\n输出结果：\n{ \u0026ldquo;jsonrpc\u0026rdquo;: \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;result\u0026rdquo;: [ { \u0026ldquo;groupid\u0026rdquo;: \u0026ldquo;2\u0026rdquo;, \u0026ldquo;name\u0026rdquo;: \u0026ldquo;Linux servers\u0026rdquo;, \u0026ldquo;internal\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;flags\u0026rdquo;: \u0026ldquo;0\u0026rdquo; } ], \u0026ldquo;id\u0026rdquo;: 1 }\n4、获取模版信息\nurl = \u0026lsquo;http://172.10.10.2/zabbix/api_jsonrpc.php\u0026rsquo; post_headers = {\u0026lsquo;Content-Type\u0026rsquo;: \u0026lsquo;application/json\u0026rsquo;} post_data = { \u0026ldquo;jsonrpc\u0026rdquo;: \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;method\u0026rdquo;: \u0026ldquo;template.get\u0026rdquo;, \u0026ldquo;params\u0026rdquo;: { \u0026ldquo;output\u0026rdquo;: \u0026ldquo;extend\u0026rdquo;, \u0026ldquo;filter\u0026rdquo;: { \u0026ldquo;host\u0026rdquo;: [ \u0026ldquo;Template OS Linux\u0026rdquo; ] } }, \u0026ldquo;auth\u0026rdquo;: \u0026ldquo;dfba5d41dc9b46d6525f70af13631cb6\u0026rdquo;, \u0026ldquo;id\u0026rdquo;: 1 }\nret = requests.post(url, data = json.dumps(post_data), headers = post_headers) print(ret.text)\n输出结果：\n{ \u0026ldquo;jsonrpc\u0026rdquo;: \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;result\u0026rdquo;: [ { \u0026ldquo;proxy_hostid\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;host\u0026rdquo;: \u0026ldquo;Template OS Linux\u0026rdquo;, \u0026ldquo;status\u0026rdquo;: \u0026ldquo;3\u0026rdquo;, \u0026ldquo;disable_until\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;error\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;available\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;errors_from\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;lastaccess\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;ipmi_authtype\u0026rdquo;: \u0026ldquo;-1\u0026rdquo;, \u0026ldquo;ipmi_privilege\u0026rdquo;: \u0026ldquo;2\u0026rdquo;, \u0026ldquo;ipmi_username\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;ipmi_password\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;ipmi_disable_until\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;ipmi_available\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;snmp_disable_until\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;snmp_available\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;maintenanceid\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;maintenance_status\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;maintenance_type\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;maintenance_from\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;ipmi_errors_from\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;snmp_errors_from\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;ipmi_error\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;snmp_error\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;jmx_disable_until\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;jmx_available\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;jmx_errors_from\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;jmx_error\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;name\u0026rdquo;: \u0026ldquo;Template OS Linux\u0026rdquo;, \u0026ldquo;flags\u0026rdquo;: \u0026ldquo;0\u0026rdquo;, \u0026ldquo;templateid\u0026rdquo;: \u0026ldquo;10001\u0026rdquo;, \u0026ldquo;description\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;tls_connect\u0026rdquo;: \u0026ldquo;1\u0026rdquo;, \u0026ldquo;tls_accept\u0026rdquo;: \u0026ldquo;1\u0026rdquo;, \u0026ldquo;tls_issuer\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;tls_subject\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;tls_psk_identity\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;tls_psk\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;proxy_address\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;auto_compress\u0026rdquo;: \u0026ldquo;1\u0026rdquo; } ], \u0026ldquo;id\u0026rdquo;: 1 }\n5、创建主机\nurl = \u0026lsquo;http://172.10.10.2/zabbix/api_jsonrpc.php\u0026rsquo; post_headers = {\u0026lsquo;Content-Type\u0026rsquo;: \u0026lsquo;application/json\u0026rsquo;} post_data = { \u0026ldquo;jsonrpc\u0026rdquo;: \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;method\u0026rdquo;: \u0026ldquo;host.create\u0026rdquo;, \u0026ldquo;params\u0026rdquo;: { \u0026ldquo;host\u0026rdquo;: \u0026ldquo;Linux server\u0026rdquo;, \u0026ldquo;interfaces\u0026rdquo;: [ { \u0026ldquo;type\u0026rdquo;: 1, \u0026ldquo;main\u0026rdquo;: 1, \u0026ldquo;useip\u0026rdquo;: 1, \u0026ldquo;ip\u0026rdquo;: \u0026ldquo;192.168.3.1\u0026rdquo;, \u0026ldquo;dns\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;port\u0026rdquo;: \u0026ldquo;10050\u0026rdquo; } ], \u0026ldquo;groups\u0026rdquo;: [ { \u0026ldquo;groupid\u0026rdquo;: \u0026ldquo;2\u0026rdquo; #填写第3步获取的组ID } ], \u0026ldquo;templates\u0026rdquo;: [ { \u0026ldquo;templateid\u0026rdquo;: \u0026ldquo;10001\u0026rdquo; #填写第4步获取的模板ID } ], \u0026ldquo;macros\u0026rdquo;: [ { \u0026ldquo;macro\u0026rdquo;: \u0026ldquo;{$USER_ID}\u0026rdquo;, \u0026ldquo;value\u0026rdquo;: \u0026ldquo;123321\u0026rdquo; } ], \u0026ldquo;inventory_mode\u0026rdquo;: 0, \u0026ldquo;inventory\u0026rdquo;: { \u0026ldquo;macaddress_a\u0026rdquo;: \u0026ldquo;01234\u0026rdquo;, \u0026ldquo;macaddress_b\u0026rdquo;: \u0026ldquo;56768\u0026rdquo; } }, \u0026ldquo;auth\u0026rdquo;: \u0026ldquo;dfba5d41dc9b46d6525f70af13631cb6\u0026rdquo;, \u0026ldquo;id\u0026rdquo;: 1 }\nret = requests.post(url, data = json.dumps(post_data), headers = post_headers) print(ret.text)\n输出结果：\n{ \u0026ldquo;jsonrpc\u0026rdquo;: \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;result\u0026rdquo;: { \u0026ldquo;hostids\u0026rdquo;: [ \u0026ldquo;10264\u0026rdquo; ] }, \u0026ldquo;id\u0026rdquo;: 1 }\n","permalink":"https://water711.github.io/posts/2019-06-20-%E4%BD%BF%E7%94%A8python%E8%B0%83%E7%94%A8zabbixapinull/","tags":null,"title":"使用Python调用Zabbix API"},{"categories":["linux"],"contents":"vsftp会根据/etc/shells文件来判断用户是否是有效，并阻止shell不在/etc/shells文件里的用户登陆\n解决方法：echo \u0026lsquo;/sbin/nologin\u0026rsquo; \u0026raquo; /etc/shells\n","permalink":"https://water711.github.io/posts/2019-05-10-vsftpd%E6%9C%AC%E5%9C%B0%E7%94%A8%E6%88%B7shell%E4%B8%BAnologin%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AEftp/","tags":null,"title":"vsftpd本地用户shell为nologin无法访问ftp"},{"categories":null,"contents":"1、下载mysql绿色版压缩包 https://dev.mysql.com/downloads/mysql/\n2、解压到安装目录后，在根目录创建data文件夹\n3、把mysql下的bin目录添加到环境变量\n4、根目录创建my.ini文件，并拷贝以下代码，并修改basedir和datadir路径\n# MySQL Server Instance Configuration File\n\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- Generated by the MySQL Server Instance Configuration Wizard Installation Instructions \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- On Linux you can copy this file to /etc/my.cnf to set global options, mysql-data-dir/my.cnf to set server-specific options (@localstatedir@ for this installation) or to ~/.my.cnf to set user-specific options. On Windows you should keep this file in the installation directory of your server (e.g. C:\\Program Files\\MySQL\\MySQL Server X.Y). To make sure the server reads the config file use the startup option \u0026ldquo;\u0026ndash;defaults-file\u0026rdquo;. To run run the server from the command line, execute this in a command line shell, e.g. mysqld \u0026ndash;defaults-file=\u0026ldquo;D:\\GreenSoft\\MySQL\\my.ini\u0026rdquo; To install the server as a Windows service manually, execute this in a command line shell, e.g. mysqld \u0026ndash;install mysql \u0026ndash;defaults-file=\u0026ldquo;D:\\GreenSoft\\MySQL\\my.ini\u0026rdquo; And then execute this in a command line shell to start the server, e.g. net start mysql Guildlines for editing this file \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- In this file, you can use all long options that the program supports. If you want to know the options a program supports, start the program with the \u0026ldquo;\u0026ndash;help\u0026rdquo; option. More detailed information about the individual options can also be found in the manual. For advice on how to change settings please see http://dev.mysql.com/doc/refman/8.0/en/server-configuration-defaults.html CLIENT SECTION \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- The following options will be read by MySQL client applications. Note that only client applications shipped by MySQL are guaranteed to read this section. If you want your own MySQL client program to honor these values, you need to specify it as an option during the MySQL client library initialization. [client] no-beep\npipe socket=0.0 port=3306\n[mysql]\ndefault-character-set=utf8\n[mysqld]\n这是8.0.4的新特性 caching_sha2_password，在linux上面使用命宁 mysql -uroot -proot 可以链接，但是使用windows下面的navict链接不成功 default_authentication_plugin = mysql_native_password\nThese are commonly set, remove the # and set as required. character-set-server = utf8 basedir = D:\\Program Files\\mysql-8.0.11-winx64 datadir = D:\\Program Files\\mysql-8.0.11-winx64\\data port = 3306 server_id = 1\nRemove leading # and set to the amount of RAM for the most important data cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%. innodb_buffer_pool_size = 128M\nRemove leading # to turn on a very important data integrity option: logging changes to the binary log between backups. log_bin General and Slow logging. log-output=FILE general-log=0 general_log_file=\u0026ldquo;CUPID.log\u0026rdquo; slow-query-log=1 slow_query_log_file=\u0026ldquo;CUPID-slow.log\u0026rdquo; long_query_time=10\nBinary Logging. log-bin Error Logging. log-error=\u0026ldquo;CUPID.err\u0026rdquo;\nRemove leading # to set options mainly useful for reporting servers. The server defaults are faster for transactions and fast SELECTs. Adjust sizes as needed, experiment to find the optimal values. join_buffer_size = 128M sort_buffer_size = 2M read_rnd_buffer_size = 2M 8.0.4版本的时候，用的是这个sql_mode，但在8.0.11版本中会报错，改成下面那个 sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION sql-mode=\u0026ldquo;STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION\u0026rdquo;\ndefault-storage-engine=INNODB\ninnodb_log_file_size = 512M binlog_format=\u0026lsquo;MIXED\u0026rsquo; max_allowed_packet = 1G\ninnodb_file_per_table = 1 innodb_file_format = Barracuda 大小写是否敏感，0敏感 Linux下默认为0， Windows下默认值是 1， MacOS下默认值是 2（0敏感） lower_case_table_names = 1\ninnodb_strict_mode = 0 max_connections = 500\n5、mysqld \u0026ndash;install //安装MYSQL服务\n6、mysqld \u0026ndash;initialize \u0026ndash;user=mysql \u0026ndash;console //初始化mysql，并记下临时密码\n7、net start mysql //启动mysql服务\n8、SET PASSWORD = \u0026lsquo;123456\u0026rsquo;; //修改密码\n或者使用\nALTER USER \u0026lsquo;root\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; IDENTIFIED BY \u0026lsquo;123456\u0026rsquo;;\n9、CREATE USER \u0026lsquo;username\u0026rsquo;@\u0026lsquo;host\u0026rsquo; IDENTIFIED BY \u0026lsquo;password\u0026rsquo;; （创建异地登录用户）\n例：CREATE USER \u0026lsquo;backup\u0026rsquo;@\u0026lsquo;10.0.0.2\u0026rsquo; IDENTIFIED BY \u0026lsquo;123456\u0026rsquo;; （用户名为backup,密码123456，只允许10.0.0.2远程登录）\n10、GRANT privileges ON databasename.tablename TO \u0026lsquo;username\u0026rsquo;@\u0026lsquo;host\u0026rsquo;;（用户授权）\n例：GRANT select，lock tables ON db1.* TO \u0026lsquo;backup\u0026rsquo;@\u0026rsquo;%\u0026rsquo;;（授权db1数据库的select和lock tables权限给backup用户）\n客户端下使用mysqldump备份\n1、下载mysql绿色版，解压后，进入bin目录（客户端可以不用安装服务和初始化）\n2、mysqldump -h主机名 -P端口 -u用户名 -p密码 数据库名 \u0026gt; 文件名.sql\nmysqldump -h10.0.0.1 -P3310 -ubackup -p123456 db1 \u0026gt; db1.sql （备份db1数据库并保存为db1.sql文件）\n安装mysql过程中，出现过的报错\n1、丢失MSVCP140.DLL 解决方法：安装VC++2015运行库\n2、安装VC++2015运行库失败 解决方法：控制面板-》Windows更新，更新到最新补丁\n","permalink":"https://water711.github.io/posts/2019-03-10-mysql8-0%E7%BB%BF%E8%89%B2%E7%89%88%E5%AE%89%E8%A3%85%E5%8F%8Amysqldump%E5%A4%87%E4%BB%BD/","tags":null,"title":"mysql8.0绿色版安装及mysqldump备份"},{"categories":["zabbix"],"contents":"zabbix接收trap的工作流程：\nsnmptrapd 收到trap snmptrapd将trap传递给SNMPTT或调用Perl接收器 SNMPTT或Perl trap接收器解析，格式化并将trap写入文件 Zabbix SNMP trap读取并解析trap文件 对于每个trap，Zabbix发现主机接口与接收的trap地址匹配的所有“SNMP trap”监控项。请注意，在匹配期间只使用主机接口中选定的“IP”或“DNS”。 对于每个找到的监控项，将trap与“snmptrap[regexp]”中的regexp进行比较。 trap设置为all匹配项的值。如果没有找到匹配的监控项，并且有一个“snmptrap.fallback”监控项，则将trap设置为该值。 如果trap未设置为任何监控项的值，Zabbix默认记录不匹配的trap。（这由管理 - \u0026gt;常规 - \u0026gt;其它中的“记录不匹配的SNMP trap（Log unmatched SNMP traps）”配置。） 一、安装配置snmptrapd\n1、yum install -y net-snmp net-snmp-utils net-snmp-perl #安装net-snmp及相关工具（里面包含SNMPTrapd）\n2、vim /etc/snmp/snmptrapd.conf\nauthCommunity log,execute,net 团体名 #指定团体名\ntraphandle default /usr/sbin/snmptthandler #指定snmptt为trap接收器，此时还没安装snmptt\n3、systemctl start snmptrapd #启动snmptrapd\n4、systemctl enable snmptrapd #加入开机启动项\n5、交换机开启snmp和snmptrap，并指定团体名和trap目标主机IP\n6、tail -F /var/log/messages #打开并跟踪日志\n7、手动关闭交换机端口，触发告警，验证snmptrapd是否能正常接收trap\n二、安装配置snmptt\n1、yum -y install epel-release #安装EPRL源 2、yum -y install snmptt #安装snmptt 3、systemctl start snmptt （启动报错：Could not load Perl module Sys::Syslog!） 4、systemctl status snmptt -l #查看出错信息，缺少perl-syslog 5、yum -y install perl-Sys-Syslog #安装perl-syslog 6、vim /etc/snmp/snmptt.ini #修改配置文件\ndate_time_format= %Y/%m/%d %H:%M:%S net_snmp_perl_enable = 1 translate_log_trap_oid = 2 # 0：数字形式显示OID，1：显示OID名称，2：显示OID所属模块名及其名称 log_file = /var/log/snmptt/snmptt.log #默认\n7、mv /etc/snmp/snmptt.conf /etc/snmp/snmptt.conf.bak #备份规则文件 8、vim /etc/snmp/snmptt.conf #自定义trap格式化规则\n#匹配Linkdown的规则 EVENT LinkDown .1.3.6.1.6.3.1.1.5.3 \u0026ldquo;Status Events\u0026rdquo; Warning FORMAT ZBXTRAP $aA LinkDown on interface $4. Admin state: $2. Operational state: $3\n#匹配Linkup的规则 EVENT LinkUp .1.3.6.1.6.3.1.1.5.4 \u0026ldquo;Status Events\u0026rdquo; Normal FORMAT ZBXTRAP $aA Linkup on interface $4. Admin state: $2. Operational state: $3\n默认规则，没有其他规则匹配上时，所有trap信息都按此规则处理 EVENT general .* \u0026ldquo;General event\u0026rdquo; Normal FORMAT ZBXTRAP $aA $1\n9、systemctl restart snmptt 10、tail -F /var/log/snmptt/snmptt.log #打开并跟踪snmptt日志\n三、配置zabbix-server 1、vim /etc/zabbix/zabbix_server.conf\nStartSNMPTrapper=1 #开启SNMPTrapper功能 SNMPTrapperFile=/var/log/snmptt/snmptt.log #指定snmptt日志文件\n2、systemctl restart zabbix-server #重启Zabbix服务 3、zabbix添加监控项 匹配snmptt日志中，属于IF-MIB模块的告警（IF-MIB包含设备接口相关的管理对象，告警节点包含linkUp和linkDown）\n其余没匹配上的，都匹配到键值为fallback的监控项\n查看获取的trap数据\nzabbix_snmptrap官方文档\nhttps://www.zabbix.com/documentation/3.4/zh/manual/config/items/itemtypes/snmptrap\nhttps://www.zabbix.org/wiki/Start_with_SNMP_traps_in_Zabbix\nsnmptt官方文档\nhttp://www.snmptt.org/docs/snmptt.shtml\n","permalink":"https://water711.github.io/posts/2019-03-06-zabbix%E5%88%A9%E7%94%A8snmptrap%E6%8E%A5%E6%94%B6%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%BB%E5%8A%A8%E5%91%8A%E8%AD%A6/","tags":null,"title":"zabbix利用SNMPTrap接收交换机主动告警"},{"categories":["zabbix"],"contents":"1、在Zabbix中添加主机\n输入名称、群组和交换机IP（交换机要开启snmp）\n2、创建监控项\n输入OID和其它信息（键值随便填，但是不能和系统内的键值重复）\nOID获取方法可查看上一篇文章：https://www.cnblogs.com/zhenwei66/p/10473121.html\n3、添加图形\n查看图形\n","permalink":"https://water711.github.io/posts/2019-03-04-zabbix%E7%9B%91%E6%8E%A7%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%8A%B6%E6%80%81/","tags":null,"title":"zabbix监控交换机状态"},{"categories":["zabbix"],"contents":"1、安装邮件服务\nyum -y install mailx echo \u0026ldquo;我是内容\u0026rdquo; | mail -s \u0026ldquo;邮件测试\u0026rdquo; 894548465@qq.com #发邮件测试\n2、添加报警媒介\n输入接收告警邮件的邮箱\n3、配置SMTP服务端\n使用本机作为SMTP服务器\n4、创建触发器\n最后1个值大于40度则触发告警（值设低一点，方便查看效果） 更多触发器表达式用法，可查看官方文档：https://www.zabbix.com/documentation/4.0/zh/manual/config/triggers/expression\n函数用法：https://www.zabbix.com/documentation/4.0/manual/appendix/triggers/functions\n查看触发器是否被触发\n4、配置Actions动作\n动作内容中，可用的宏列表： https://www.zabbix.com/documentation/4.0/zh/manual/appendix/macros/supported_by_location\n5、查看告警邮件\nPS：如果收不到，有可能是被过滤到垃圾箱\n","permalink":"https://water711.github.io/posts/2019-03-04-zabbix%E9%85%8D%E7%BD%AE%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6/","tags":null,"title":"zabbix配置邮件告警"},{"categories":["zabbix"],"contents":"1、下载交换机MIB参考文件 访问 https://support.huawei.com/enterprise/zh/index.html，搜索交换机型号，点击案例库，选择MIB参考\n2、交换机下启用snmp，并设置团体名 图形界面：\n命令行：\nsystem-view snmp-agent snmp-agent community read public //设置读团体名:public snmp-agent community write private //设置写团体名:private\n3、linux下安装snmpwalk\nyum -y install net-snmp-utils\n4、使用snmpwalk获取交换机OID信息\nsnmpwalk -v SNMP版本（1或2c) -c 团体名 IP地址 OID(对象标示符)\na、通过硬件实体名OID，查询硬件索引值，查询到MPU Board索引值为67108873\nsnmpwalk -v 2c -c 团体名 IP地址 1.3.6.1.2.1.47.1.1.1.1.7\nb、查询CPU使用率，查询时要在OID后面加上MPU Board的索引值\n（如果不指定硬件索引，会列出所有硬件的CPU使用率的值，但是其它硬件没有CPU使用率，所以值为0）\nsnmpwalk -v 2c -c 团体名 IP地址 1.3.6.1.4.1.2011.5.25.31.1.1.1.1.5.67108873\nc、查询内存使用率\nsnmpwalk -v 2c -c 团体名 IP地址 1.3.6.1.4.1.2011.5.25.31.1.1.1.1.7.67108873\nd、查询设备温度\nsnmpwalk -v 2c -c 团体名 IP地址 1.3.6.1.4.1.2011.5.25.31.1.1.1.1.11.67108873\n","permalink":"https://water711.github.io/posts/2019-03-04-%E4%B8%8B%E8%BD%BD%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BAmib%E5%8F%82%E8%80%83%E6%96%87%E4%BB%B6%E5%B9%B6%E4%BD%BF%E7%94%A8snmpwalk%E8%8E%B7%E5%8F%96oid%E4%BF%A1%E6%81%AF/","tags":null,"title":"下载华为交换机MIB参考文件并使用snmpwalk获取OID信息"},{"categories":["zabbix"],"contents":"1、添加 Zabbix 软件仓库\nrpm -ivh http://repo.zabbix.com/zabbix/4.0/rhel/7/x86_64/zabbix-release-4.0-1.el7.noarch.rpm\n2、启用可选 rpms 的软件仓库\nyum -y install yum-utils yum-config-manager \u0026ndash;enable rhel-7-server-optional-rpms\n3、安装 Server/前端/agent\nyum -y install zabbix-server-mysql zabbix-web-mysql zabbix-agent\n4、安装mariaDB数据库\nyum install -y mariadb mariadb-server\n5、创建数据库\nmysql -uroot -p mysql\u0026gt; create database zabbix character set utf8 collate utf8_bin;\n6、创建账户并授权\nmysql\u0026gt; grant all privileges on zabbix.* to zabbix@localhost identified by \u0026lsquo;zabbix\u0026rsquo;; mysql\u0026gt; quit;\n7、导入数据 (导入需要一点时间，不要以为卡住按ctrl+c停止)\nzcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -pzabbix zabbix\n8、修改Zabbix server配置文件\nvim /etc/zabbix/zabbix_server.conf DBPassword=zabbix\n9、为Zabbix前端配置PHP\nvim /etc/httpd/conf.d/zabbix.conf php_value date.timezone Asia/Shanghai\n10、关闭selinux\n永久关闭\nvim /etc/selinux/config SELINUX=disabled\n临时关闭\nsetenforce 0\n11、关闭防火墙\n永久关闭\nsystemctl disable firewalld.service\n临时关闭\nsystemctl stop firewalld.service\n12. 启动Zabbix server和httpd服务\n启动服务，并设置开机自启\nsystemctl restart zabbix-server httpd systemctl enable zabbix-server httpd\n13、配置Zabbix前端\n浏览器访问 http://server_ip/zabbix\n检查安装先决条件，必须所有项为OK 输入数据库密码，前面步骤已设置密码为zabbix\nName为可选项，它会显示在菜单栏和网页title上\n默认用户名为Admin，密码为zabbix\n14、设置中文语言\n点击右上角用户图标\n修改Language\n15、解决Zabbix中文乱码问题\n在windows系统上挑选一款中文字体\n先备份原有字体文件graphfont.ttf，再把字体文件名修改为graphfont.ttf\n拷贝到/usr/share/zabbix/fonts/ 目录下替换字体\n","permalink":"https://water711.github.io/posts/2019-03-02-rhel7-centos7%E5%AE%89%E8%A3%85zabbix/","tags":null,"title":"RHEL7/CentOS7 安装Zabbix"},{"categories":["zabbix"],"contents":"1、添加 Zabbix 软件仓库\nrpm -ivh http://repo.zabbix.com/zabbix/4.0/rhel/7/x86_64/zabbix-release-4.0-1.el7.noarch.rpm\n2、启用可选 rpms 的软件仓库\nyum -y install yum-utils yum-config-manager \u0026ndash;enable rhel-7-server-optional-rpms\n3、安装 Server/前端/agent\nyum -y install zabbix-server-mysql zabbix-web-mysql zabbix-agent\n4、安装mariaDB数据库\nyum install -y mariadb mariadb-server\n5、创建数据库\nmysql -uroot -p mysql\u0026gt; create database zabbix character set utf8 collate utf8_bin;\n6、创建账户并授权\nmysql\u0026gt; grant all privileges on zabbix.* to zabbix@localhost identified by \u0026lsquo;zabbix\u0026rsquo;; mysql\u0026gt; quit;\n7、导入数据 (导入需要一点时间，不要以为卡住按ctrl+c停止)\nzcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -pzabbix zabbix\n8、修改Zabbix server配置文件\nvim /etc/zabbix/zabbix_server.conf DBPassword=zabbix\n9、为Zabbix前端配置PHP\nvim /etc/httpd/conf.d/zabbix.conf php_value date.timezone Asia/Shanghai\n10、关闭selinux\n永久关闭\nvim /etc/selinux/config SELINUX=disabled\n临时关闭\nsetenforce 0\n11、关闭防火墙\n永久关闭\nsystemctl disable firewalld.service\n临时关闭\nsystemctl stop firewalld.service\n12. 启动Zabbix server和httpd服务\n启动服务，并设置开机自启\nsystemctl restart zabbix-server httpd systemctl enable zabbix-server httpd\n13、配置Zabbix前端\n浏览器访问 http://server_ip/zabbix\n检查安装先决条件，必须所有项为OK 输入数据库密码，前面步骤已设置密码为zabbix\nName为可选项，它会显示在菜单栏和网页title上\n默认用户名为Admin，密码为zabbix\n14、设置中文语言\n点击右上角用户图标\n修改Language\n15、解决Zabbix中文乱码问题\n在windows系统上挑选一款中文字体\n先备份原有字体文件graphfont.ttf，再把字体文件名修改为graphfont.ttf\n拷贝到/usr/share/zabbix/fonts/ 目录下替换字体\n","permalink":"https://water711.github.io/posts/2019-03-02-rhel7-centos7%E5%AE%89%E8%A3%85zabbixnull/","tags":null,"title":"RHEL7/CentOS7 安装Zabbix"},{"categories":null,"contents":"一、通过web浏览器访问\n1、打开浏览器，在地址栏上输入IMM2的IP地址访问，打开登录页面后，输入用户名和密码 登录\nPS：第一次登录IMM2时，初始的用户名为USERID，密码为PASSW0RD(零，不是字母O)。在初始配置期间更改此用户名和密码，以增强安全性。\n二、通过IPMI 管理工具：IPMItool进行访问\nipmitool 是一种命令行方式的 ipmi 平台管理工具，通过它可以实现获取传感器的信息、显示系统日志内容、网络远程开关机等功能。\n一些英文简写：\nSDR：传感器数据库 sensor data repository\nBMC ：基板管理控制器 Baseboard Management Controller\nSEL : 系统事件日志 System Evelnt Log\nFRU : 可更换部件 Field Replaceable Unit linux下可以通过包管理工具安装，例如：yum install ipmitool -y\n常用命令：\nipmitool -U 用户名 -P 密码 -H IP地址 power off //关机（非正常关机）\nipmitool -U 用户名 -P 密码 -H IP地址 power on //开机\nipmitool -U 用户名 -P 密码 -H IP地址 sdr //打印传感器数据库条目\nipmitool -U 用户名 -P 密码 -H IP地址 sensor // 打印详细的传感器数据\nipmitool -U 用户名 -P 密码 -H IP地址 sensor get \u0026ldquo;CPU 1 Temp\u0026rdquo; //打印第1颗CPU的温度\nipmitool -U 用户名 -P 密码 -H IP地址 sensor get \u0026ldquo;Fan 2A Tach\u0026rdquo; //打印第2个风扇转速\nipmitool -U 用户名 -P 密码 -H IP地址 sensor get \u0026ldquo;CPU Utilization\u0026rdquo; //打印CPU利用率\nipmitool -U 用户名 -P 密码 -H IP地址 sensor get \u0026ldquo;Mem Utilization\u0026rdquo; //打印内存利用率\nipmitool -U 用户名 -P 密码 -H IP地址 sensor get \u0026ldquo;IO Utilization\u0026rdquo; //打印IO利用率\nipmitool -U 用户名 -P 密码 -H IP地址 sel list //打印系统事件日志\nipmitool -U 用户名 -P 密码 -H IP地址 fru list //打印可更换部件\n详细命令参数可查看README文档：https://github.com/ipmitool/ipmitool\n","permalink":"https://water711.github.io/posts/2019-02-24-%E8%AE%BF%E9%97%AEsystemx3650imm2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","tags":null,"title":"访问System x3650 IMM2的几种方式"},{"categories":null,"contents":"1、开启服务器。\n2、显示 Setup提示后，按 F1。（此提示在屏幕上仅显示几秒钟。必须迅速按 F1。）\n如果同时设置了开机密码和管理员密码，则必须输入管理员密码才能访问完整的 Setup Utility 菜单。\n3、在 Setup Utility 主菜单中，选择 System Settings。\n4、在下一屏幕中，选择 Integrated Management Module。\n5、在下一屏幕中，选择 Network Configuration。\n6、向下移动到DHCP Control，选择Static IP。\n7、输入管理接口的IP地址、掩码和网关\n8、向下移动到Save Network Settings\n9、退出Setup utility。\n","permalink":"https://water711.github.io/posts/2019-02-22-lenovosystemx3650%E8%AE%BE%E7%BD%AE%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80/","tags":null,"title":"Lenovo System x3650 设置管理接口地址"},{"categories":["linux"],"contents":"对于网站来说，发送各种例如注册通知的邮件是很基本的一个需求，之前我一直用的是腾讯的企业邮箱，感觉挺方便的，直接可以绑定QQ邮箱接收邮件，网站配置一下SMTP也就可以发出邮件。\n但是在前几天由于有重要信息需要立即通知用户，所以选择了群发邮件的方式。在当我以为一切都是辣么完美的时候，陆续有用户过来问我什么情况，我都会跟他们说请查收邮件，但是有好几个人说并没有任何邮件，于是我试着再发一次，结果返回了错误提示。在网上找了下原因，后来看到这个：各大免费邮箱邮件群发账户SMTP服务器配置及SMTP发送量限制情况，才知道是因为发信数量限制了。\n所以只好另寻出路了，然后我在知乎上面找到了很多个提供邮件发送的服务商，大概有这些：SendGrid、MailChimp、Amazon SES、SendCloud、Mailgun等等，在看了不少人的建议之后，我选择了Mailgun。\nMailgun注册和配置都挺简单，很快我就成功的发出了第一封邮件，怀着这封欣喜，我又发送了几封邮件，可是悲剧发生在第三封邮件，Mailgun后台有详细的发送记录，这个非常不错，在后台我看到我的邮件被拒收了，原因大概是该服务器IP的发信频率超过腾讯邮箱限制。所以这里就涉及到IP的问题，目前第三方的邮件发送服务普遍都是共享IP（后面还试过SendCloud、），而共享IP并不能确定是否已经达到接收方的数量限制，一旦达到了就无法再发送。这就是说还需要使用独立IP才能保证邮件有较高的到达率，接着就看了各家的独立IP价格，一般都是二十几甚至四十几美刀一个月，这对于我们这种小站长邮件需求不高的来说确实有点贵，买台VPS都不用这个价吧。\n经过上面这些折腾，也算明白了如果要想顺畅的发出邮件的话，除了花钱，就只有自己搭建一个邮件服务器了。\n好了，下面开始进入正题，教你搭建一个简单的邮件服务器。\n用于搭建的服务器信息 阿里云 Centos 6.5 32位\n安装过程 1.安装Postfix yum -y install postfix 安装完成还需要替换系统自带的sendmail：\nrpm -e sendmail 或者 yum remove sendmail 修改MTA（默认邮件传输代理）\nalternatives --config mta 然后直接回车即可。\n检查一下是不是已经设置成功了。\nalternatives --display mta 第一行可以看到mta的状态。 例如：mat - status is manual.\n2.安装Dovecot yum -y install dovecot 3.配置Postfix 编辑/etc/postfix/main.cf，可以下载下来修改，也可以使用vi进行编辑：\nvi /etc/postfix/main.cf 修改如下：\n# 75行: 取消注释，设置hostname myhostname = mail.lomu.me # 83行: 取消注释，设置域名 mydomain = lomu.me # 99行: 取消注释 myorigin = $mydomain # 116行: 修改 inet_interfaces = all # 119行: 推荐ipv4，如果支持ipv6，则可以为all inet_protocols = ipv4 # 164行: 添加 mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain # 264行: 取消注释，指定内网和本地的IP地址范围 mynetworks = 127.0.0.0/8, 10.0.0.0/24 # 419行: 取消注释，邮件保存目录 home_mailbox = Maildir/ # 571行: 添加 smtpd_banner = $myhostname ESMTP # 添加到最后 # 规定邮件最大尺寸为10M message_size_limit = 10485760 # 规定收件箱最大容量为1G mailbox_size_limit = 1073741824 # SMTP认证 smtpd_sasl_type = dovecot smtpd_sasl_path = private/auth smtpd_sasl_auth_enable = yes smtpd_sasl_security_options = noanonymous smtpd_sasl_local_domain = $myhostname smtpd_recipient_restrictions = permit_mynetworks,permit_auth_destination,permit_sasl_authenticated,reject 修改好了之后使用/etc/rc.d/init.d/postfix start开启postfix，使用chkconfig postfix on将postfix开机启动。\n4.配置Dovecot 修改如下：\n[root@mail ~]# vi /etc/dovecot/dovecot.conf # 26行: 如果不使用IPv6，请修改为* listen = * //修改第48行的允许登陆网段地址，全部允许即为（0.0.0.0/0）。 login_trusted_networks = 192.168.0.0/24\n[root@mail ~]# vi /etc/dovecot/conf.d/10-auth.conf # 9行: 取消注释并修改 disable_plaintext_auth = no # 97行: 添加 auth_mechanisms = plain login [root@mail ~]# vi /etc/dovecot/conf.d/10-mail.conf # 30行: 取消注释并添加 mail_location = maildir:~/Maildir [root@mail ~]# vi /etc/dovecot/conf.d/10-master.conf # 88-90行: 取消注释并添加 # Postfix smtp验证 unix_listener /var/spool/postfix/private/auth { mode = 0666 user = postfix group = postfix } [root@mail ~]# /etc/rc.d/init.d/dovecot start Starting Dovecot Imap: [ OK ] [root@mail ~]# chkconfig dovecot on 到这里，我们的邮件服务器就已经搭建成功了。\n5.域名解析 最后别忘了还需要进行域名解析工作。\n添加一个子域名mail，A记录解析到服务器IP。\n再添加一个MX记录，主机记录为空，记录值为上面解析的二级域名mail.lomu.me，优先级10。\n注意：解析生效可能需要一段时间。\n6.邮箱使用 一切都弄好以后，就可以使用Foxmail等第三方软件来收发邮件了。在这里需要说一下，系统用户就是邮件的用户，例如root，就是一个邮箱用户，邮箱是root@domain.com，密码就是root的密码，所以需要创建用户，只要使用useradd创建用户，再使用passwd设置密码。\n好了，假如我们创建一个admin的用户：\n# 创建用户 useradd admin #设置密码，会要求输入两次密码 passwd admin 接下来登录Foxmail，如图：\n点击创建，进入：\n这里需要注意，邮件账号是admin，并不是邮箱，另外我们没有配置SSL，所以也不要勾选。 接下来点击创建，如果一切正常的话，你已经成功了。\n后续 这篇文章已经完整的介绍了搭建一个简单邮件服务器的方法，但是在使用中还是会遇到很多问题，最大的问题莫过于经常被认定为垃圾邮件，所以还需要进行一些其他配置，例如：spf、dkim。\n","permalink":"https://water711.github.io/posts/2018-02-25-linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BApostfixdovecot/","tags":null,"title":"Linux系统下邮件服务器的搭建（Postfix+Dovecot）"},{"categories":["python"],"contents":"首先要安装三个模块：xlrd，xlwt，xlutils\n命令：pip install xlrd xlwt xlutils\n示例代码：\n#!/usr/bin/env python\n-*- coding:utf-8 -*- from xlrd import open_workbook from xlutils.copy import copy\n#读取excel文件 r_xls = open_workbook(\u0026ldquo;test.xls\u0026rdquo;)\n获取已有的行数 row = r_xls.sheets()[0].nrows\n将xlrd的对象转化为xlwt的对象 excel = copy(r_xls)\n获取要操作的sheet table = excel.get_sheet(0)\n#对excel表追加一行内容，括号内分别为行数、列数、内容 table.write(row, 0, \u0026lsquo;内容1\u0026rsquo;) table.write(row, 1, \u0026lsquo;内容2\u0026rsquo;) table.write(row, 2, \u0026lsquo;内容3\u0026rsquo;)\n#保存并覆盖文件 excel.save(\u0026ldquo;test.xls\u0026rdquo;)\n","permalink":"https://water711.github.io/posts/2018-02-02-python%E4%B9%8Bexcel%E6%96%87%E4%BB%B6%E8%BF%BD%E5%8A%A0%E5%86%85%E5%AE%B9/","tags":null,"title":"Python之excel文件追加内容"},{"categories":["python"],"contents":"面向对象基础 基础内容介绍详见一下两篇博文：\n面向对象初级篇 面向对象进阶篇 其他相关 一、isinstance(obj, cls)\n检查是否obj是否是类 cls 的对象\nclass Foo(object): pass\nobj = Foo()\nisinstance(obj, Foo)\n二、issubclass(sub, super)\n检查sub类是否是 super 类的派生类\nclass Foo(object): pass\nclass Bar(Foo): pass\nissubclass(Bar, Foo)\n三、异常处理\n1、异常基础\n在编程过程中为了增加友好性，在程序出现bug时一般不会将错误信息显示给用户，而是现实一个提示的页面，通俗来说就是不让用户看见大黄页！！！\ntry: pass except Exception,ex: pass\n需求：将用户输入的两个数字相加\nwhile True: num1 = raw_input(\u0026rsquo;num1:\u0026rsquo;) num2 = raw_input(\u0026rsquo;num2:\u0026rsquo;) try: num1 = int(num1) num2 = int(num2) result = num1 + num2 except Exception, e: print \u0026lsquo;出现异常，信息如下：\u0026rsquo; print e\nView Code\n2、异常种类\npython中的异常种类非常多，每个异常专门用于处理某一项异常！！！\nAttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x IOError 输入/输出异常；基本上是无法打开文件 ImportError 无法引入模块或包；基本上是路径问题或名称错误 IndentationError 语法错误（的子类） ；代码没有正确对齐 IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5] KeyError 试图访问字典里不存在的键 KeyboardInterrupt Ctrl+C被按下 NameError 使用一个还未被赋予对象的变量 SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了） TypeError 传入对象类型与要求的不符合 UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量， 导致你以为正在访问它 ValueError 传入一个调用者不期望的值，即使值的类型是正确的\n常用异常\nArithmeticError AssertionError AttributeError BaseException BufferError BytesWarning DeprecationWarning EnvironmentError EOFError Exception FloatingPointError FutureWarning GeneratorExit ImportError ImportWarning IndentationError IndexError IOError KeyboardInterrupt KeyError LookupError MemoryError NameError NotImplementedError OSError OverflowError PendingDeprecationWarning ReferenceError RuntimeError RuntimeWarning StandardError StopIteration SyntaxError SyntaxWarning SystemError SystemExit TabError TypeError UnboundLocalError UnicodeDecodeError UnicodeEncodeError UnicodeError UnicodeTranslateError UnicodeWarning UserWarning ValueError Warning ZeroDivisionError\n更多异常\ndic = [\u0026ldquo;wupeiqi\u0026rdquo;, \u0026lsquo;alex\u0026rsquo;] try: dic[10] except IndexError, e: print e\n实例：IndexError\ndic = {\u0026lsquo;k1\u0026rsquo;:\u0026lsquo;v1\u0026rsquo;} try: dic[\u0026lsquo;k20\u0026rsquo;] except KeyError, e: print e\n实例：KeyError\ns1 = \u0026lsquo;hello\u0026rsquo; try: int(s1) except ValueError, e: print e\n实例：ValueError\n对于上述实例，异常类只能用来处理指定的异常情况，如果非指定异常则无法处理。\n# 未捕获到异常，程序直接报错\ns1 = \u0026lsquo;hello\u0026rsquo; try: int(s1) except IndexError,e: print e\n所以，写程序时需要考虑到try代码块中可能出现的任意异常，可以这样写：\ns1 = \u0026lsquo;hello\u0026rsquo; try: int(s1) except IndexError,e: print e except KeyError,e: print e except ValueError,e: print e\n万能异常 在python的异常中，有一个万能异常：Exception，他可以捕获任意异常，即：\ns1 = \u0026lsquo;hello\u0026rsquo; try: int(s1) except Exception,e: print e\n接下来你可能要问了，既然有这个万能异常，其他异常是不是就可以忽略了！\n答：当然不是，对于特殊处理或提醒的异常需要先定义，最后定义Exception来确保程序正常运行。\ns1 = \u0026lsquo;hello\u0026rsquo; try: int(s1) except KeyError,e: print \u0026lsquo;键错误\u0026rsquo; except IndexError,e: print \u0026lsquo;索引错误\u0026rsquo; except Exception, e: print \u0026lsquo;错误\u0026rsquo;\n3、异常其他结构\ntry: # 主代码块 pass except KeyError,e: # 异常时，执行该块 pass else: # 主代码块执行完，执行该块 pass finally: # 无论异常与否，最终执行该块 pass\n4、主动触发异常\ntry: raise Exception(\u0026lsquo;错误了。。。\u0026rsquo;) except Exception,e: print e\n5、自定义异常\nclass WupeiqiException(Exception):\ndef \\_\\_init\\_\\_(self, msg): self.message = msg def \\_\\_str\\_\\_(self): return self.message try: raise WupeiqiException(\u0026lsquo;我的异常\u0026rsquo;) except WupeiqiException,e: print e\n6、断言\n# assert 条件\nassert 1 == 1\nassert 1 == 2\n四、反射\npython中的反射功能是由以下四个内置函数提供：hasattr、getattr、setattr、delattr，改四个函数分别用于对对象内部执行：检查是否含有某成员、获取成员、设置成员、删除成员。\nclass Foo(object):\ndef \\_\\_init\\_\\_(self): self.name = 'wupeiqi' def func(self): return 'func' obj = Foo()\n#### 检查是否含有成员 hasattr(obj, \u0026rsquo;name\u0026rsquo;) hasattr(obj, \u0026lsquo;func\u0026rsquo;)\n#### 获取成员 getattr(obj, \u0026rsquo;name\u0026rsquo;) getattr(obj, \u0026lsquo;func\u0026rsquo;)\n#### 设置成员 setattr(obj, \u0026lsquo;age\u0026rsquo;, 18) setattr(obj, \u0026lsquo;show\u0026rsquo;, lambda num: num + 1)\n#### 删除成员 delattr(obj, \u0026rsquo;name\u0026rsquo;) delattr(obj, \u0026lsquo;func\u0026rsquo;)\n详细解析：\n当我们要访问一个对象的成员时，应该是这样操作：\nclass Foo(object):\ndef \\_\\_init\\_\\_(self): self.name = 'alex' def func(self): return 'func' obj = Foo()\n访问字段 obj.name\n执行方法 obj.func()\n那么问题来了？\na、上述访问对象成员的 name 和 func 是什么？ 答：是变量名\nb、obj.xxx 是什么意思？ 答：obj.xxx 表示去obj中或类中寻找变量名 xxx，并获取对应内存地址中的内容。\nc、需求：请使用其他方式获取obj对象中的name变量指向内存中的值 “alex”\nclass Foo(object): def __init__(self): self.name = \u0026lsquo;alex\u0026rsquo;\n不允许使用 obj.name obj = Foo()\nView Code\n答：有两种方式，如下：\nclass Foo(object): def __init__(self): self.name = \u0026lsquo;alex\u0026rsquo;\ndef func(self): return 'func' 不允许使用 obj.name obj = Foo() print obj.__dict__[\u0026rsquo;name\u0026rsquo;]\n方式一\nclass Foo(object): def __init__(self): self.name = \u0026lsquo;alex\u0026rsquo;\ndef func(self): return 'func' 不允许使用 obj.name obj = Foo() print getattr(obj, \u0026rsquo;name\u0026rsquo;)\n方式二\nd、比较三种访问方式\nobj.name obj.__dict__[\u0026rsquo;name\u0026rsquo;] getattr(obj, \u0026rsquo;name\u0026rsquo;) 答：第一种和其他种比，\u0026hellip;\n第二种和第三种比，\u0026hellip;\n#!/usr/bin/env python #coding:utf-8 from wsgiref.simple_server import make_server class Handler(object): def index(self): return \u0026lsquo;index\u0026rsquo;\ndef news(self): return 'news' def RunServer(environ, start_response): start_response(\u0026lsquo;200 OK\u0026rsquo;, [(\u0026lsquo;Content-Type\u0026rsquo;, \u0026rsquo;text/html\u0026rsquo;)]) url = environ[\u0026lsquo;PATH_INFO\u0026rsquo;] temp = url.split(\u0026rsquo;/\u0026rsquo;)[1] obj = Handler() is_exist = hasattr(obj, temp) if is_exist: func = getattr(obj, temp) ret = func() return ret else: return \u0026lsquo;404 not found\u0026rsquo;\nif __name__ == \u0026lsquo;__main__\u0026rsquo;: httpd = make_server(\u0026rsquo;\u0026rsquo;, 8001, RunServer) print \u0026ldquo;Serving HTTP on port 8000\u0026hellip;\u0026rdquo; httpd.serve_forever()\nWeb框架实例\n**结论：**反射是通过字符串的形式操作对象相关的成员。一切事物都是对象！！！\n#!/usr/bin/env python # -*- coding:utf-8 -*-\nimport sys def s1(): print \u0026lsquo;s1\u0026rsquo;\ndef s2(): print \u0026lsquo;s2\u0026rsquo; this_module = sys.modules[__name__]\nhasattr(this_module, \u0026lsquo;s1\u0026rsquo;) getattr(this_module, \u0026lsquo;s2\u0026rsquo;)\n反射当前模块成员\n类也是对象\nclass Foo(object):\nstaticField = \u0026quot;old boy\u0026quot; def \\_\\_init\\_\\_(self): self.name = 'wupeiqi' def func(self): return 'func' @staticmethod def bar(): return 'bar' print getattr(Foo, \u0026lsquo;staticField\u0026rsquo;) print getattr(Foo, \u0026lsquo;func\u0026rsquo;) print getattr(Foo, \u0026lsquo;bar\u0026rsquo;)\n模块也是对象\n#!/usr/bin/env python # -*- coding:utf-8 -*-\ndef dev(): return \u0026lsquo;dev\u0026rsquo;\nhome.py\n#!/usr/bin/env python\n-*- coding:utf-8 -*- \u0026quot;\u0026quot;\u0026quot; 程序目录： home.py index.py\n当前文件： index.py \u0026quot;\u0026quot;\u0026quot;\nimport home as obj\n#obj.dev()\nfunc = getattr(obj, \u0026lsquo;dev\u0026rsquo;) func() 设计模式 一、单例模式\n单例，顾名思义单个实例。\n学习单例之前，首先来回顾下面向对象的内容：\npython的面向对象由两个非常重要的两个“东西”组成：类、实例\n面向对象场景一：\n如：创建三个游戏人物，分别是：\n苍井井，女，18，初始战斗力1000 东尼木木，男，20，初始战斗力1800 波多多，女，19，初始战斗力2500 ##################### 定义类 class Person: def __init__(self, na, gen, age, fig): self.name = na self.gender = gen self.age = age self.fight =fig def grassland(self): \u0026ldquo;\u0026ldquo;\u0026ldquo;注释：草丛战斗，消耗200战斗力\u0026rdquo;\u0026rdquo;\u0026rdquo; self.fight = self.fight - 200\n##################### 创建实例 cang = Person(\u0026lsquo;苍井井\u0026rsquo;, \u0026lsquo;女\u0026rsquo;, 18, 1000) # 创建苍井井角色 dong = Person(\u0026lsquo;东尼木木\u0026rsquo;, \u0026lsquo;男\u0026rsquo;, 20, 1800) # 创建东尼木木角色 bo = Person(\u0026lsquo;波多多\u0026rsquo;, \u0026lsquo;女\u0026rsquo;, 19, 2500) # 创建波多多角色\nView Code\n面向对象场景二：\n如：创建对数据库操作的公共类\n增 删 改 查 #### 定义类 class DbHelper(object): def __init__(self): self.hostname = \u0026lsquo;1.1.1.1\u0026rsquo; self.port = 3306 self.password = \u0026lsquo;pwd\u0026rsquo; self.username = \u0026lsquo;root\u0026rsquo;\ndef fetch(self): # 连接数据库 # 拼接sql语句 # 操作 pass def create(self): # 连接数据库 # 拼接sql语句 # 操作 pass def remove(self): # 连接数据库 # 拼接sql语句 # 操作 pass def modify(self): # 连接数据库 # 拼接sql语句 # 操作 pass #### 操作类 db = DbHelper() db.create()\nView Code\n**实例：**结合场景二实现Web应用程序\n#!/usr/bin/env python #coding:utf-8 from wsgiref.simple_server import make_server class DbHelper(object): def __init__(self): self.hostname = \u0026lsquo;1.1.1.1\u0026rsquo; self.port = 3306 self.password = \u0026lsquo;pwd\u0026rsquo; self.username = \u0026lsquo;root\u0026rsquo;\ndef fetch(self): # 连接数据库 # 拼接sql语句 # 操作 return 'fetch' def create(self): # 连接数据库 # 拼接sql语句 # 操作 return 'create' def remove(self): # 连接数据库 # 拼接sql语句 # 操作 return 'remove' def modify(self): # 连接数据库 # 拼接sql语句 # 操作 return 'modify' class Handler(object): def index(self): # 创建对象 db = DbHelper() db.fetch() return \u0026lsquo;index\u0026rsquo;\ndef news(self): return 'news' def RunServer(environ, start_response): start_response(\u0026lsquo;200 OK\u0026rsquo;, [(\u0026lsquo;Content-Type\u0026rsquo;, \u0026rsquo;text/html\u0026rsquo;)]) url = environ[\u0026lsquo;PATH_INFO\u0026rsquo;] temp = url.split(\u0026rsquo;/\u0026rsquo;)[1] obj = Handler() is_exist = hasattr(obj, temp) if is_exist: func = getattr(obj, temp) ret = func() return ret else: return \u0026lsquo;404 not found\u0026rsquo;\nif __name__ == \u0026lsquo;__main__\u0026rsquo;: httpd = make_server(\u0026rsquo;\u0026rsquo;, 8001, RunServer) print \u0026ldquo;Serving HTTP on port 8001\u0026hellip;\u0026rdquo; httpd.serve_forever()\nWeb应用程序实例\n对于上述实例，每个请求到来，都需要在内存里创建一个实例，再通过该实例执行指定的方法。\n那么问题来了\u0026hellip;如果并发量大的话，内存里就会存在非常多功能上一模一样的对象。存在这些对象肯定会消耗内存，对于这些功能相同的对象可以在内存中仅创建一个，需要时都去调用，也是极好的！！！\n铛铛 铛铛 铛铛铛铛铛，单例模式出马，单例模式用来保证内存中仅存在一个实例！！！\n通过面向对象的特性，构造出单例模式：\n# ########### 单例类定义 ########### class Foo(object):\n\\_\\_instance = None @staticmethod def singleton(): if Foo.\\_\\_instance: return Foo.\\_\\_instance else: Foo.\\_\\_instance = Foo() return Foo.\\_\\_instance ########### 获取实例 obj = Foo.singleton()\n对于Python单例模式，创建对象时不能再直接使用：obj = Foo()，而应该调用特殊的方法：obj = Foo.singleton() 。\n#!/usr/bin/env python #coding:utf-8 from wsgiref.simple_server import make_server # ########### 单例类定义 ########### class DbHelper(object): __instance = None def __init__(self): self.hostname = \u0026lsquo;1.1.1.1\u0026rsquo; self.port = 3306 self.password = \u0026lsquo;pwd\u0026rsquo; self.username = \u0026lsquo;root\u0026rsquo; @staticmethod def singleton(): if DbHelper.__instance: return DbHelper.__instance else: DbHelper.__instance = DbHelper() return DbHelper.__instance\ndef fetch(self): # 连接数据库 # 拼接sql语句 # 操作 pass def create(self): # 连接数据库 # 拼接sql语句 # 操作 pass def remove(self): # 连接数据库 # 拼接sql语句 # 操作 pass def modify(self): # 连接数据库 # 拼接sql语句 # 操作 pass class Handler(object): def index(self): obj = DbHelper.singleton() print id(single) obj.create() return \u0026lsquo;index\u0026rsquo;\ndef news(self): return 'news' def RunServer(environ, start_response): start_response(\u0026lsquo;200 OK\u0026rsquo;, [(\u0026lsquo;Content-Type\u0026rsquo;, \u0026rsquo;text/html\u0026rsquo;)]) url = environ[\u0026lsquo;PATH_INFO\u0026rsquo;] temp = url.split(\u0026rsquo;/\u0026rsquo;)[1] obj = Handler() is_exist = hasattr(obj, temp) if is_exist: func = getattr(obj, temp) ret = func() return ret else: return \u0026lsquo;404 not found\u0026rsquo;\nif __name__ == \u0026lsquo;__main__\u0026rsquo;: httpd = make_server(\u0026rsquo;\u0026rsquo;, 8001, RunServer) print \u0026ldquo;Serving HTTP on port 8001\u0026hellip;\u0026rdquo; httpd.serve_forever()\nWeb应用实例-单例模式\n总结：单利模式存在的目的是保证当前内存中仅存在单个实例，避免内存浪费！！！\n","permalink":"https://water711.github.io/posts/2017-04-11-python%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%83%E7%AF%87%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","tags":null,"title":"Python开发【第七篇】：面向对象"},{"categories":["python"],"contents":"运算符 1、算数运算：\n2、比较运算：\n3、赋值运算：\n4、逻辑运算：\n5、成员运算：\n基本数据类型 1、数字\nint（整型）\n在32位机器上，整数的位数为32位，取值范围为-2**31～2**31-1，即-2147483648～2147483647\n在64位系统上，整数的位数为64位，取值范围为-2**63～2**63-1，即-9223372036854775808～9223372036854775807\nclass int(object): \u0026quot;\u0026quot;\u0026quot; int(x=0) -\u0026gt; int or long int(x, base=10) -\u0026gt; int or long\nConvert a number or string to an integer, or return 0 if no arguments are given. If x is floating point, the conversion truncates towards zero. If x is outside the integer range, the function returns a long instead. If x is not a number or if base is given, then x must be a string or Unicode object representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. \u0026gt;\u0026gt;\u0026gt; int('0b100', base=0) 4 \u0026quot;\u0026quot;\u0026quot; def bit\\_length(self): \u0026quot;\u0026quot;\u0026quot; 返回表示该数字的时占用的最少位数 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; int.bit\\_length() -\u0026gt; int Number of bits necessary to represent self in binary. \u0026gt;\u0026gt;\u0026gt; bin(37) '0b100101' \u0026gt;\u0026gt;\u0026gt; (37).bit\\_length() 6 \u0026quot;\u0026quot;\u0026quot; return 0 def conjugate(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; 返回该复数的共轭复数 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; Returns self, the complex conjugate of any int. \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_abs\\_\\_(self): \u0026quot;\u0026quot;\u0026quot; 返回绝对值 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; x.\\_\\_abs\\_\\_() \u0026lt;==\u0026gt; abs(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_add\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_add\\_\\_(y) \u0026lt;==\u0026gt; x+y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_and\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_and\\_\\_(y) \u0026lt;==\u0026gt; x\u0026amp;y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_cmp\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; 比较两个数大小 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; x.\\_\\_cmp\\_\\_(y) \u0026lt;==\u0026gt; cmp(x,y) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_coerce\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; 强制生成一个元组 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; x.\\_\\_coerce\\_\\_(y) \u0026lt;==\u0026gt; coerce(x, y) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_divmod\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; 相除，得到商和余数组成的元组 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; x.\\_\\_divmod\\_\\_(y) \u0026lt;==\u0026gt; divmod(x, y) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_div\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_div\\_\\_(y) \u0026lt;==\u0026gt; x/y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_float\\_\\_(self): \u0026quot;\u0026quot;\u0026quot; 转换为浮点类型 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; x.\\_\\_float\\_\\_() \u0026lt;==\u0026gt; float(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_floordiv\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_floordiv\\_\\_(y) \u0026lt;==\u0026gt; x//y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_format\\_\\_(self, \\*args, \\*\\*kwargs): # real signature unknown pass def \\_\\_getattribute\\_\\_(self, name): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_getattribute\\_\\_('name') \u0026lt;==\u0026gt; x.name \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_getnewargs\\_\\_(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; 内部调用 \\_\\_new\\_\\_方法或创建对象时传入参数使用 \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_hash\\_\\_(self): \u0026quot;\u0026quot;\u0026quot;如果对象object为哈希表类型，返回对象object的哈希值。哈希值为整数。在字典查找中，哈希值用于快速比较字典的键。两个数值如果相等，则哈希值也相等。\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; x.\\_\\_hash\\_\\_() \u0026lt;==\u0026gt; hash(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_hex\\_\\_(self): \u0026quot;\u0026quot;\u0026quot; 返回当前数的 十六进制 表示 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; x.\\_\\_hex\\_\\_() \u0026lt;==\u0026gt; hex(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_index\\_\\_(self): \u0026quot;\u0026quot;\u0026quot; 用于切片，数字无意义 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; x\\[y:z\\] \u0026lt;==\u0026gt; x\\[y.\\_\\_index\\_\\_():z.\\_\\_index\\_\\_()\\] \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_init\\_\\_(self, x, base=10): # known special case of int.\\_\\_init\\_\\_ \u0026quot;\u0026quot;\u0026quot; 构造方法，执行 x = 123 或 x = int(10) 时，自动调用，暂时忽略 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; int(x=0) -\u0026gt; int or long int(x, base=10) -\u0026gt; int or long Convert a number or string to an integer, or return 0 if no arguments are given. If x is floating point, the conversion truncates towards zero. If x is outside the integer range, the function returns a long instead. If x is not a number or if base is given, then x must be a string or Unicode object representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. \u0026gt;\u0026gt;\u0026gt; int('0b100', base=0) 4 # (copied from class doc) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_int\\_\\_(self): \u0026quot;\u0026quot;\u0026quot; 转换为整数 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; x.\\_\\_int\\_\\_() \u0026lt;==\u0026gt; int(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_invert\\_\\_(self): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_invert\\_\\_() \u0026lt;==\u0026gt; ~x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_long\\_\\_(self): \u0026quot;\u0026quot;\u0026quot; 转换为长整数 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; x.\\_\\_long\\_\\_() \u0026lt;==\u0026gt; long(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_lshift\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_lshift\\_\\_(y) \u0026lt;==\u0026gt; x\u0026lt;\u0026quot;\u0026quot;\u0026quot; pass def \\_\\_mod\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_mod\\_\\_(y) \u0026lt;==\u0026gt; x%y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_mul\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_mul\\_\\_(y) \u0026lt;==\u0026gt; x\\*y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_neg\\_\\_(self): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_neg\\_\\_() \u0026lt;==\u0026gt; -x \u0026quot;\u0026quot;\u0026quot; pass @staticmethod # known case of \\_\\_new\\_\\_ def \\_\\_new\\_\\_(S, \\*more): \u0026quot;\u0026quot;\u0026quot; T.\\_\\_new\\_\\_(S, ...) -\u0026gt; a new object with type S, a subtype of T \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_nonzero\\_\\_(self): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_nonzero\\_\\_() \u0026lt;==\u0026gt; x != 0 \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_oct\\_\\_(self): \u0026quot;\u0026quot;\u0026quot; 返回改值的 八进制 表示 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; x.\\_\\_oct\\_\\_() \u0026lt;==\u0026gt; oct(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_or\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_or\\_\\_(y) \u0026lt;==\u0026gt; x|y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_pos\\_\\_(self): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_pos\\_\\_() \u0026lt;==\u0026gt; +x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_pow\\_\\_(self, y, z=None): \u0026quot;\u0026quot;\u0026quot; 幂，次方 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; x.\\_\\_pow\\_\\_(y\\[, z\\]) \u0026lt;==\u0026gt; pow(x, y\\[, z\\]) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_radd\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_radd\\_\\_(y) \u0026lt;==\u0026gt; y+x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rand\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_rand\\_\\_(y) \u0026lt;==\u0026gt; y\u0026amp;x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rdivmod\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_rdivmod\\_\\_(y) \u0026lt;==\u0026gt; divmod(y, x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rdiv\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_rdiv\\_\\_(y) \u0026lt;==\u0026gt; y/x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_repr\\_\\_(self): \u0026quot;\u0026quot;\u0026quot;转化为解释器可读取的形式 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; x.\\_\\_repr\\_\\_() \u0026lt;==\u0026gt; repr(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_str\\_\\_(self): \u0026quot;\u0026quot;\u0026quot;转换为人阅读的形式，如果没有适于人阅读的解释形式的话，则返回解释器课阅读的形式\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; x.\\_\\_str\\_\\_() \u0026lt;==\u0026gt; str(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rfloordiv\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_rfloordiv\\_\\_(y) \u0026lt;==\u0026gt; y//x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rlshift\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_rlshift\\_\\_(y) \u0026lt;==\u0026gt; y\u0026lt;\u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rmod\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_rmod\\_\\_(y) \u0026lt;==\u0026gt; y%x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rmul\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_rmul\\_\\_(y) \u0026lt;==\u0026gt; y\\*x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_ror\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_ror\\_\\_(y) \u0026lt;==\u0026gt; y|x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rpow\\_\\_(self, x, z=None): \u0026quot;\u0026quot;\u0026quot; y.\\_\\_rpow\\_\\_(x\\[, z\\]) \u0026lt;==\u0026gt; pow(x, y\\[, z\\]) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rrshift\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_rrshift\\_\\_(y) \u0026lt;==\u0026gt; y\u0026gt;\u0026gt;x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rshift\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_rshift\\_\\_(y) \u0026lt;==\u0026gt; x\u0026gt;\u0026gt;y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rsub\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_rsub\\_\\_(y) \u0026lt;==\u0026gt; y-x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rtruediv\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_rtruediv\\_\\_(y) \u0026lt;==\u0026gt; y/x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rxor\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_rxor\\_\\_(y) \u0026lt;==\u0026gt; y^x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_sub\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_sub\\_\\_(y) \u0026lt;==\u0026gt; x-y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_truediv\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_truediv\\_\\_(y) \u0026lt;==\u0026gt; x/y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_trunc\\_\\_(self, \\*args, \\*\\*kwargs): \u0026quot;\u0026quot;\u0026quot; 返回数值被截取为整形的值，在整形中无意义 \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_xor\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_xor\\_\\_(y) \u0026lt;==\u0026gt; x^y \u0026quot;\u0026quot;\u0026quot; pass denominator \\= property(lambda self: object(), lambda self, v: None, lambda self: None) # default \u0026quot;\u0026quot;\u0026quot; 分母 = 1 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;the denominator of a rational number in lowest terms\u0026quot;\u0026quot;\u0026quot; imag \\= property(lambda self: object(), lambda self, v: None, lambda self: None) # default \u0026quot;\u0026quot;\u0026quot; 虚数，无意义 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;the imaginary part of a complex number\u0026quot;\u0026quot;\u0026quot; numerator \\= property(lambda self: object(), lambda self, v: None, lambda self: None) # default \u0026quot;\u0026quot;\u0026quot; 分子 = 数字大小 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;the numerator of a rational number in lowest terms\u0026quot;\u0026quot;\u0026quot; real \\= property(lambda self: object(), lambda self, v: None, lambda self: None) # default \u0026quot;\u0026quot;\u0026quot; 实属，无意义 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;the real part of a complex number\u0026quot;\u0026quot;\u0026quot; int\n2、布尔值\n真或假\n1 或 0\n3、字符串\n\u0026ldquo;hello world\u0026rdquo;\n字符串常用功能：\n移除空白 分割 长度 索引 切片 class str(basestring): \u0026quot;\u0026quot;\u0026quot; str(object=\u0026rsquo;\u0026rsquo;) -\u0026gt; string\nReturn a nice string representation of the object. If the argument is a string, the return value is the same object. \u0026quot;\u0026quot;\u0026quot; def capitalize(self): \u0026quot;\u0026quot;\u0026quot; 首字母变大写 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.capitalize() -\u0026gt; string Return a copy of the string S with only its first character capitalized. \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def center(self, width, fillchar=None): \u0026quot;\u0026quot;\u0026quot; 内容居中，width：总长度；fillchar：空白处填充内容，默认无 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.center(width\\[, fillchar\\]) -\u0026gt; string Return S centered in a string of length width. Padding is done using the specified fill character (default is a space) \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def count(self, sub, start=None, end=None): \u0026quot;\u0026quot;\u0026quot; 子序列个数 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.count(sub\\[, start\\[, end\\]\\]) -\u0026gt; int Return the number of non-overlapping occurrences of substring sub in string S\\[start:end\\]. Optional arguments start and end are interpreted as in slice notation. \u0026quot;\u0026quot;\u0026quot; return 0 def decode(self, encoding=None, errors=None): \u0026quot;\u0026quot;\u0026quot; 解码 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.decode(\\[encoding\\[,errors\\]\\]) -\u0026gt; object Decodes S using the codec registered for encoding. encoding defaults to the default encoding. errors may be given to set a different error handling scheme. Default is 'strict' meaning that encoding errors raise a UnicodeDecodeError. Other possible values are 'ignore' and 'replace' as well as any other name registered with codecs.register\\_error that is able to handle UnicodeDecodeErrors. \u0026quot;\u0026quot;\u0026quot; return object() def encode(self, encoding=None, errors=None): \u0026quot;\u0026quot;\u0026quot; 编码，针对unicode \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.encode(\\[encoding\\[,errors\\]\\]) -\u0026gt; object Encodes S using the codec registered for encoding. encoding defaults to the default encoding. errors may be given to set a different error handling scheme. Default is 'strict' meaning that encoding errors raise a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and 'xmlcharrefreplace' as well as any other name registered with codecs.register\\_error that is able to handle UnicodeEncodeErrors. \u0026quot;\u0026quot;\u0026quot; return object() def endswith(self, suffix, start=None, end=None): \u0026quot;\u0026quot;\u0026quot; 是否以 xxx 结束 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.endswith(suffix\\[, start\\[, end\\]\\]) -\u0026gt; bool Return True if S ends with the specified suffix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. suffix can also be a tuple of strings to try. \u0026quot;\u0026quot;\u0026quot; return False def expandtabs(self, tabsize=None): \u0026quot;\u0026quot;\u0026quot; 将tab转换成空格，默认一个tab转换成8个空格 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.expandtabs(\\[tabsize\\]) -\u0026gt; string Return a copy of S where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed. \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def find(self, sub, start=None, end=None): \u0026quot;\u0026quot;\u0026quot; 寻找子序列位置，如果没找到，返回 -1 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.find(sub \\[,start \\[,end\\]\\]) -\u0026gt; int Return the lowest index in S where substring sub is found, such that sub is contained within S\\[start:end\\]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. \u0026quot;\u0026quot;\u0026quot; return 0 def format(\\*args, \\*\\*kwargs): # known special case of str.format \u0026quot;\u0026quot;\u0026quot; 字符串格式化，动态参数，将函数式编程时细说 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.format(\\*args, \\*\\*kwargs) -\u0026gt; string Return a formatted version of S, using substitutions from args and kwargs. The substitutions are identified by braces ('{' and '}'). \u0026quot;\u0026quot;\u0026quot; pass def index(self, sub, start=None, end=None): \u0026quot;\u0026quot;\u0026quot; 子序列位置，如果没找到，报错 \u0026quot;\u0026quot;\u0026quot; S.index(sub \\[,start \\[,end\\]\\]) \\-\u0026gt; int Like S.find() but raise ValueError when the substring is not found. \u0026quot;\u0026quot;\u0026quot; return 0 def isalnum(self): \u0026quot;\u0026quot;\u0026quot; 是否是字母和数字 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.isalnum() \\-\u0026gt; bool Return True if all characters in S are alphanumeric and there is at least one character in S, False otherwise. \u0026quot;\u0026quot;\u0026quot; return False def isalpha(self): \u0026quot;\u0026quot;\u0026quot; 是否是字母 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.isalpha() \\-\u0026gt; bool Return True if all characters in S are alphabetic and there is at least one character in S, False otherwise. \u0026quot;\u0026quot;\u0026quot; return False def isdigit(self): \u0026quot;\u0026quot;\u0026quot; 是否是数字 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.isdigit() \\-\u0026gt; bool Return True if all characters in S are digits and there is at least one character in S, False otherwise. \u0026quot;\u0026quot;\u0026quot; return False def islower(self): \u0026quot;\u0026quot;\u0026quot; 是否小写 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.islower() \\-\u0026gt; bool Return True if all cased characters in S are lowercase and there is at least one cased character in S, False otherwise. \u0026quot;\u0026quot;\u0026quot; return False def isspace(self): \u0026quot;\u0026quot;\u0026quot; S.isspace() \\-\u0026gt; bool Return True if all characters in S are whitespace and there is at least one character in S, False otherwise. \u0026quot;\u0026quot;\u0026quot; return False def istitle(self): \u0026quot;\u0026quot;\u0026quot; S.istitle() \\-\u0026gt; bool Return True if S is a titlecased string and there is at least one character in S, i.e. uppercase characters may only follow uncased characters and lowercase characters only cased ones. Return False otherwise. \u0026quot;\u0026quot;\u0026quot; return False def isupper(self): \u0026quot;\u0026quot;\u0026quot; S.isupper() \\-\u0026gt; bool Return True if all cased characters in S are uppercase and there is at least one cased character in S, False otherwise. \u0026quot;\u0026quot;\u0026quot; return False def join(self, iterable): \u0026quot;\u0026quot;\u0026quot; 连接 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.join(iterable) \\-\u0026gt; string Return a string which is the concatenation of the strings in the iterable. The separator between elements is S. \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def ljust(self, width, fillchar=None): \u0026quot;\u0026quot;\u0026quot; 内容左对齐，右侧填充 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.ljust(width\\[, fillchar\\]) \\-\u0026gt; string Return S left\\-justified in a string of length width. Padding is done using the specified fill character (default is a space). \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def lower(self): \u0026quot;\u0026quot;\u0026quot; 变小写 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.lower() \\-\u0026gt; string Return a copy of the string S converted to lowercase. \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def lstrip(self, chars=None): \u0026quot;\u0026quot;\u0026quot; 移除左侧空白 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.lstrip(\\[chars\\]) \\-\u0026gt; string or unicode Return a copy of the string S with leading whitespace removed. If chars is given and not None, remove characters in chars instead. If chars is unicode, S will be converted to unicode before stripping \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def partition(self, sep): \u0026quot;\u0026quot;\u0026quot; 分割，前，中，后三部分 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.partition(sep) \\-\u0026gt; (head, sep, tail) Search for the separator sep in S, and return the part before it, the separator itself, and the part after it. If the separator is not found, return S and two empty strings. \u0026quot;\u0026quot;\u0026quot; pass def replace(self, old, new, count=None): \u0026quot;\u0026quot;\u0026quot; 替换 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.replace(old, new\\[, count\\]) \\-\u0026gt; string Return a copy of string S with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def rfind(self, sub, start=None, end=None): \u0026quot;\u0026quot;\u0026quot; S.rfind(sub \\[,start \\[,end\\]\\]) \\-\u0026gt; int Return the highest index in S where substring sub is found, such that sub is contained within S\\[start:end\\]. Optional arguments start and end are interpreted as in slice notation. Return \\-1 on failure. \u0026quot;\u0026quot;\u0026quot; return 0 def rindex(self, sub, start=None, end=None): \u0026quot;\u0026quot;\u0026quot; S.rindex(sub \\[,start \\[,end\\]\\]) \\-\u0026gt; int Like S.rfind() but raise ValueError when the substring is not found. \u0026quot;\u0026quot;\u0026quot; return 0 def rjust(self, width, fillchar=None): \u0026quot;\u0026quot;\u0026quot; S.rjust(width\\[, fillchar\\]) \\-\u0026gt; string Return S right\\-justified in a string of length width. Padding is done using the specified fill character (default is a space) \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def rpartition(self, sep): \u0026quot;\u0026quot;\u0026quot; S.rpartition(sep) \\-\u0026gt; (head, sep, tail) Search for the separator sep in S, starting at the end of S, and return the part before it, the separator itself, and the part after it. If the separator is not found, return two empty strings and S. \u0026quot;\u0026quot;\u0026quot; pass def rsplit(self, sep=None, maxsplit=None): \u0026quot;\u0026quot;\u0026quot; S.rsplit(\\[sep \\[,maxsplit\\]\\]) \\-\u0026gt; list of strings Return a list of the words in the string S, using sep as the delimiter string, starting at the end of the string and working to the front. If maxsplit is given, at most maxsplit splits are done. If sep is not specified or is None, any whitespace string is a separator. \u0026quot;\u0026quot;\u0026quot; return \\[\\] def rstrip(self, chars=None): \u0026quot;\u0026quot;\u0026quot; S.rstrip(\\[chars\\]) \\-\u0026gt; string or unicode Return a copy of the string S with trailing whitespace removed. If chars is given and not None, remove characters in chars instead. If chars is unicode, S will be converted to unicode before stripping \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def split(self, sep=None, maxsplit=None): \u0026quot;\u0026quot;\u0026quot; 分割， maxsplit最多分割几次 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.split(\\[sep \\[,maxsplit\\]\\]) \\-\u0026gt; list of strings Return a list of the words in the string S, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done. If sep is not specified or is None, any whitespace string is a separator and empty strings are removed from the result. \u0026quot;\u0026quot;\u0026quot; return \\[\\] def splitlines(self, keepends=False): \u0026quot;\u0026quot;\u0026quot; 根据换行分割 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.splitlines(keepends\\=False) -\u0026gt; list of strings Return a list of the lines in S, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true. \u0026quot;\u0026quot;\u0026quot; return \\[\\] def startswith(self, prefix, start=None, end=None): \u0026quot;\u0026quot;\u0026quot; 是否起始 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.startswith(prefix\\[, start\\[, end\\]\\]) \\-\u0026gt; bool Return True if S starts with the specified prefix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. prefix can also be a tuple of strings to try. \u0026quot;\u0026quot;\u0026quot; return False def strip(self, chars=None): \u0026quot;\u0026quot;\u0026quot; 移除两段空白 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.strip(\\[chars\\]) \\-\u0026gt; string or unicode Return a copy of the string S with leading and trailing whitespace removed. If chars is given and not None, remove characters in chars instead. If chars is unicode, S will be converted to unicode before stripping \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def swapcase(self): \u0026quot;\u0026quot;\u0026quot; 大写变小写，小写变大写 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.swapcase() \\-\u0026gt; string Return a copy of the string S with uppercase characters converted to lowercase and vice versa. \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def title(self): \u0026quot;\u0026quot;\u0026quot; S.title() \\-\u0026gt; string Return a titlecased version of S, i.e. words start with uppercase characters, all remaining cased characters have lowercase. \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def translate(self, table, deletechars=None): \u0026quot;\u0026quot;\u0026quot; 转换，需要先做一个对应表，最后一个表示删除字符集合 intab \\= \u0026quot;aeiou\u0026quot; outtab \\= \u0026quot;12345\u0026quot; trantab \\= maketrans(intab, outtab) str \\= \u0026quot;this is string example....wow!!!\u0026quot; print str.translate(trantab, 'xm') \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.translate(table \\[,deletechars\\]) \\-\u0026gt; string Return a copy of the string S, where all characters occurring in the optional argument deletechars are removed, and the remaining characters have been mapped through the given translation table, which must be a string of length 256 or None. If the table argument is None, no translation is applied and the operation simply removes the characters in deletechars. \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def upper(self): \u0026quot;\u0026quot;\u0026quot; S.upper() \\-\u0026gt; string Return a copy of the string S converted to uppercase. \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def zfill(self, width): \u0026quot;\u0026quot;\u0026quot;方法返回指定长度的字符串，原字符串右对齐，前面填充0。\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; S.zfill(width) \\-\u0026gt; string Pad a numeric string S with zeros on the left, to fill a field of the specified width. The string S is never truncated. \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def \\_formatter\\_field\\_name\\_split(self, \\*args, \\*\\*kwargs): # real signature unknown pass def \\_formatter\\_parser(self, \\*args, \\*\\*kwargs): # real signature unknown pass def \\_\\_add\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_add\\_\\_(y) \u0026lt;==\u0026gt; x+y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_contains\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_contains\\_\\_(y) \u0026lt;==\u0026gt; y in x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_eq\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_eq\\_\\_(y) \u0026lt;==\u0026gt; x==y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_format\\_\\_(self, format\\_spec): \u0026quot;\u0026quot;\u0026quot; S.\\_\\_format\\_\\_(format\\_spec) -\u0026gt; string Return a formatted version of S as described by format\\_spec. \u0026quot;\u0026quot;\u0026quot; return \u0026quot;\u0026quot; def \\_\\_getattribute\\_\\_(self, name): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_getattribute\\_\\_('name') \u0026lt;==\u0026gt; x.name \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_getitem\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_getitem\\_\\_(y) \u0026lt;==\u0026gt; x\\[y\\] \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_getnewargs\\_\\_(self, \\*args, \\*\\*kwargs): # real signature unknown pass def \\_\\_getslice\\_\\_(self, i, j): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_getslice\\_\\_(i, j) \u0026lt;==\u0026gt; x\\[i:j\\] Use of negative indices is not supported. \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_ge\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_ge\\_\\_(y) \u0026lt;==\u0026gt; x\u0026gt;=y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_gt\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_gt\\_\\_(y) \u0026lt;==\u0026gt; x\u0026gt;y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_hash\\_\\_(self): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_hash\\_\\_() \u0026lt;==\u0026gt; hash(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_init\\_\\_(self, string=''): # known special case of str.\\_\\_init\\_\\_ \u0026quot;\u0026quot;\u0026quot; str(object\\='') -\u0026gt; string Return a nice string representation of the object. If the argument is a string, the return value is the same object. # (copied from class doc) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_len\\_\\_(self): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_len\\_\\_() \u0026lt;==\u0026gt; len(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_le\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_le\\_\\_(y) \u0026lt;==\u0026gt; x\u0026lt;=y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_lt\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_lt\\_\\_(y) \u0026lt;==\u0026gt; x\u0026quot;\u0026quot;\u0026quot; pass def \\_\\_mod\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_mod\\_\\_(y) \u0026lt;==\u0026gt; x%y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_mul\\_\\_(self, n): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_mul\\_\\_(n) \u0026lt;==\u0026gt; x\\*n \u0026quot;\u0026quot;\u0026quot; pass @staticmethod # known case of \\_\\_new\\_\\_ def \\_\\_new\\_\\_(S, \\*more): \u0026quot;\u0026quot;\u0026quot; T.\\_\\_new\\_\\_(S, ...) -\u0026gt; a new object with type S, a subtype of T \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_ne\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_ne\\_\\_(y) \u0026lt;==\u0026gt; x!=y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_repr\\_\\_(self): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_repr\\_\\_() \u0026lt;==\u0026gt; repr(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rmod\\_\\_(self, y): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_rmod\\_\\_(y) \u0026lt;==\u0026gt; y%x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rmul\\_\\_(self, n): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_rmul\\_\\_(n) \u0026lt;==\u0026gt; n\\*x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_sizeof\\_\\_(self): \u0026quot;\u0026quot;\u0026quot; S.\\_\\_sizeof\\_\\_() -\u0026gt; size of S in memory, in bytes \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_str\\_\\_(self): \u0026quot;\u0026quot;\u0026quot; x.\\_\\_str\\_\\_() \u0026lt;==\u0026gt; str(x) \u0026quot;\u0026quot;\u0026quot; pass str\n4、列表\n创建列表：\nname_list = [\u0026lsquo;alex\u0026rsquo;, \u0026lsquo;seven\u0026rsquo;, \u0026rsquo;eric\u0026rsquo;] 或 name_list ＝ list([\u0026lsquo;alex\u0026rsquo;, \u0026lsquo;seven\u0026rsquo;, \u0026rsquo;eric\u0026rsquo;])\n基本操作：\n索引 切片 追加 删除 长度 切片 循环 包含 class list(object): \u0026quot;\u0026quot;\u0026quot; list() -\u0026gt; new empty list list(iterable) -\u0026gt; new list initialized from iterable\u0026rsquo;s items \u0026quot;\u0026quot;\u0026quot; def append(self, p_object): # real signature unknown; restored from __doc__ \u0026quot;\u0026quot;\u0026quot; L.append(object) \u0026ndash; append object to end \u0026quot;\u0026quot;\u0026quot; pass\ndef count(self, value): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; L.count(value) -\u0026gt; integer -- return number of occurrences of value \u0026quot;\u0026quot;\u0026quot; return 0 def extend(self, iterable): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; L.extend(iterable) -- extend list by appending elements from the iterable \u0026quot;\u0026quot;\u0026quot; pass def index(self, value, start=None, stop=None): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; L.index(value, \\[start, \\[stop\\]\\]) -\u0026gt; integer -- return first index of value. Raises ValueError if the value is not present. \u0026quot;\u0026quot;\u0026quot; return 0 def insert(self, index, p\\_object): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; L.insert(index, object) -- insert object before index \u0026quot;\u0026quot;\u0026quot; pass def pop(self, index=None): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; L.pop(\\[index\\]) -\u0026gt; item -- remove and return item at index (default last). Raises IndexError if list is empty or index is out of range. \u0026quot;\u0026quot;\u0026quot; pass def remove(self, value): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; L.remove(value) -- remove first occurrence of value. Raises ValueError if the value is not present. \u0026quot;\u0026quot;\u0026quot; pass def reverse(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; L.reverse() -- reverse \\*IN PLACE\\* \u0026quot;\u0026quot;\u0026quot; pass def sort(self, cmp=None, key=None, reverse=False): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; L.sort(cmp=None, key=None, reverse=False) -- stable sort \\*IN PLACE\\*; cmp(x, y) -\u0026gt; -1, 0, 1 \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_add\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_add\\_\\_(y) \u0026lt;==\u0026gt; x+y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_contains\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_contains\\_\\_(y) \u0026lt;==\u0026gt; y in x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_delitem\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_delitem\\_\\_(y) \u0026lt;==\u0026gt; del x\\[y\\] \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_delslice\\_\\_(self, i, j): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_delslice\\_\\_(i, j) \u0026lt;==\u0026gt; del x\\[i:j\\] Use of negative indices is not supported. \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_eq\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_eq\\_\\_(y) \u0026lt;==\u0026gt; x==y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_getattribute\\_\\_(self, name): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_getattribute\\_\\_('name') \u0026lt;==\u0026gt; x.name \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_getitem\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_getitem\\_\\_(y) \u0026lt;==\u0026gt; x\\[y\\] \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_getslice\\_\\_(self, i, j): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_getslice\\_\\_(i, j) \u0026lt;==\u0026gt; x\\[i:j\\] Use of negative indices is not supported. \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_ge\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_ge\\_\\_(y) \u0026lt;==\u0026gt; x\u0026gt;=y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_gt\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_gt\\_\\_(y) \u0026lt;==\u0026gt; x\u0026gt;y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_iadd\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_iadd\\_\\_(y) \u0026lt;==\u0026gt; x+=y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_imul\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_imul\\_\\_(y) \u0026lt;==\u0026gt; x\\*=y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_init\\_\\_(self, seq=()): # known special case of list.\\_\\_init\\_\\_ \u0026quot;\u0026quot;\u0026quot; list() -\u0026gt; new empty list list(iterable) -\u0026gt; new list initialized from iterable's items # (copied from class doc) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_iter\\_\\_(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_iter\\_\\_() \u0026lt;==\u0026gt; iter(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_len\\_\\_(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_len\\_\\_() \u0026lt;==\u0026gt; len(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_le\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_le\\_\\_(y) \u0026lt;==\u0026gt; x\u0026lt;=y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_lt\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_lt\\_\\_(y) \u0026lt;==\u0026gt; x\u0026quot;\u0026quot;\u0026quot; pass def \\_\\_mul\\_\\_(self, n): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_mul\\_\\_(n) \u0026lt;==\u0026gt; x\\*n \u0026quot;\u0026quot;\u0026quot; pass @staticmethod # known case of \\_\\_new\\_\\_ def \\_\\_new\\_\\_(S, \\*more): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; T.\\_\\_new\\_\\_(S, ...) -\u0026gt; a new object with type S, a subtype of T \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_ne\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_ne\\_\\_(y) \u0026lt;==\u0026gt; x!=y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_repr\\_\\_(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_repr\\_\\_() \u0026lt;==\u0026gt; repr(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_reversed\\_\\_(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; L.\\_\\_reversed\\_\\_() -- return a reverse iterator over the list \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rmul\\_\\_(self, n): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_rmul\\_\\_(n) \u0026lt;==\u0026gt; n\\*x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_setitem\\_\\_(self, i, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_setitem\\_\\_(i, y) \u0026lt;==\u0026gt; x\\[i\\]=y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_setslice\\_\\_(self, i, j, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_setslice\\_\\_(i, j, y) \u0026lt;==\u0026gt; x\\[i:j\\]=y Use of negative indices is not supported. \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_sizeof\\_\\_(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; L.\\_\\_sizeof\\_\\_() -- size of L in memory, in bytes \u0026quot;\u0026quot;\u0026quot; pass \\_\\_hash\\_\\_ = None list\n5、元祖\n创建元祖：\nages = (11, 22, 33, 44, 55) 或 ages = tuple((11, 22, 33, 44, 55))\n基本操作：\n索引 切片 循环 长度 包含 lass tuple(object): \u0026quot;\u0026quot;\u0026quot; tuple() -\u0026gt; empty tuple tuple(iterable) -\u0026gt; tuple initialized from iterable\u0026rsquo;s items\nIf the argument is a tuple, the return value is the same object. \u0026quot;\u0026quot;\u0026quot; def count(self, value): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; T.count(value) -\u0026gt; integer -- return number of occurrences of value \u0026quot;\u0026quot;\u0026quot; return 0 def index(self, value, start=None, stop=None): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; T.index(value, \\[start, \\[stop\\]\\]) -\u0026gt; integer -- return first index of value. Raises ValueError if the value is not present. \u0026quot;\u0026quot;\u0026quot; return 0 def \\_\\_add\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_add\\_\\_(y) \u0026lt;==\u0026gt; x+y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_contains\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_contains\\_\\_(y) \u0026lt;==\u0026gt; y in x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_eq\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_eq\\_\\_(y) \u0026lt;==\u0026gt; x==y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_getattribute\\_\\_(self, name): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_getattribute\\_\\_('name') \u0026lt;==\u0026gt; x.name \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_getitem\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_getitem\\_\\_(y) \u0026lt;==\u0026gt; x\\[y\\] \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_getnewargs\\_\\_(self, \\*args, \\*\\*kwargs): # real signature unknown pass def \\_\\_getslice\\_\\_(self, i, j): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_getslice\\_\\_(i, j) \u0026lt;==\u0026gt; x\\[i:j\\] Use of negative indices is not supported. \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_ge\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_ge\\_\\_(y) \u0026lt;==\u0026gt; x\u0026gt;=y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_gt\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_gt\\_\\_(y) \u0026lt;==\u0026gt; x\u0026gt;y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_hash\\_\\_(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_hash\\_\\_() \u0026lt;==\u0026gt; hash(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_init\\_\\_(self, seq=()): # known special case of tuple.\\_\\_init\\_\\_ \u0026quot;\u0026quot;\u0026quot; tuple() -\u0026gt; empty tuple tuple(iterable) -\u0026gt; tuple initialized from iterable's items If the argument is a tuple, the return value is the same object. # (copied from class doc) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_iter\\_\\_(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_iter\\_\\_() \u0026lt;==\u0026gt; iter(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_len\\_\\_(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_len\\_\\_() \u0026lt;==\u0026gt; len(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_le\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_le\\_\\_(y) \u0026lt;==\u0026gt; x\u0026lt;=y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_lt\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_lt\\_\\_(y) \u0026lt;==\u0026gt; x\u0026quot;\u0026quot;\u0026quot; pass def \\_\\_mul\\_\\_(self, n): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_mul\\_\\_(n) \u0026lt;==\u0026gt; x\\*n \u0026quot;\u0026quot;\u0026quot; pass @staticmethod # known case of \\_\\_new\\_\\_ def \\_\\_new\\_\\_(S, \\*more): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; T.\\_\\_new\\_\\_(S, ...) -\u0026gt; a new object with type S, a subtype of T \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_ne\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_ne\\_\\_(y) \u0026lt;==\u0026gt; x!=y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_repr\\_\\_(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_repr\\_\\_() \u0026lt;==\u0026gt; repr(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_rmul\\_\\_(self, n): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_rmul\\_\\_(n) \u0026lt;==\u0026gt; n\\*x \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_sizeof\\_\\_(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; T.\\_\\_sizeof\\_\\_() -- size of T in memory, in bytes \u0026quot;\u0026quot;\u0026quot; pass tuple\n6、字典（无序）\n创建字典：\nperson = {\u0026ldquo;name\u0026rdquo;: \u0026ldquo;mr.wu\u0026rdquo;, \u0026lsquo;age\u0026rsquo;: 18} 或 person = dict({\u0026ldquo;name\u0026rdquo;: \u0026ldquo;mr.wu\u0026rdquo;, \u0026lsquo;age\u0026rsquo;: 18})\n常用操作：\n索引 新增 删除 键、值、键值对 循环 长度 class dict(object): \u0026quot;\u0026quot;\u0026quot; dict() -\u0026gt; new empty dictionary dict(mapping) -\u0026gt; new dictionary initialized from a mapping object\u0026rsquo;s (key, value) pairs dict(iterable) -\u0026gt; new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict(**kwargs) -\u0026gt; new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2) \u0026quot;\u0026quot;\u0026quot;\ndef clear(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; 清除内容 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; D.clear() -\u0026gt; None. Remove all items from D. \u0026quot;\u0026quot;\u0026quot; pass def copy(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; 浅拷贝 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; D.copy() -\u0026gt; a shallow copy of D \u0026quot;\u0026quot;\u0026quot; pass @staticmethod # known case def fromkeys(S, v=None): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; dict.fromkeys(S\\[,v\\]) -\u0026gt; New dict with keys from S and values equal to v. v defaults to None. \u0026quot;\u0026quot;\u0026quot; pass def get(self, k, d=None): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; 根据key获取值，d是默认值 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; D.get(k\\[,d\\]) -\u0026gt; D\\[k\\] if k in D, else d. d defaults to None. \u0026quot;\u0026quot;\u0026quot; pass def has\\_key(self, k): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; 是否有key \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; D.has\\_key(k) -\u0026gt; True if D has a key k, else False \u0026quot;\u0026quot;\u0026quot; return False def items(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; 所有项的列表形式 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; D.items() -\u0026gt; list of D's (key, value) pairs, as 2-tuples \u0026quot;\u0026quot;\u0026quot; return \\[\\] def iteritems(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; 项可迭代 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; D.iteritems() -\u0026gt; an iterator over the (key, value) items of D \u0026quot;\u0026quot;\u0026quot; pass def iterkeys(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; key可迭代 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; D.iterkeys() -\u0026gt; an iterator over the keys of D \u0026quot;\u0026quot;\u0026quot; pass def itervalues(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; value可迭代 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; D.itervalues() -\u0026gt; an iterator over the values of D \u0026quot;\u0026quot;\u0026quot; pass def keys(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; 所有的key列表 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; D.keys() -\u0026gt; list of D's keys \u0026quot;\u0026quot;\u0026quot; return \\[\\] def pop(self, k, d=None): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; 获取并在字典中移除 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; D.pop(k\\[,d\\]) -\u0026gt; v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised \u0026quot;\u0026quot;\u0026quot; pass def popitem(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; 获取并在字典中移除 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; D.popitem() -\u0026gt; (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. \u0026quot;\u0026quot;\u0026quot; pass def setdefault(self, k, d=None): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; 如果key不存在，则创建，如果存在，则返回已存在的值且不修改 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; D.setdefault(k\\[,d\\]) -\u0026gt; D.get(k,d), also set D\\[k\\]=d if k not in D \u0026quot;\u0026quot;\u0026quot; pass def update(self, E=None, \\*\\*F): # known special case of dict.update \u0026quot;\u0026quot;\u0026quot; 更新 {'name':'alex', 'age': 18000} \\[('name','sbsbsb'),\\] \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; D.update(\\[E, \\]\\*\\*F) -\u0026gt; None. Update D from dict/iterable E and F. If E present and has a .keys() method, does: for k in E: D\\[k\\] = E\\[k\\] If E present and lacks .keys() method, does: for (k, v) in E: D\\[k\\] = v In either case, this is followed by: for k in F: D\\[k\\] = F\\[k\\] \u0026quot;\u0026quot;\u0026quot; pass def values(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; 所有的值 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; D.values() -\u0026gt; list of D's values \u0026quot;\u0026quot;\u0026quot; return \\[\\] def viewitems(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; 所有项，只是将内容保存至view对象中 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; D.viewitems() -\u0026gt; a set-like object providing a view on D's items \u0026quot;\u0026quot;\u0026quot; pass def viewkeys(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; D.viewkeys() -\u0026gt; a set-like object providing a view on D's keys \u0026quot;\u0026quot;\u0026quot; pass def viewvalues(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; D.viewvalues() -\u0026gt; an object providing a view on D's values \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_cmp\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_cmp\\_\\_(y) \u0026lt;==\u0026gt; cmp(x,y) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_contains\\_\\_(self, k): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; D.\\_\\_contains\\_\\_(k) -\u0026gt; True if D has a key k, else False \u0026quot;\u0026quot;\u0026quot; return False def \\_\\_delitem\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_delitem\\_\\_(y) \u0026lt;==\u0026gt; del x\\[y\\] \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_eq\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_eq\\_\\_(y) \u0026lt;==\u0026gt; x==y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_getattribute\\_\\_(self, name): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_getattribute\\_\\_('name') \u0026lt;==\u0026gt; x.name \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_getitem\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_getitem\\_\\_(y) \u0026lt;==\u0026gt; x\\[y\\] \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_ge\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_ge\\_\\_(y) \u0026lt;==\u0026gt; x\u0026gt;=y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_gt\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_gt\\_\\_(y) \u0026lt;==\u0026gt; x\u0026gt;y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_init\\_\\_(self, seq=None, \\*\\*kwargs): # known special case of dict.\\_\\_init\\_\\_ \u0026quot;\u0026quot;\u0026quot; dict() -\u0026gt; new empty dictionary dict(mapping) -\u0026gt; new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -\u0026gt; new dictionary initialized as if via: d = {} for k, v in iterable: d\\[k\\] = v dict(\\*\\*kwargs) -\u0026gt; new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2) # (copied from class doc) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_iter\\_\\_(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_iter\\_\\_() \u0026lt;==\u0026gt; iter(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_len\\_\\_(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_len\\_\\_() \u0026lt;==\u0026gt; len(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_le\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_le\\_\\_(y) \u0026lt;==\u0026gt; x\u0026lt;=y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_lt\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_lt\\_\\_(y) \u0026lt;==\u0026gt; x\u0026quot;\u0026quot;\u0026quot; pass @staticmethod # known case of \\_\\_new\\_\\_ def \\_\\_new\\_\\_(S, \\*more): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; T.\\_\\_new\\_\\_(S, ...) -\u0026gt; a new object with type S, a subtype of T \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_ne\\_\\_(self, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_ne\\_\\_(y) \u0026lt;==\u0026gt; x!=y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_repr\\_\\_(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_repr\\_\\_() \u0026lt;==\u0026gt; repr(x) \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_setitem\\_\\_(self, i, y): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; x.\\_\\_setitem\\_\\_(i, y) \u0026lt;==\u0026gt; x\\[i\\]=y \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_sizeof\\_\\_(self): # real signature unknown; restored from \\_\\_doc\\_\\_ \u0026quot;\u0026quot;\u0026quot; D.\\_\\_sizeof\\_\\_() -\u0026gt; size of D in memory, in bytes \u0026quot;\u0026quot;\u0026quot; pass \\_\\_hash\\_\\_ = None dict\nPS：循环，range，continue 和 break\n其他 1、for循环\n用户按照顺序循环可迭代对象中的内容，\nPS：break、continue\nli = [11,22,33,44] for item in li: print item\n2、enumrate\n为可迭代的对象添加序号\nli = [11,22,33] for k,v in enumerate(li, 1): print(k,v)\n3、range和xrange\n指定范围，生成指定的数字\nprint range(1, 10)\n结果：[1, 2, 3, 4, 5, 6, 7, 8, 9] print range(1, 10, 2)\n结果：[1, 3, 5, 7, 9] print range(30, 0, -2)\n结果：[30, 28, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 6, 4, 2]　练习题 一、元素分类\n有如下值集合 [11,22,33,44,55,66,77,88,99,90\u0026hellip;]，将所有大于 66 的值保存至字典的第一个key中，将小于 66 的值保存至第二个key的值中。\n即： {\u0026lsquo;k1\u0026rsquo;: 大于66的所有值, \u0026lsquo;k2\u0026rsquo;: 小于66的所有值}\n二、查找\n查找列表中元素，移除每个元素的空格，并查找以 a或A开头 并且以 c 结尾的所有元素。\nli = [\u0026ldquo;alec\u0026rdquo;, \u0026quot; aric\u0026quot;, \u0026ldquo;Alex\u0026rdquo;, \u0026ldquo;Tony\u0026rdquo;, \u0026ldquo;rain\u0026rdquo;]\ntu = (\u0026ldquo;alec\u0026rdquo;, \u0026quot; aric\u0026quot;, \u0026ldquo;Alex\u0026rdquo;, \u0026ldquo;Tony\u0026rdquo;, \u0026ldquo;rain\u0026rdquo;) dic = {\u0026lsquo;k1\u0026rsquo;: \u0026ldquo;alex\u0026rdquo;, \u0026lsquo;k2\u0026rsquo;: \u0026rsquo; aric\u0026rsquo;, \u0026ldquo;k3\u0026rdquo;: \u0026ldquo;Alex\u0026rdquo;, \u0026ldquo;k4\u0026rdquo;: \u0026ldquo;Tony\u0026rdquo;}\n三、输出商品列表，用户输入序号，显示用户选中的商品\n商品 li = [\u0026ldquo;手机\u0026rdquo;, \u0026ldquo;电脑\u0026rdquo;, \u0026lsquo;鼠标垫\u0026rsquo;, \u0026lsquo;游艇\u0026rsquo;]\n四、购物车\n功能要求：\n要求用户输入总资产，例如：2000 显示商品列表，让用户根据序号选择商品，加入购物车 购买，如果商品总额大于总资产，提示账户余额不足，否则，购买成功。 附加：可充值、某商品移除购物车 goods = [ {\u0026ldquo;name\u0026rdquo;: \u0026ldquo;电脑\u0026rdquo;, \u0026ldquo;price\u0026rdquo;: 1999}, {\u0026ldquo;name\u0026rdquo;: \u0026ldquo;鼠标\u0026rdquo;, \u0026ldquo;price\u0026rdquo;: 10}, {\u0026ldquo;name\u0026rdquo;: \u0026ldquo;游艇\u0026rdquo;, \u0026ldquo;price\u0026rdquo;: 20}, {\u0026ldquo;name\u0026rdquo;: \u0026ldquo;美女\u0026rdquo;, \u0026ldquo;price\u0026rdquo;: 998}, ]\n五、用户交互，显示省市县三级联动的选择\ndic = { \u0026ldquo;河北\u0026rdquo;: { \u0026ldquo;石家庄\u0026rdquo;: [\u0026ldquo;鹿泉\u0026rdquo;, \u0026ldquo;藁城\u0026rdquo;, \u0026ldquo;元氏\u0026rdquo;], \u0026ldquo;邯郸\u0026rdquo;: [\u0026ldquo;永年\u0026rdquo;, \u0026ldquo;涉县\u0026rdquo;, \u0026ldquo;磁县\u0026rdquo;], } \u0026ldquo;河南\u0026rdquo;: { \u0026hellip; } \u0026ldquo;山西\u0026rdquo;: { \u0026hellip; }\n}\n","permalink":"https://water711.github.io/posts/2017-04-11-python%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%89%E7%AF%87python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","tags":null,"title":"Python开发【第三篇】：Python基本数据类型"},{"categories":["python"],"contents":"字符串格式化 Python的字符串格式化有两种方式: 百分号方式、format方式\n百分号的方式相对来说比较老，而format方式则是比较先进的方式，企图替换古老的方式，目前两者并存。[PEP-3101]\nThis PEP proposes a new system for built-in string formatting operations, intended as a replacement for the existing \u0026lsquo;%\u0026rsquo; string formatting operator.\n1、百分号方式\n%[(name)][flags][width].[precision]typecode\n(name) 可选，用于选择指定的key\nflags 可选，可供选择的值有:\n+ 右对齐；正数前加正好，负数前加负号； - 左对齐；正数前无符号，负数前加负号； 空格 右对齐；正数前加空格，负数前加负号； 0 右对齐；正数前无符号，负数前加负号；用0填充空白处 width 可选，占有宽度\n.precision 可选，小数点后保留的位数\ntypecode 必选\ns，获取传入对象的__str__方法的返回值，并将其格式化到指定位置 r，获取传入对象的__repr__方法的返回值，并将其格式化到指定位置 c，整数：将数字转换成其unicode对应的值，10进制范围为 0 \u0026lt;= i \u0026lt;= 1114111（py27则只支持0-255）；字符：将字符添加到指定位置 o，将整数转换成 八 进制表示，并将其格式化到指定位置 x，将整数转换成十六进制表示，并将其格式化到指定位置 d，将整数、浮点数转换成 十 进制表示，并将其格式化到指定位置 e，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（小写e） E，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（大写E） f， 将整数、浮点数转换成浮点数表示，并将其格式化到指定位置（默认保留小数点后6位） F，同上 g，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是e；） G，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是E；） %，当字符串中存在格式化标志时，需要用 %%表示一个百分号 注：Python中百分号格式化是不存在自动将整数转换成二进制表示的方式\n常用格式化：\ntpl = \u0026ldquo;i am %s\u0026rdquo; % \u0026ldquo;alex\u0026rdquo;\ntpl = \u0026ldquo;i am %s age %d\u0026rdquo; % (\u0026ldquo;alex\u0026rdquo;, 18)\ntpl = \u0026ldquo;i am %(name)s age %(age)d\u0026rdquo; % {\u0026ldquo;name\u0026rdquo;: \u0026ldquo;alex\u0026rdquo;, \u0026ldquo;age\u0026rdquo;: 18}\ntpl = \u0026ldquo;percent %.2f\u0026rdquo; % 99.97623\ntpl = \u0026ldquo;i am %(pp).2f\u0026rdquo; % {\u0026ldquo;pp\u0026rdquo;: 123.425556, }\ntpl = \u0026ldquo;i am %.2f %%\u0026rdquo; % {\u0026ldquo;pp\u0026rdquo;: 123.425556, }\n2、Format方式\n[[fill]align][sign][#][0][width][,][.precision][type]\nfill 【可选】空白处填充的字符\nalign 【可选】对齐方式（需配合width使用）\n\u0026lt;，内容左对齐\n\u0026gt;，内容右对齐(默认)\n＝，内容右对齐，将符号放置在填充字符的左侧，且只对数字类型有效。 即使：符号+填充物+数字\n^，内容居中\nsign 【可选】有无符号数字\n+，正号加正，负号加负； -，正号不变，负号加负； 空格 ，正号空格，负号加负； # 【可选】对于二进制、八进制、十六进制，如果加上#，会显示 0b/0o/0x，否则不显示\n， 【可选】为数字添加分隔符，如：1,000,000\nwidth 【可选】格式化位所占宽度\n.precision 【可选】小数位保留精度\ntype 【可选】格式化类型\n传入” 字符串类型 “的参数\ns，格式化字符串类型数据 空白，未指定类型，则默认是None，同s _传入“ 整数类型 ”的参数\n_\nb，将10进制整数自动转换成2进制表示然后格式化 c，将10进制整数自动转换为其对应的unicode字符 d，十进制整数 o，将10进制整数自动转换成8进制表示然后格式化； x，将10进制整数自动转换成16进制表示然后格式化（小写x） X，将10进制整数自动转换成16进制表示然后格式化（大写X） 传入“ 浮点型或小数类型 ”的参数\ne， 转换为科学计数法（小写e）表示，然后格式化； E， 转换为科学计数法（大写E）表示，然后格式化; f ， 转换为浮点型（默认小数点后保留6位）表示，然后格式化； F， 转换为浮点型（默认小数点后保留6位）表示，然后格式化； g， 自动在e和f中切换 G， 自动在E和F中切换 %，显示百分比（默认显示小数点后6位） 常用格式化：\ntpl = \u0026ldquo;i am {}, age {}, {}\u0026quot;.format(\u0026ldquo;seven\u0026rdquo;, 18, \u0026lsquo;alex\u0026rsquo;)\ntpl = \u0026ldquo;i am {}, age {}, {}\u0026quot;.format(*[\u0026ldquo;seven\u0026rdquo;, 18, \u0026lsquo;alex\u0026rsquo;])\ntpl = \u0026ldquo;i am {0}, age {1}, really {0}\u0026quot;.format(\u0026ldquo;seven\u0026rdquo;, 18)\ntpl = \u0026ldquo;i am {0}, age {1}, really {0}\u0026quot;.format(*[\u0026ldquo;seven\u0026rdquo;, 18])\ntpl = \u0026ldquo;i am {name}, age {age}, really {name}\u0026quot;.format(name=\u0026ldquo;seven\u0026rdquo;, age=18)\ntpl = \u0026ldquo;i am {name}, age {age}, really {name}\u0026quot;.format(**{\u0026ldquo;name\u0026rdquo;: \u0026ldquo;seven\u0026rdquo;, \u0026ldquo;age\u0026rdquo;: 18})\ntpl = \u0026ldquo;i am {0[0]}, age {0[1]}, really {0[2]}\u0026quot;.format([1, 2, 3], [11, 22, 33])\ntpl = \u0026ldquo;i am {:s}, age {:d}, money {:f}\u0026quot;.format(\u0026ldquo;seven\u0026rdquo;, 18, 88888.1)\ntpl = \u0026ldquo;i am {:s}, age {:d}\u0026quot;.format(*[\u0026ldquo;seven\u0026rdquo;, 18])\ntpl = \u0026ldquo;i am {name:s}, age {age:d}\u0026quot;.format(name=\u0026ldquo;seven\u0026rdquo;, age=18)\ntpl = \u0026ldquo;i am {name:s}, age {age:d}\u0026quot;.format(**{\u0026ldquo;name\u0026rdquo;: \u0026ldquo;seven\u0026rdquo;, \u0026ldquo;age\u0026rdquo;: 18})\ntpl = \u0026ldquo;numbers: {:b},{:o},{:d},{:x},{:X}, {:%}\u0026quot;.format(15, 15, 15, 15, 15, 15.87623, 2)\ntpl = \u0026ldquo;numbers: {:b},{:o},{:d},{:x},{:X}, {:%}\u0026quot;.format(15, 15, 15, 15, 15, 15.87623, 2)\ntpl = \u0026ldquo;numbers: {0:b},{0:o},{0:d},{0:x},{0:X}, {0:%}\u0026quot;.format(15)\ntpl = \u0026ldquo;numbers: {num:b},{num:o},{num:d},{num:x},{num:X}, {num:%}\u0026quot;.format(num=15)\n更多格式化操作：https://docs.python.org/3/library/string.html\n迭代器和生成器 1、迭代器\n迭代器是访问集合元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退，不过这也没什么，因为人们很少在迭代途中往后退。另外，迭代器的一大优点是不要求事先准备好整个迭代过程中所有的元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。这个特点使得它特别适合用于遍历一些巨大的或是无限的集合，比如几个G的文件\n特点：\n访问者不需要关心迭代器内部的结构，仅需通过next()方法不断去取下一个内容 不能随机访问集合中的某个值 ，只能从头到尾依次访问 访问到一半时不能往回退 便于循环比较大的数据集合，节省内存 \u0026gt;\u0026raquo; a = iter([1,2,3,4,5])\na a.__next__() 1 a.__next__() 2 a.__next__() 3 a.__next__() 4 a.__next__() 5 a.__next__() Traceback (most recent call last): File \u0026ldquo;\u0026rdquo;, line 1, in StopIteration\n2、生成器\n一个函数调用时返回一个迭代器，那这个函数就叫做生成器（generator）；如果函数中包含yield语法，那这个函数就会变成生成器；\ndef func(): yield 1 yield 2 yield 3 yield 4\n上述代码中：func是函数称为生成器，当执行此函数func()时会得到一个迭代器。\n\u0026gt;\u0026raquo; temp = func()\ntemp.__next__() 1 temp.__next__() 2 temp.__next__() 3 temp.__next__() 4 temp.__next__() Traceback (most recent call last): File \u0026ldquo;\u0026rdquo;, line 1, in StopIteration\n3、实例\na、利用生成器自定义range\ndef nrange(num): temp = -1 while True: temp = temp + 1 if temp \u0026gt;= num: return else: yield temp\nb、利用迭代器访问range\n\u0026hellip;\n","permalink":"https://water711.github.io/posts/2017-04-11-python%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%94%E7%AF%87python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9D%82%E8%B4%A7%E9%93%BA/","tags":null,"title":"Python开发【第五篇】：Python基础之杂货铺"},{"categories":["python"],"contents":"socket通常也称作\u0026quot;套接字\u0026quot;，用于描述IP地址和端口，是一个通信链的句柄，应用程序通常通过\u0026quot;套接字\u0026quot;向网络发出请求或者应答网络请求。\nsocket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，对于文件用【打开】【读写】【关闭】模式来操作。socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）\nsocket和file的区别：\nfile模块是针对某个指定文件进行【打开】【读写】【关闭】 socket模块是针对 服务器端 和 客户端Socket 进行【打开】【读写】【关闭】 #!/usr/bin/env python # -*- coding:utf-8 -*-\nimport socket\nip_port = (\u0026lsquo;127.0.0.1\u0026rsquo;,9999)\nsk = socket.socket() sk.bind(ip_port) sk.listen(5) while True: print \u0026lsquo;server waiting\u0026hellip;\u0026rsquo; conn,addr = sk.accept()\nclient\\_data \\= conn.recv(1024) print client\\_data conn.sendall('不要回答,不要回答,不要回答') conn.close() socket server\n#!/usr/bin/env python # -*- coding:utf-8 -*- import socket ip_port = (\u0026lsquo;127.0.0.1\u0026rsquo;,9999)\nsk = socket.socket() sk.connect(ip_port)\nsk.sendall(\u0026lsquo;请求占领地球\u0026rsquo;)\nserver_reply = sk.recv(1024) print server_reply\nsk.close()\nsocket client\nWEB服务应用：\n#!/usr/bin/env python #coding:utf-8 import socket\ndef handle_request(client): buf = client.recv(1024) client.send(\u0026ldquo;HTTP/1.1 200 OK\\r\\n\\r\\n\u0026rdquo;) client.send(\u0026ldquo;Hello, World\u0026rdquo;)\ndef main(): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.bind((\u0026rsquo;localhost\u0026rsquo;,8080)) sock.listen(5)\nwhile True: connection, address = sock.accept() handle\\_request(connection) connection.close() if __name__ == \u0026lsquo;__main__\u0026rsquo;: main()\n更多功能\nsk = socket.socket(socket.AF_INET,socket.SOCK_STREAM,0)\n参数一：地址簇\nsocket.AF_INET IPv4（默认）\nsocket.AF_INET6 IPv6\nsocket.AF_UNIX 只能够用于单一的Unix系统进程间通信\n参数二：类型\nsocket.SOCK_STREAM　流式socket , for TCP （默认）\nsocket.SOCK_DGRAM　数据报式socket , for UDP\nsocket.SOCK_RAW 原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。\nsocket.SOCK_RDM 是一种可靠的UDP形式，即保证交付数据报但不保证顺序。SOCK_RAM用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。SOCK_RAM通常仅限于高级用户或管理员运行的程序使用。\nsocket.SOCK_SEQPACKET 可靠的连续数据包服务\n参数三：协议\n0　（默认）与特定的地址家族相关的协议,如果是 0 ，则系统就会根据地址格式和套接类别,自动选择一个合适的协议\nimport socket ip_port = (\u0026lsquo;127.0.0.1\u0026rsquo;,9999) sk = socket.socket(socket.AF_INET,socket.SOCK_DGRAM,0) sk.bind(ip_port) while True: data = sk.recv(1024) print data import socket ip_port = (\u0026lsquo;127.0.0.1\u0026rsquo;,9999)\nsk = socket.socket(socket.AF_INET,socket.SOCK_DGRAM,0) while True: inp = raw_input(\u0026lsquo;数据：\u0026rsquo;).strip() if inp == \u0026rsquo;exit\u0026rsquo;: break sk.sendto(inp,ip_port)\nsk.close()\nUDP Demo\nsk.bind(address)\ns.bind(address) 将套接字绑定到地址。address地址的格式取决于地址族。在AF_INET下，以元组（host,port）的形式表示地址。\nsk.listen(backlog)\n开始监听传入连接。backlog指定在拒绝连接之前，可以挂起的最大连接数量。\nbacklog等于5，表示内核已经接到了连接请求，但服务器还没有调用accept进行处理的连接个数最大为5\n这个值不能无限大，因为要在内核中维护连接队列\nsk.setblocking(bool)\n是否阻塞（默认True），如果设置False，那么accept和recv时一旦无数据，则报错。\nsk.accept()\n接受连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。\n接收TCP 客户的连接（阻塞式）等待连接的到来\nsk.connect(address)\n连接到address处的套接字。一般，address的格式为元组（hostname,port）,如果连接出错，返回socket.error错误。\nsk.connect_ex(address)\n同上，只不过会有返回值，连接成功时返回 0 ，连接失败时候返回编码，例如：10061\nsk.close()\n关闭套接字\nsk.recv(bufsize[,flag])\n接受套接字的数据。数据以字符串形式返回，bufsize指定最多可以接收的数量。flag提供有关消息的其他信息，通常可以忽略。\nsk.recvfrom(bufsize[.flag])\n与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。\nsk.send(string[,flag])\n将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。即：可能未将指定内容全部发送。\nsk.sendall(string[,flag])\n将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。\n内部通过递归调用send，将所有内容发送出去。\nsk.sendto(string[,flag],address)\n将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。该函数主要用于UDP协议。\nsk.settimeout(timeout)\n设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如 client 连接最多等待5s ）\nsk.getpeername()\n返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。\nsk.getsockname()\n返回套接字自己的地址。通常是一个元组(ipaddr,port)\nsk.fileno()\n套接字的文件描述符\n服务端 import socket ip_port = (\u0026lsquo;127.0.0.1\u0026rsquo;,9999) sk = socket.socket(socket.AF_INET,socket.SOCK_DGRAM,0) sk.bind(ip_port) while True: data,(host,port) = sk.recvfrom(1024) print(data,host,port) sk.sendto(bytes(\u0026lsquo;ok\u0026rsquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;), (host,port)) #客户端 import socket ip_port = (\u0026lsquo;127.0.0.1\u0026rsquo;,9999)\nsk = socket.socket(socket.AF_INET,socket.SOCK_DGRAM,0) while True: inp = input(\u0026lsquo;数据：\u0026rsquo;).strip() if inp == \u0026rsquo;exit\u0026rsquo;: break sk.sendto(bytes(inp, encoding=\u0026lsquo;utf-8\u0026rsquo;),ip_port) data = sk.recvfrom(1024) print(data)\nsk.close()\nUDP\n**实例：**智能机器人\n#!/usr/bin/env python # -*- coding:utf-8 -*-\nimport socket\nip_port = (\u0026lsquo;127.0.0.1\u0026rsquo;,8888) sk = socket.socket() sk.bind(ip_port) sk.listen(5) while True: conn,address = sk.accept() conn.sendall(\u0026lsquo;欢迎致电 10086，请输入1xxx,0转人工服务.\u0026rsquo;) Flag = True while Flag: data = conn.recv(1024) if data == \u0026rsquo;exit\u0026rsquo;: Flag = False elif data == \u0026lsquo;0\u0026rsquo;: conn.sendall(\u0026lsquo;通过可能会被录音.balabala一大推\u0026rsquo;) else: conn.sendall(\u0026lsquo;请重新输入.\u0026rsquo;) conn.close()\n服务端\n#!/usr/bin/env python # -*- coding:utf-8 -*-\nimport socket\nip_port = (\u0026lsquo;127.0.0.1\u0026rsquo;,8005) sk = socket.socket() sk.connect(ip_port) sk.settimeout(5) while True: data = sk.recv(1024) print \u0026lsquo;receive:\u0026rsquo;,data inp = raw_input(\u0026lsquo;please input:\u0026rsquo;) sk.sendall(inp) if inp == \u0026rsquo;exit\u0026rsquo;: break sk.close()\n客户端\nIO多路复用 I/O多路复用指：通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。\nLinux\nLinux中的 select，poll，epoll 都是IO多路复用的机制。\nselect\nselect最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。 select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。 select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。 另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。\npoll\npoll在1986年诞生于System V Release 3，它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。 poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。 另外，select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll()的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。\nepoll\n直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。 epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。 epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。 另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。\nPython\nPython中有一个select模块，其中提供了：select、poll、epoll三个方法，分别调用系统的 select，poll，epoll 从而实现IO多路复用。\nWindows Python： 提供： select Mac Python： 提供： select Linux Python： 提供： select、poll、epoll\n注意：网络操作、文件操作、终端操作等均属于IO操作，对于windows只支持Socket操作，其他系统支持其他IO操作，但是无法检测 普通文件操作 自动上次读取是否已经变化。\n对于select方法：\n句柄列表11, 句柄列表22, 句柄列表33 = select.select(句柄序列1, 句柄序列2, 句柄序列3, 超时时间)\n参数： 可接受四个参数（前三个必须） 返回值：三个列表\nselect方法用来监视文件句柄，如果句柄发生变化，则获取该句柄。 1、当 参数1 序列中的句柄发生可读时（accetp和read），则获取发生变化的句柄并添加到 返回值1 序列中 2、当 参数2 序列中含有句柄时，则将该序列中所有的句柄添加到 返回值2 序列中 3、当 参数3 序列中的句柄发生错误时，则将该发生错误的句柄添加到 返回值3 序列中 4、当 超时时间 未设置，则select会一直阻塞，直到监听的句柄发生变化 当 超时时间 ＝ 1时，那么如果监听的句柄均无任何变化，则select会阻塞 1 秒，之后返回三个空列表，如果监听的句柄有变化，则直接执行。\n#!/usr/bin/env python # -*- coding:utf-8 -*-\nimport select import threading import sys while True: readable, writeable, error = select.select([sys.stdin,],[],[],1) if sys.stdin in readable: print \u0026lsquo;select get stdin\u0026rsquo;,sys.stdin.readline()\n利用select监听终端操作实例\n#!/usr/bin/env python # -*- coding:utf-8 -*-\nimport socket import select\nsk1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sk1.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) sk1.bind((\u0026lsquo;127.0.0.1\u0026rsquo;,8002)) sk1.listen(5) sk1.setblocking(0)\ninputs = [sk1,] while True: readable_list, writeable_list, error_list = select.select(inputs, [], inputs, 1) for r in readable_list: # 当客户端第一次连接服务端时 if sk1 == r: print \u0026lsquo;accept\u0026rsquo; request, address = r.accept() request.setblocking(0) inputs.append(request) # 当客户端连接上服务端之后，再次发送数据时 else: received = r.recv(1024) # 当正常接收客户端发送的数据时 if received: print \u0026lsquo;received data:\u0026rsquo;, received # 当客户端关闭程序时 else: inputs.remove(r)\nsk1.close()\n利用select实现伪同时处理多个Socket客户端请求：服务端\n#!/usr/bin/env python # -*- coding:utf-8 -*- import socket\nip_port = (\u0026lsquo;127.0.0.1\u0026rsquo;,8002) sk = socket.socket() sk.connect(ip_port) while True: inp = raw_input(\u0026lsquo;please input:\u0026rsquo;) sk.sendall(inp) sk.close()\n利用select实现伪同时处理多个Socket客户端请求：客户端\n此处的Socket服务端相比与原生的Socket，他支持当某一个请求不再发送数据时，服务器端不会等待而是可以去处理其他请求的数据。但是，如果每个请求的耗时比较长时，select版本的服务器端也无法完成同时操作。\n#!/usr/bin/env python #coding:utf8\n\u0026rsquo;\u0026rsquo;\u0026rsquo; 服务器的实现 采用select的方式 \u0026rsquo;\u0026rsquo;\u0026rsquo;\nimport select import socket import sys import Queue #创建套接字并设置该套接字为非阻塞模式 server = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server.setblocking(0) #绑定套接字 server_address = (\u0026rsquo;localhost\u0026rsquo;,10000) print \u0026raquo;sys.stderr,\u0026lsquo;starting up on %s port %s\u0026rsquo;% server_address server.bind(server_address) #将该socket变成服务模式 #backlog等于5，表示内核已经接到了连接请求，但服务器还没有调用accept进行处理的连接个数最大为5 #这个值不能无限大，因为要在内核中维护连接队列 server.listen(5) #初始化读取数据的监听列表,最开始时希望从server这个套接字上读取数据 inputs = [server] #初始化写入数据的监听列表，最开始并没有客户端连接进来，所以列表为空 outputs = [] #要发往客户端的数据 message_queues = {} while inputs: print \u0026raquo;sys.stderr,\u0026lsquo;waiting for the next event\u0026rsquo; #调用select监听所有监听列表中的套接字，并将准备好的套接字加入到对应的列表中 readable,writable,exceptional = select.select(inputs,outputs,inputs)#列表中的socket 套接字 如果是文件呢？ #监控文件句柄有某一处发生了变化 可写 可读 异常属于Linux中的网络编程 #属于同步I/O操作，属于I/O复用模型的一种 #rlist\u0026ndash;等待到准备好读 #wlist\u0026ndash;等待到准备好写 #xlist\u0026ndash;等待到一种异常 #处理可读取的套接字\n''' 如果server这个套接字可读，则说明有新链接到来 此时在server套接字上调用accept,生成一个与客户端通讯的套接字 并将与客户端通讯的套接字加入inputs列表，下一次可以通过select检查连接是否可读 然后在发往客户端的缓冲中加入一项，键名为:与客户端通讯的套接字，键值为空队列 select系统调用是用来让我们的程序监视多个文件句柄(file descrīptor)的状态变化的。程序会停在select这里等待， 直到被监视的文件句柄有某一个或多个发生了状态改变 ''' ''' 若可读的套接字不是server套接字,有两种情况:一种是有数据到来，另一种是链接断开 如果有数据到来,先接收数据,然后将收到的数据填入往客户端的缓存区中的对应位置，最后 将于客户端通讯的套接字加入到写数据的监听列表: 如果套接字可读.但没有接收到数据，则说明客户端已经断开。这时需要关闭与客户端连接的套接字 进行资源清理 ''' for s in readable: if s is server: connection,client\\_address \\= s.accept() print \u0026gt;\u0026gt;sys.stderr,'connection from',client\\_address connection.setblocking(0)#设置非阻塞 inputs.append(connection) message_queues[connection] = Queue.Queue() else: data = s.recv(1024) if data: print \u0026raquo;sys.stderr,\u0026lsquo;received \u0026ldquo;%s\u0026rdquo; from %s\u0026rsquo;% \\ (data,s.getpeername()) message_queues[s].put(data) if s not in outputs: outputs.append(s) else: print \u0026raquo;sys.stderr,\u0026lsquo;closing\u0026rsquo;,client_address if s in outputs: outputs.remove(s) inputs.remove(s) s.close() del message_queues[s] #处理可写的套接字 \u0026rsquo;\u0026rsquo;\u0026rsquo; 在发送缓冲区中取出响应的数据，发往客户端。 如果没有数据需要写，则将套接字从发送队列中移除，select中不再监视 \u0026rsquo;\u0026rsquo;\u0026rsquo;\nfor s in writable: try: next\\_msg \\= message\\_queues\\[s\\].get\\_nowait() except Queue.Empty: print \u0026gt;\u0026gt;sys.stderr,' ',s,getpeername(),'queue empty' outputs.remove(s) else: print \u0026gt;\u0026gt;sys.stderr,'sending \u0026quot;%s\u0026quot; to %s'% \\\\ (next\\_msg,s.getpeername()) s.send(next\\_msg) #处理异常情况 for s in exceptional: for s in exceptional: print \u0026gt;\u0026gt;sys.stderr,'exception condition on',s.getpeername() inputs.remove(s) if s in outputs: outputs.remove(s) s.close() del message\\_queues\\[s\\] 基于select实现socket服务端\nSocketServer模块 SocketServer内部使用 IO多路复用 以及 “多线程” 和 “多进程” ，从而实现并发处理多个客户端请求的Socket服务端。即：每个客户端请求连接到服务器时，Socket服务端都会在服务器是创建一个“线程”或者“进程” 专门负责处理当前客户端的所有请求。\nThreadingTCPServer\nThreadingTCPServer实现的Soket服务器内部会为每个client创建一个 “线程”，该线程用来和客户端进行交互。\n**1、**ThreadingTCPServer基础\n使用ThreadingTCPServer:\n创建一个继承自 SocketServer.BaseRequestHandler 的类 类中必须定义一个名称为 handle 的方法 启动ThreadingTCPServer #!/usr/bin/env python # -*- coding:utf-8 -*- import SocketServer class MyServer(SocketServer.BaseRequestHandler): def handle(self): # print self.request,self.client_address,self.server conn = self.request conn.sendall(\u0026lsquo;欢迎致电 10086，请输入1xxx,0转人工服务.\u0026rsquo;) Flag = True while Flag: data = conn.recv(1024) if data == \u0026rsquo;exit\u0026rsquo;: Flag = False elif data == \u0026lsquo;0\u0026rsquo;: conn.sendall(\u0026lsquo;通过可能会被录音.balabala一大推\u0026rsquo;) else: conn.sendall(\u0026lsquo;请重新输入.\u0026rsquo;) if __name__ == \u0026lsquo;__main__\u0026rsquo;: server = SocketServer.ThreadingTCPServer((\u0026lsquo;127.0.0.1\u0026rsquo;,8009),MyServer) server.serve_forever()\nSocketServer实现服务器\n#!/usr/bin/env python # -*- coding:utf-8 -*-\nimport socket\nip_port = (\u0026lsquo;127.0.0.1\u0026rsquo;,8009) sk = socket.socket() sk.connect(ip_port) sk.settimeout(5) while True: data = sk.recv(1024) print \u0026lsquo;receive:\u0026rsquo;,data inp = raw_input(\u0026lsquo;please input:\u0026rsquo;) sk.sendall(inp) if inp == \u0026rsquo;exit\u0026rsquo;: break sk.close()\n客户端\n**2、**ThreadingTCPServer源码剖析\nThreadingTCPServer的类图关系如下：\n内部调用流程为：\n启动服务端程序 执行 TCPServer.__init__ 方法，创建服务端Socket对象并绑定 IP 和 端口 执行 BaseServer.__init__ 方法，将自定义的继承自SocketServer.BaseRequestHandler 的类 MyRequestHandle赋值给 self.RequestHandlerClass 执行 BaseServer.server_forever 方法，While 循环一直监听是否有客户端请求到达 \u0026hellip; 当客户端连接到达服务器 执行 ThreadingMixIn.process_request 方法，创建一个 “线程” 用来处理请求 执行 ThreadingMixIn.process_request_thread 方法 执行 BaseServer.finish_request 方法，执行 self.RequestHandlerClass() 即：执行 自定义 MyRequestHandler 的构造方法（自动调用基类BaseRequestHandler的构造方法，在该构造方法中又会调用 MyRequestHandler的handle方法） ThreadingTCPServer相关源码：\nclass BaseServer: \u0026ldquo;\u0026ldquo;\u0026ldquo;Base class for server classes.\nMethods for the caller: - \\_\\_init\\_\\_(server\\_address, RequestHandlerClass) - serve\\_forever(poll\\_interval=0.5) - shutdown() - handle\\_request() # if you do not use serve\\_forever() - fileno() -\u0026gt; int # for select() Methods that may be overridden: - server\\_bind() - server\\_activate() - get\\_request() -\u0026gt; request, client\\_address - handle\\_timeout() - verify\\_request(request, client\\_address) - server\\_close() - process\\_request(request, client\\_address) - shutdown\\_request(request) - close\\_request(request) - handle\\_error() Methods for derived classes: - finish\\_request(request, client\\_address) Class variables that may be overridden by derived classes or instances: - timeout - address\\_family - socket\\_type - allow\\_reuse\\_address Instance variables: - RequestHandlerClass - socket \u0026quot;\u0026quot;\u0026quot; timeout \\= None def \\_\\_init\\_\\_(self, server\\_address, RequestHandlerClass): \u0026quot;\u0026quot;\u0026quot;Constructor. May be extended, do not override.\u0026quot;\u0026quot;\u0026quot; self.server\\_address \\= server\\_address self.RequestHandlerClass \\= RequestHandlerClass self.\\_\\_is\\_shut\\_down = threading.Event() self.\\_\\_shutdown\\_request = False def server\\_activate(self): \u0026quot;\u0026quot;\u0026quot;Called by constructor to activate the server. May be overridden. \u0026quot;\u0026quot;\u0026quot; pass def serve\\_forever(self, poll\\_interval=0.5): \u0026quot;\u0026quot;\u0026quot;Handle one request at a time until shutdown. Polls for shutdown every poll\\_interval seconds. Ignores self.timeout. If you need to do periodic tasks, do them in another thread. \u0026quot;\u0026quot;\u0026quot; self.\\_\\_is\\_shut\\_down.clear() try: while not self.\\_\\_shutdown\\_request: # XXX: Consider using another file descriptor or # connecting to the socket to wake this up instead of # polling. Polling reduces our responsiveness to a # shutdown request and wastes cpu at all other times. r, w, e = \\_eintr\\_retry(select.select, \\[self\\], \\[\\], \\[\\], poll\\_interval) if self in r: self.\\_handle\\_request\\_noblock() finally: self.\\_\\_shutdown\\_request = False self.\\_\\_is\\_shut\\_down.set() def shutdown(self): \u0026quot;\u0026quot;\u0026quot;Stops the serve\\_forever loop. Blocks until the loop has finished. This must be called while serve\\_forever() is running in another thread, or it will deadlock. \u0026quot;\u0026quot;\u0026quot; self.\\_\\_shutdown\\_request = True self.\\_\\_is\\_shut\\_down.wait() # The distinction between handling, getting, processing and # finishing a request is fairly arbitrary. Remember: # # - handle\\_request() is the top-level call. It calls # select, get\\_request(), verify\\_request() and process\\_request() # - get\\_request() is different for stream or datagram sockets # - process\\_request() is the place that may fork a new process # or create a new thread to finish the request # - finish\\_request() instantiates the request handler class; # this constructor will handle the request all by itself def handle\\_request(self): \u0026quot;\u0026quot;\u0026quot;Handle one request, possibly blocking. Respects self.timeout. \u0026quot;\u0026quot;\u0026quot; # Support people who used socket.settimeout() to escape # handle\\_request before self.timeout was available. timeout = self.socket.gettimeout() if timeout is None: timeout \\= self.timeout elif self.timeout is not None: timeout \\= min(timeout, self.timeout) fd\\_sets \\= \\_eintr\\_retry(select.select, \\[self\\], \\[\\], \\[\\], timeout) if not fd\\_sets\\[0\\]: self.handle\\_timeout() return self.\\_handle\\_request\\_noblock() def \\_handle\\_request\\_noblock(self): \u0026quot;\u0026quot;\u0026quot;Handle one request, without blocking. I assume that select.select has returned that the socket is readable before this function was called, so there should be no risk of blocking in get\\_request(). \u0026quot;\u0026quot;\u0026quot; try: request, client\\_address \\= self.get\\_request() except socket.error: return if self.verify\\_request(request, client\\_address): try: self.process\\_request(request, client\\_address) except: self.handle\\_error(request, client\\_address) self.shutdown\\_request(request) def handle\\_timeout(self): \u0026quot;\u0026quot;\u0026quot;Called if no new request arrives within self.timeout. Overridden by ForkingMixIn. \u0026quot;\u0026quot;\u0026quot; pass def verify\\_request(self, request, client\\_address): \u0026quot;\u0026quot;\u0026quot;Verify the request. May be overridden. Return True if we should proceed with this request. \u0026quot;\u0026quot;\u0026quot; return True def process\\_request(self, request, client\\_address): \u0026quot;\u0026quot;\u0026quot;Call finish\\_request. Overridden by ForkingMixIn and ThreadingMixIn. \u0026quot;\u0026quot;\u0026quot; self.finish\\_request(request, client\\_address) self.shutdown\\_request(request) def server\\_close(self): \u0026quot;\u0026quot;\u0026quot;Called to clean-up the server. May be overridden. \u0026quot;\u0026quot;\u0026quot; pass def finish\\_request(self, request, client\\_address): \u0026quot;\u0026quot;\u0026quot;Finish one request by instantiating RequestHandlerClass.\u0026quot;\u0026quot;\u0026quot; self.RequestHandlerClass(request, client\\_address, self) def shutdown\\_request(self, request): \u0026quot;\u0026quot;\u0026quot;Called to shutdown and close an individual request.\u0026quot;\u0026quot;\u0026quot; self.close\\_request(request) def close\\_request(self, request): \u0026quot;\u0026quot;\u0026quot;Called to clean up an individual request.\u0026quot;\u0026quot;\u0026quot; pass def handle\\_error(self, request, client\\_address): \u0026quot;\u0026quot;\u0026quot;Handle an error gracefully. May be overridden. The default is to print a traceback and continue. \u0026quot;\u0026quot;\u0026quot; print '\\-'\\*40 print 'Exception happened during processing of request from', print client\\_address import traceback traceback.print\\_exc() # XXX But this goes to stderr! print '\\-'\\*40 BaseServer\nclass TCPServer(BaseServer): \u0026ldquo;\u0026ldquo;\u0026ldquo;Base class for various socket-based server classes.\nDefaults to synchronous IP stream (i.e., TCP). Methods for the caller: - \\_\\_init\\_\\_(server\\_address, RequestHandlerClass, bind\\_and\\_activate=True) - serve\\_forever(poll\\_interval=0.5) - shutdown() - handle\\_request() # if you don't use serve\\_forever() - fileno() -\u0026gt; int # for select() Methods that may be overridden: - server\\_bind() - server\\_activate() - get\\_request() -\u0026gt; request, client\\_address - handle\\_timeout() - verify\\_request(request, client\\_address) - process\\_request(request, client\\_address) - shutdown\\_request(request) - close\\_request(request) - handle\\_error() Methods for derived classes: - finish\\_request(request, client\\_address) Class variables that may be overridden by derived classes or instances: - timeout - address\\_family - socket\\_type - request\\_queue\\_size (only for stream sockets) - allow\\_reuse\\_address Instance variables: - server\\_address - RequestHandlerClass - socket \u0026quot;\u0026quot;\u0026quot; address\\_family \\= socket.AF\\_INET socket\\_type \\= socket.SOCK\\_STREAM request\\_queue\\_size \\= 5 allow\\_reuse\\_address \\= False def \\_\\_init\\_\\_(self, server\\_address, RequestHandlerClass, bind\\_and\\_activate=True): \u0026quot;\u0026quot;\u0026quot;Constructor. May be extended, do not override.\u0026quot;\u0026quot;\u0026quot; BaseServer.\\_\\_init\\_\\_(self, server\\_address, RequestHandlerClass) self.socket \\= socket.socket(self.address\\_family, self.socket\\_type) if bind\\_and\\_activate: try: self.server\\_bind() self.server\\_activate() except: self.server\\_close() raise def server\\_bind(self): \u0026quot;\u0026quot;\u0026quot;Called by constructor to bind the socket. May be overridden. \u0026quot;\u0026quot;\u0026quot; if self.allow\\_reuse\\_address: self.socket.setsockopt(socket.SOL\\_SOCKET, socket.SO\\_REUSEADDR, 1) self.socket.bind(self.server\\_address) self.server\\_address \\= self.socket.getsockname() def server\\_activate(self): \u0026quot;\u0026quot;\u0026quot;Called by constructor to activate the server. May be overridden. \u0026quot;\u0026quot;\u0026quot; self.socket.listen(self.request\\_queue\\_size) def server\\_close(self): \u0026quot;\u0026quot;\u0026quot;Called to clean-up the server. May be overridden. \u0026quot;\u0026quot;\u0026quot; self.socket.close() def fileno(self): \u0026quot;\u0026quot;\u0026quot;Return socket file number. Interface required by select(). \u0026quot;\u0026quot;\u0026quot; return self.socket.fileno() def get\\_request(self): \u0026quot;\u0026quot;\u0026quot;Get the request and client address from the socket. May be overridden. \u0026quot;\u0026quot;\u0026quot; return self.socket.accept() def shutdown\\_request(self, request): \u0026quot;\u0026quot;\u0026quot;Called to shutdown and close an individual request.\u0026quot;\u0026quot;\u0026quot; try: #explicitly shutdown. socket.close() merely releases #the socket and waits for GC to perform the actual close. request.shutdown(socket.SHUT_WR) except socket.error: pass #some platforms may raise ENOTCONN here self.close_request(request) def close_request(self, request): \u0026ldquo;\u0026ldquo;\u0026ldquo;Called to clean up an individual request.\u0026rdquo;\u0026rdquo;\u0026rdquo; request.close()\nTCPServer\nclass ThreadingMixIn: \u0026ldquo;\u0026ldquo;\u0026ldquo;Mix-in class to handle each request in a new thread.\u0026rdquo;\u0026rdquo;\u0026rdquo;\n# Decides how threads will act upon termination of the # main process daemon\\_threads = False def process\\_request\\_thread(self, request, client\\_address): \u0026quot;\u0026quot;\u0026quot;Same as in BaseServer but as a thread. In addition, exception handling is done here. \u0026quot;\u0026quot;\u0026quot; try: self.finish\\_request(request, client\\_address) self.shutdown\\_request(request) except: self.handle\\_error(request, client\\_address) self.shutdown\\_request(request) def process\\_request(self, request, client\\_address): \u0026quot;\u0026quot;\u0026quot;Start a new thread to process the request.\u0026quot;\u0026quot;\u0026quot; t \\= threading.Thread(target = self.process\\_request\\_thread, args \\= (request, client\\_address)) t.daemon \\= self.daemon\\_threads t.start() ThreadingMixIn\nclass ThreadingTCPServer(ThreadingMixIn, TCPServer): pass\nThreadingTCPServer\nRequestHandler相关源码\nclass BaseRequestHandler: \u0026ldquo;\u0026ldquo;\u0026ldquo;Base class for request handler classes.\nThis class is instantiated for each request to be handled. The constructor sets the instance variables request, client\\_address and server, and then calls the handle() method. To implement a specific service, all you need to do is to derive a class which defines a handle() method. The handle() method can find the request as self.request, the client address as self.client\\_address, and the server (in case it needs access to per-server information) as self.server. Since a separate instance is created for each request, the handle() method can define arbitrary other instance variariables. \u0026quot;\u0026quot;\u0026quot; def \\_\\_init\\_\\_(self, request, client\\_address, server): self.request \\= request self.client\\_address \\= client\\_address self.server \\= server self.setup() try: self.handle() finally: self.finish() def setup(self): pass def handle(self): pass def finish(self): pass SocketServer.BaseRequestHandler\n实例：\n#!/usr/bin/env python # -*- coding:utf-8 -*- import SocketServer class MyServer(SocketServer.BaseRequestHandler): def handle(self): # print self.request,self.client_address,self.server conn = self.request conn.sendall(\u0026lsquo;欢迎致电 10086，请输入1xxx,0转人工服务.\u0026rsquo;) Flag = True while Flag: data = conn.recv(1024) if data == \u0026rsquo;exit\u0026rsquo;: Flag = False elif data == \u0026lsquo;0\u0026rsquo;: conn.sendall(\u0026lsquo;通过可能会被录音.balabala一大推\u0026rsquo;) else: conn.sendall(\u0026lsquo;请重新输入.\u0026rsquo;) if __name__ == \u0026lsquo;__main__\u0026rsquo;: server = SocketServer.ThreadingTCPServer((\u0026lsquo;127.0.0.1\u0026rsquo;,8009),MyServer) server.serve_forever()\n服务端\n#!/usr/bin/env python # -*- coding:utf-8 -*-\nimport socket\nip_port = (\u0026lsquo;127.0.0.1\u0026rsquo;,8009) sk = socket.socket() sk.connect(ip_port) sk.settimeout(5) while True: data = sk.recv(1024) print \u0026lsquo;receive:\u0026rsquo;,data inp = raw_input(\u0026lsquo;please input:\u0026rsquo;) sk.sendall(inp) if inp == \u0026rsquo;exit\u0026rsquo;: break sk.close()\n客户端\n源码精简：\nimport socket import threading import select def process(request, client_address): print request,client_address conn = request conn.sendall(\u0026lsquo;欢迎致电 10086，请输入1xxx,0转人工服务.\u0026rsquo;) flag = True while flag: data = conn.recv(1024) if data == \u0026rsquo;exit\u0026rsquo;: flag = False elif data == \u0026lsquo;0\u0026rsquo;: conn.sendall(\u0026lsquo;通过可能会被录音.balabala一大推\u0026rsquo;) else: conn.sendall(\u0026lsquo;请重新输入.\u0026rsquo;)\nsk = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sk.bind((\u0026lsquo;127.0.0.1\u0026rsquo;,8002)) sk.listen(5) while True: r, w, e = select.select([sk,],[],[],1) print \u0026rsquo;looping\u0026rsquo; if sk in r: print \u0026lsquo;get request\u0026rsquo; request, client_address = sk.accept() t = threading.Thread(target=process, args=(request, client_address)) t.daemon = False t.start()\nsk.close()\n如精简代码可以看出，SocketServer的ThreadingTCPServer之所以可以同时处理请求得益于 select 和 Threading 两个东西，其实本质上就是在服务器端为每一个客户端创建一个线程，当前线程用来处理对应客户端的请求，所以，可以支持同时n个客户端链接（长连接）。\nForkingTCPServer\nForkingTCPServer和ThreadingTCPServer的使用和执行流程基本一致，只不过在内部分别为请求者建立 “线程” 和 “进程”。\n基本使用：\n#!/usr/bin/env python # -*- coding:utf-8 -*- import SocketServer class MyServer(SocketServer.BaseRequestHandler): def handle(self): # print self.request,self.client_address,self.server conn = self.request conn.sendall(\u0026lsquo;欢迎致电 10086，请输入1xxx,0转人工服务.\u0026rsquo;) Flag = True while Flag: data = conn.recv(1024) if data == \u0026rsquo;exit\u0026rsquo;: Flag = False elif data == \u0026lsquo;0\u0026rsquo;: conn.sendall(\u0026lsquo;通过可能会被录音.balabala一大推\u0026rsquo;) else: conn.sendall(\u0026lsquo;请重新输入.\u0026rsquo;) if __name__ == \u0026lsquo;__main__\u0026rsquo;: server = SocketServer.ForkingTCPServer((\u0026lsquo;127.0.0.1\u0026rsquo;,8009),MyServer) server.serve_forever()\n服务端\n#!/usr/bin/env python # -*- coding:utf-8 -*-\nimport socket\nip_port = (\u0026lsquo;127.0.0.1\u0026rsquo;,8009) sk = socket.socket() sk.connect(ip_port) sk.settimeout(5) while True: data = sk.recv(1024) print \u0026lsquo;receive:\u0026rsquo;,data inp = raw_input(\u0026lsquo;please input:\u0026rsquo;) sk.sendall(inp) if inp == \u0026rsquo;exit\u0026rsquo;: break sk.close()\n客户端\n以上ForkingTCPServer只是将 ThreadingTCPServer 实例中的代码：\nserver = SocketServer.ThreadingTCPServer((\u0026lsquo;127.0.0.1\u0026rsquo;,8009),MyRequestHandler) 变更为： server = SocketServer.ForkingTCPServer((\u0026lsquo;127.0.0.1\u0026rsquo;,8009),MyRequestHandler)\nSocketServer的ThreadingTCPServer之所以可以同时处理请求得益于 select 和 os.fork 两个东西，其实本质上就是在服务器端为每一个客户端创建一个进程，当前新创建的进程用来处理对应客户端的请求，所以，可以支持同时n个客户端链接（长连接）。\n源码剖析参考 ThreadingTCPServer\nTwisted Twisted是一个事件驱动的网络框架，其中包含了诸多功能，例如：网络协议、线程、数据库管理、网络操作、电子邮件等。\n事件驱动\n简而言之，事件驱动分为二个部分：第一，注册事件；第二，触发事件。\n自定义事件驱动框架，命名为：“弑君者”：\n#!/usr/bin/env python # -*- coding:utf-8 -*-\nevent_drive.py event_list = [] def run(): for event in event_list: obj = event() obj.execute() class BaseHandler(object): \u0026quot;\u0026rdquo;\u0026rdquo; 用户必须继承该类，从而规范所有类的方法（类似于接口的功能） \u0026quot;\u0026rdquo;\u0026rdquo; def execute(self): raise Exception(\u0026lsquo;you must overwrite execute\u0026rsquo;)\n最牛逼的事件驱动框架\n程序员使用“弑君者框架”：\n#!/usr/bin/env python # -*- coding:utf-8 -*-\nfrom source import event_drive class MyHandler(event_drive.BaseHandler): def execute(self): print \u0026rsquo;event-drive execute MyHandler\u0026rsquo; event_drive.event_list.append(MyHandler) event_drive.run()\nView Code\n如上述代码，事件驱动只不过是框架规定了执行顺序，程序员在使用框架时，可以向原执行顺序中注册“事件”，从而在框架执行时可以出发已注册的“事件”。\n基于事件驱动Socket\n#!/usr/bin/env python\n-*- coding:utf-8 -*- from twisted.internet import protocol from twisted.internet import reactor\nclass Echo(protocol.Protocol): def dataReceived(self, data): self.transport.write(data)\ndef main(): factory = protocol.ServerFactory() factory.protocol = Echo\nreactor.listenTCP(8000,factory) reactor.run() if __name__ == \u0026lsquo;__main__\u0026rsquo;: main()\n程序执行流程：\n运行服务端程序 创建Protocol的派生类Echo 创建ServerFactory对象，并将Echo类封装到其protocol字段中 执行reactor的 listenTCP 方法，内部使用 tcp.Port 创建socket server对象，并将该对象添加到了 reactor的set类型的字段 _read 中 执行reactor的 run 方法，内部执行 while 循环，并通过 select 来监视 _read 中文件描述符是否有变化，循环中\u0026hellip; 客户端请求到达 执行reactor的 _doReadOrWrite 方法，其内部通过反射调用 tcp.Port 类的 doRead 方法，内部 accept 客户端连接并创建Server对象实例（用于封装客户端socket信息）和 创建 Echo 对象实例（用于处理请求） ，然后调用 Echo 对象实例的 makeConnection 方法，创建连接。 执行 tcp.Server 类的 doRead 方法，读取数据， 执行 tcp.Server 类的 _dataReceived 方法，如果读取数据内容为空（关闭链接），否则，出发 Echo 的 dataReceived 方法 执行 Echo 的 dataReceived 方法 从源码可以看出，上述实例本质上使用了事件驱动的方法 和 IO多路复用的机制来进行Socket的处理。\n#!/usr/bin/env python # -*- coding:utf-8 -*-\nfrom twisted.internet import reactor, protocol from twisted.web.client import getPage from twisted.internet import reactor import time class Echo(protocol.Protocol): def dataReceived(self, data): deferred1 = getPage(\u0026lsquo;http://cnblogs.com\u0026rsquo;) deferred1.addCallback(self.printContents)\ndeferred2 \\= getPage('http://baidu.com') deferred2.addCallback(self.printContents) for i in range(2): time.sleep(1) print 'execute ',i def execute(self,data): self.transport.write(data) def printContents(self,content): print len(content),content\\[0:100\\],time.time() def main(): factory \\= protocol.ServerFactory() factory.protocol \\= Echo reactor.listenTCP(8000,factory) reactor.run() if \\_\\_name\\_\\_ == '\\_\\_main\\_\\_': main() 异步IO操作\n更多请见：\nhttps://twistedmatrix.com/trac\nhttp://twistedmatrix.com/documents/current/api/\n","permalink":"https://water711.github.io/posts/2017-04-11-python%E5%BC%80%E5%8F%91%E7%AC%AC%E5%85%AB%E7%AF%87%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","tags":null,"title":"Python开发【第八篇】：网络编程"},{"categories":["python"],"contents":"三元运算 三元运算（三目运算），是对简单的条件语句的缩写。\n# 书写格式\nresult = 值1 if 条件 else 值2\n如果条件成立，那么将 “值1” 赋值给result变量，否则，将“值2”赋值给result变量 基本数据类型补充 set\nset集合，是一个无序且不重复的元素集合\nclass set(object): \u0026quot;\u0026quot;\u0026quot; set() -\u0026gt; new empty set object set(iterable) -\u0026gt; new set object\nBuild an unordered collection of unique elements. \u0026quot;\u0026quot;\u0026quot; def add(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Add an element to a set，添加元素 This has no effect if the element is already present. \u0026quot;\u0026quot;\u0026quot; pass def clear(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Remove all elements from this set. 清除内容\u0026quot;\u0026quot;\u0026quot; pass def copy(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Return a shallow copy of a set. 浅拷贝 \u0026quot;\u0026quot;\u0026quot; pass def difference(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Return the difference of two or more sets as a new set. A中存在，B中不存在 (i.e. all elements that are in this set but not the others.) \u0026quot;\u0026quot;\u0026quot; pass def difference\\_update(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Remove all elements of another set from this set. 从当前集合中删除和B中相同的元素\u0026quot;\u0026quot;\u0026quot; pass def discard(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Remove an element from a set if it is a member. If the element is not a member, do nothing. 移除指定元素，不存在不保错 \u0026quot;\u0026quot;\u0026quot; pass def intersection(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Return the intersection of two sets as a new set. 交集 (i.e. all elements that are in both sets.) \u0026quot;\u0026quot;\u0026quot; pass def intersection\\_update(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Update a set with the intersection of itself and another. 取交集并更更新到A中 \u0026quot;\u0026quot;\u0026quot; pass def isdisjoint(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Return True if two sets have a null intersection. 如果没有交集，返回True，否则返回False\u0026quot;\u0026quot;\u0026quot; pass def issubset(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Report whether another set contains this set. 是否是子序列\u0026quot;\u0026quot;\u0026quot; pass def issuperset(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Report whether this set contains another set. 是否是父序列\u0026quot;\u0026quot;\u0026quot; pass def pop(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Remove and return an arbitrary set element. Raises KeyError if the set is empty. 移除元素 \u0026quot;\u0026quot;\u0026quot; pass def remove(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Remove an element from a set; it must be a member. If the element is not a member, raise a KeyError. 移除指定元素，不存在保错 \u0026quot;\u0026quot;\u0026quot; pass def symmetric\\_difference(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Return the symmetric difference of two sets as a new set. 对称差集 (i.e. all elements that are in exactly one of the sets.) \u0026quot;\u0026quot;\u0026quot; pass def symmetric\\_difference\\_update(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Update a set with the symmetric difference of itself and another. 对称差集，并更新到a中 \u0026quot;\u0026quot;\u0026quot; pass def union(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Return the union of sets as a new set. 并集 (i.e. all elements that are in either set.) \u0026quot;\u0026quot;\u0026quot; pass def update(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Update a set with the union of itself and others. 更新 \u0026quot;\u0026quot;\u0026quot; pass **练习：**寻找差异\n# 数据库中原有 old_dict = { \u0026ldquo;#1\u0026rdquo;:{ \u0026lsquo;hostname\u0026rsquo;:c1, \u0026lsquo;cpu_count\u0026rsquo;: 2, \u0026lsquo;mem_capicity\u0026rsquo;: 80 }, \u0026ldquo;#2\u0026rdquo;:{ \u0026lsquo;hostname\u0026rsquo;:c1, \u0026lsquo;cpu_count\u0026rsquo;: 2, \u0026lsquo;mem_capicity\u0026rsquo;: 80 } \u0026ldquo;#3\u0026rdquo;:{ \u0026lsquo;hostname\u0026rsquo;:c1, \u0026lsquo;cpu_count\u0026rsquo;: 2, \u0026lsquo;mem_capicity\u0026rsquo;: 80 } }\ncmdb 新汇报的数据 new_dict = { \u0026ldquo;#1\u0026rdquo;:{ \u0026lsquo;hostname\u0026rsquo;:c1, \u0026lsquo;cpu_count\u0026rsquo;: 2, \u0026lsquo;mem_capicity\u0026rsquo;: 800 }, \u0026ldquo;#3\u0026rdquo;:{ \u0026lsquo;hostname\u0026rsquo;:c1, \u0026lsquo;cpu_count\u0026rsquo;: 2, \u0026lsquo;mem_capicity\u0026rsquo;: 80 } \u0026ldquo;#4\u0026rdquo;:{ \u0026lsquo;hostname\u0026rsquo;:c2, \u0026lsquo;cpu_count\u0026rsquo;: 2, \u0026lsquo;mem_capicity\u0026rsquo;: 80 } }\n需要删除：？ ``需要新建：？ ``需要更新：？ 注意：无需考虑内部元素是否改变，只要原来存在，新汇报也存在，就是需要更新\n深浅拷贝 一、数字和字符串\n对于 数字 和 字符串 而言，赋值、浅拷贝和深拷贝无意义，因为其永远指向同一个内存地址。\nimport copy\n######### 数字、字符串 n1 = 123\nn1 = \u0026ldquo;i am alex age 10\u0026rdquo; print(id(n1))\n## 赋值 n2 = n1 print(id(n2))\n## 浅拷贝 n2 = copy.copy(n1) print(id(n2))\n## 深拷贝 n3 = copy.deepcopy(n1) print(id(n3))\n二、其他基本数据类型\n对于字典、元祖、列表 而言，进行赋值、浅拷贝和深拷贝时，其内存地址的变化是不同的。\n1、赋值\n赋值，只是创建一个变量，该变量指向原来内存地址，如：\nn1 = {\u0026ldquo;k1\u0026rdquo;: \u0026ldquo;wu\u0026rdquo;, \u0026ldquo;k2\u0026rdquo;: 123, \u0026ldquo;k3\u0026rdquo;: [\u0026ldquo;alex\u0026rdquo;, 456]}\nn2 = n1\n2、浅拷贝\n浅拷贝，在内存中只额外创建第一层数据\nimport copy\nn1 = {\u0026ldquo;k1\u0026rdquo;: \u0026ldquo;wu\u0026rdquo;, \u0026ldquo;k2\u0026rdquo;: 123, \u0026ldquo;k3\u0026rdquo;: [\u0026ldquo;alex\u0026rdquo;, 456]}\nn3 = copy.copy(n1)\n3、深拷贝\n深拷贝，在内存中将所有的数据重新创建一份（排除最后一层，即：python内部对字符串和数字的优化）\nimport copy\nn1 = {\u0026ldquo;k1\u0026rdquo;: \u0026ldquo;wu\u0026rdquo;, \u0026ldquo;k2\u0026rdquo;: 123, \u0026ldquo;k3\u0026rdquo;: [\u0026ldquo;alex\u0026rdquo;, 456]}\nn4 = copy.deepcopy(n1)\n函数 一、背景\n在学习函数之前，一直遵循：面向过程编程，即：根据业务逻辑从上到下实现功能，其往往用一长段代码来实现指定功能，开发过程中最常见的操作就是粘贴复制，也就是将之前实现的代码块复制到现需功能处，如下：\nwhile True： if cpu利用率 \u0026gt; 90%: #发送邮件提醒 连接邮箱服务器 发送邮件 关闭连接\nif 硬盘使用空间 \u0026gt; 90%: #发送邮件提醒 连接邮箱服务器 发送邮件 关闭连接 if 内存占用 \u0026gt; 80%: #发送邮件提醒 连接邮箱服务器 发送邮件 关闭连接 腚眼一看上述代码，if条件语句下的内容可以被提取出来公用，如下：\ndef 发送邮件(内容) #发送邮件提醒 连接邮箱服务器 发送邮件 关闭连接\nwhile True：\nif cpu利用率 \u0026gt; 90%: 发送邮件('CPU报警') if 硬盘使用空间 \u0026gt; 90%: 发送邮件('硬盘报警') if 内存占用 \u0026gt; 80%: 对于上述的两种实现方式，第二次必然比第一次的重用性和可读性要好，其实这就是函数式编程和面向过程编程的区别：\n函数式：将某功能代码封装到函数中，日后便无需重复编写，仅调用函数即可 面向对象：对函数进行分类和封装，让开发“更快更好更强\u0026hellip;” 函数式编程最重要的是增强代码的重用性和可读性\n二、定义和使用\ndef 函数名(参数):\n... 函数体 ... 返回值 函数的定义主要有如下要点：\ndef：表示函数的关键字 函数名：函数的名称，日后根据函数名调用函数 函数体：函数中进行一系列的逻辑计算，如：发送邮件、计算出 [11,22,38,888,2]中的最大数等\u0026hellip; 参数：为函数体提供数据 返回值：当函数执行完毕后，可以给调用者返回数据。 1、返回值\n函数是一个功能块，该功能到底执行成功与否，需要通过返回值来告知调用者。\n以上要点中，比较重要有参数和返回值：\ndef 发送短信():\n发送短信的代码... if 发送成功: return True else: return False while True:\n# 每次执行发送短信函数，都会将返回值自动赋值给result # 之后，可以根据result来写日志，或重发等操作 result = 发送短信() if result == False: 记录日志，短信发送失败... 2、参数\n为什么要有参数？\ndef CPU报警邮件() #发送邮件提醒 连接邮箱服务器 发送邮件 关闭连接 def 硬盘报警邮件() #发送邮件提醒 连接邮箱服务器 发送邮件 关闭连接 def 内存报警邮件() #发送邮件提醒 连接邮箱服务器 发送邮件 关闭连接 while True： if cpu利用率 \u0026gt; 90%: CPU报警邮件（） if 硬盘使用空间 \u0026gt; 90%: 硬盘报警邮件（） if 内存占用 \u0026gt; 80%: 内存报警邮件（）\n无参数实现\ndef 发送邮件(邮件内容) #发送邮件提醒 连接邮箱服务器 发送邮件 关闭连接 while True： if cpu利用率 \u0026gt; 90%: 发送邮件(\u0026ldquo;CPU报警了。\u0026rdquo;) if 硬盘使用空间 \u0026gt; 90%: 发送邮件(\u0026ldquo;硬盘报警了。\u0026rdquo;) if 内存占用 \u0026gt; 80%: 发送邮件(\u0026ldquo;内存报警了。\u0026rdquo;)\n有参数实现\n函数的有三中不同的参数：\n普通参数 默认参数 动态参数 ######### 定义函数 name 叫做函数func的形式参数，简称：形参 def func(name): print name # ######### 执行函数 #########\n\u0026lsquo;wupeiqi\u0026rsquo; 叫做函数func的实际参数，简称：实参 func(\u0026lsquo;wupeiqi\u0026rsquo;)\n普通参数\ndef func(name, age = 18): print \u0026ldquo;%s:%s\u0026rdquo; %(name,age) # 指定参数 func(\u0026lsquo;wupeiqi\u0026rsquo;, 19) # 使用默认参数 func(\u0026lsquo;alex\u0026rsquo;)\n注：默认参数需要放在参数列表最后\n默认参数\ndef func(*args): print args # 执行方式一 func(11,33,4,4454,5) # 执行方式二 li = [11,2,2,3,3,4,54] func(*li)\n动态参数\ndef func(**kwargs): print args # 执行方式一 func(name＝\u0026rsquo;wupeiqi\u0026rsquo;,age=18) # 执行方式二 li = {\u0026rsquo;name\u0026rsquo;:\u0026lsquo;wupeiqi\u0026rsquo;, age:18, \u0026lsquo;gender\u0026rsquo;:\u0026lsquo;male\u0026rsquo;} func(**li)\n动态参数\ndef func(*args, **kwargs): print args print kwargs\n动态参数\n扩展：发送邮件实例\nimport smtplib from email.mime.text import MIMEText from email.utils import formataddr\nmsg = MIMEText(\u0026lsquo;邮件内容\u0026rsquo;, \u0026lsquo;plain\u0026rsquo;, \u0026lsquo;utf-8\u0026rsquo;) msg[\u0026lsquo;From\u0026rsquo;] = formataddr([\u0026ldquo;武沛齐\u0026rdquo;,\u0026lsquo;wptawy@126.com\u0026rsquo;]) msg[\u0026lsquo;To\u0026rsquo;] = formataddr([\u0026ldquo;走人\u0026rdquo;,\u0026lsquo;424662508@qq.com\u0026rsquo;]) msg[\u0026lsquo;Subject\u0026rsquo;] = \u0026ldquo;主题\u0026rdquo; server = smtplib.SMTP(\u0026ldquo;smtp.126.com\u0026rdquo;, 25) server.login(\u0026ldquo;wptawy@126.com\u0026rdquo;, \u0026ldquo;邮箱密码\u0026rdquo;) server.sendmail(\u0026lsquo;wptawy@126.com\u0026rsquo;, [\u0026lsquo;424662508@qq.com\u0026rsquo;,], msg.as_string()) server.quit()\n发送邮件实例\n内置函数 注：查看详细猛击这里\nopen函数，该函数用于文件处理\n操作文件时，一般需要经历如下步骤：\n打开文件 操作文件 一、打开文件\n文件句柄 = open(\u0026lsquo;文件路径\u0026rsquo;, \u0026lsquo;模式\u0026rsquo;)\n打开文件时，需要指定文件路径和以何等方式打开文件，打开后，即可获取该文件句柄，日后通过此文件句柄对该文件操作。\n打开文件的模式有：\nr ，只读模式【默认】 w，只写模式【不可读；不存在则创建；存在则清空内容；】 x， 只写模式【不可读；不存在则创建，存在则报错】 a， 追加模式【可读； 不存在则创建；存在则只追加内容；】 \u0026ldquo;+\u0026rdquo; 表示可以同时读写某个文件\nr+， 读写【可读，可写】 w+，写读【可读，可写】 x+ ，写读【可读，可写】 a+， 写读【可读，可写】 \u0026ldquo;b\u0026quot;表示以字节的方式操作\nrb 或 r+b wb 或 w+b xb 或 w+b ab 或 a+b 注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型\n二、操作\nclass file(object) def close(self): # real signature unknown; restored from __doc__ 关闭文件 \u0026quot;\u0026rdquo;\u0026quot; close() -\u0026gt; None or (perhaps) an integer. Close the file.\nSets data attribute .closed to True. A closed file cannot be used for further I/O operations. close() may be called more than once without error. Some kinds of file objects (for example, opened by popen()) may return an exit status upon closing. \u0026quot;\u0026quot;\u0026quot; def fileno(self): # real signature unknown; restored from \\_\\_doc\\_\\_ 文件描述符 \u0026quot;\u0026quot;\u0026quot; fileno() -\u0026gt; integer \u0026ldquo;file descriptor\u0026rdquo;.\nThis is needed for lower-level file interfaces, such os.read(). \u0026quot;\u0026quot;\u0026quot; return 0 def flush(self): # real signature unknown; restored from \\_\\_doc\\_\\_ 刷新文件内部缓冲区 \u0026quot;\u0026quot;\u0026quot; flush() -\u0026gt; None. Flush the internal I/O buffer. \u0026quot;\u0026quot;\u0026quot; pass\ndef isatty(self): # real signature unknown; restored from \\_\\_doc\\_\\_ 判断文件是否是同意tty设备 \u0026quot;\u0026quot;\u0026quot; isatty() -\u0026gt; true or false. True if the file is connected to a tty device. \u0026quot;\u0026quot;\u0026quot; return False def next(self): # real signature unknown; restored from __doc__ 获取下一行数据，不存在，则报错 \u0026quot;\u0026quot;\u0026quot; x.next() -\u0026gt; the next value, or raise StopIteration \u0026quot;\u0026quot;\u0026quot; pass\ndef read(self, size=None): # real signature unknown; restored from \\_\\_doc\\_\\_ 读取指定字节数据 \u0026quot;\u0026quot;\u0026quot; read([size]) -\u0026gt; read at most size bytes, returned as a string.\nIf the size argument is negative or omitted, read until EOF is reached. Notice that when in non-blocking mode, less data than what was requested may be returned, even if no size parameter was given. \u0026quot;\u0026quot;\u0026quot; pass def readinto(self): # real signature unknown; restored from \\_\\_doc\\_\\_ 读取到缓冲区，不要用，将被遗弃 \u0026quot;\u0026quot;\u0026quot; readinto() -\u0026gt; Undocumented. Don\u0026rsquo;t use this; it may go away. \u0026quot;\u0026quot;\u0026quot; pass\ndef readline(self, size=None): # real signature unknown; restored from \\_\\_doc\\_\\_ 仅读取一行数据 \u0026quot;\u0026quot;\u0026quot; readline([size]) -\u0026gt; next line from the file, as a string.\nRetain newline. A non-negative size argument limits the maximum number of bytes to return (an incomplete line may be returned then). Return an empty string at EOF. \u0026quot;\u0026quot;\u0026quot; pass def readlines(self, size=None): # real signature unknown; restored from \\_\\_doc\\_\\_ 读取所有数据，并根据换行保存值列表 \u0026quot;\u0026quot;\u0026quot; readlines([size]) -\u0026gt; list of strings, each a line from the file.\nCall readline() repeatedly and return a list of the lines so read. The optional size argument, if given, is an approximate bound on the total number of bytes in the lines returned. \u0026quot;\u0026quot;\u0026quot; return \\[\\] def seek(self, offset, whence=None): # real signature unknown; restored from \\_\\_doc\\_\\_ 指定文件中指针位置 \u0026quot;\u0026quot;\u0026quot; seek(offset[, whence]) -\u0026gt; None. Move to new file position.\nArgument offset is a byte count. Optional argument whence defaults to (offset from start of file, offset should be \u0026gt;= 0); other values are 1 (move relative to current position, positive or negative), and 2 (move relative to end of file, usually negative, although many platforms allow seeking beyond the end of a file). If the file is opened in text mode, only offsets returned by tell() are legal. Use of other offsets causes undefined behavior. Note that not all file objects are seekable. \u0026quot;\u0026quot;\u0026quot; pass\ndef tell(self): # real signature unknown; restored from \\_\\_doc\\_\\_ 获取当前指针位置 \u0026quot;\u0026quot;\u0026quot; tell() -\u0026gt; current file position, an integer (may be a long integer). \u0026quot;\u0026quot;\u0026quot; pass\ndef truncate(self, size=None): # real signature unknown; restored from \\_\\_doc\\_\\_ 截断数据，仅保留指定之前数据 \u0026quot;\u0026quot;\u0026quot; truncate([size]) -\u0026gt; None. Truncate the file to at most size bytes.\nSize defaults to the current file position, as returned by tell(). \u0026quot;\u0026quot;\u0026quot; pass def write(self, p\\_str): # real signature unknown; restored from \\_\\_doc\\_\\_ 写内容 \u0026quot;\u0026quot;\u0026quot; write(str) -\u0026gt; None. Write string str to file.\nNote that due to buffering, flush() or close() may be needed before the file on disk reflects the data written. \u0026quot;\u0026quot;\u0026quot; pass def writelines(self, sequence\\_of\\_strings): # real signature unknown; restored from \\_\\_doc\\_\\_ 将一个字符串列表写入文件 \u0026quot;\u0026quot;\u0026quot; writelines(sequence_of_strings) -\u0026gt; None. Write the strings to the file.\nNote that newlines are not added. The sequence can be any iterable object producing strings. This is equivalent to calling write() for each string. \u0026quot;\u0026quot;\u0026quot; pass def xreadlines(self): # real signature unknown; restored from \\_\\_doc\\_\\_ 可用于逐行读取文件，非全部 \u0026quot;\u0026quot;\u0026quot; xreadlines() -\u0026gt; returns self.\nFor backward compatibility. File objects now include the performance optimizations previously implemented in the xreadlines module. \u0026quot;\u0026quot;\u0026quot; pass 2.x\nclass TextIOWrapper(_TextIOBase): \u0026quot;\u0026quot;\u0026quot; Character and line based layer over a BufferedIOBase object, buffer.\nencoding gives the name of the encoding that the stream will be decoded or encoded with. It defaults to locale.getpreferredencoding(False). errors determines the strictness of encoding and decoding (see help(codecs.Codec) or the documentation for codecs.register) and defaults to \u0026quot;strict\u0026quot;. newline controls how line endings are handled. It can be None, '', '\\\\n', '\\\\r', and '\\\\r\\\\n'. It works as follows: \\* On input, if newline is None, universal newlines mode is enabled. Lines in the input can end in '\\\\n', '\\\\r', or '\\\\r\\\\n', and these are translated into '\\\\n' before being returned to the caller. If it is '', universal newline mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated. \\* On output, if newline is None, any '\\\\n' characters written are translated to the system default line separator, os.linesep. If newline is '' or '\\\\n', no translation takes place. If newline is any of the other legal values, any '\\\\n' characters written are translated to the given string. If line\\_buffering is True, a call to flush is implied when a call to write contains a newline character. \u0026quot;\u0026quot;\u0026quot; def close(self, \\*args, \\*\\*kwargs): # real signature unknown 关闭文件 pass\ndef fileno(self, \\*args, \\*\\*kwargs): # real signature unknown 文件描述符 pass\ndef flush(self, \\*args, \\*\\*kwargs): # real signature unknown 刷新文件内部缓冲区 pass\ndef isatty(self, \\*args, \\*\\*kwargs): # real signature unknown 判断文件是否是同意tty设备 pass\ndef read(self, \\*args, \\*\\*kwargs): # real signature unknown 读取指定字节数据 pass\ndef readable(self, \\*args, \\*\\*kwargs): # real signature unknown 是否可读 pass\ndef readline(self, \\*args, \\*\\*kwargs): # real signature unknown 仅读取一行数据 pass\ndef seek(self, \\*args, \\*\\*kwargs): # real signature unknown 指定文件中指针位置 pass\ndef seekable(self, \\*args, \\*\\*kwargs): # real signature unknown 指针是否可操作 pass\ndef tell(self, \\*args, \\*\\*kwargs): # real signature unknown 获取指针位置 pass\ndef truncate(self, \\*args, \\*\\*kwargs): # real signature unknown 截断数据，仅保留指定之前数据 pass\ndef writable(self, \\*args, \\*\\*kwargs): # real signature unknown 是否可写 pass\ndef write(self, \\*args, \\*\\*kwargs): # real signature unknown 写内容 pass\ndef \\_\\_getstate\\_\\_(self, \\*args, \\*\\*kwargs): # real signature unknown pass def \\_\\_init\\_\\_(self, \\*args, \\*\\*kwargs): # real signature unknown pass @staticmethod # known case of \\_\\_new\\_\\_ def \\_\\_new\\_\\_(\\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Create and return a new object. See help(type) for accurate signature. \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_next\\_\\_(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Implement next(self). \u0026quot;\u0026quot;\u0026quot; pass def \\_\\_repr\\_\\_(self, \\*args, \\*\\*kwargs): # real signature unknown \u0026quot;\u0026quot;\u0026quot; Return repr(self). \u0026quot;\u0026quot;\u0026quot; pass buffer \\= property(lambda self: object(), lambda self, v: None, lambda self: None) # default closed = property(lambda self: object(), lambda self, v: None, lambda self: None) # default encoding = property(lambda self: object(), lambda self, v: None, lambda self: None) # default errors = property(lambda self: object(), lambda self, v: None, lambda self: None) # default line_buffering = property(lambda self: object(), lambda self, v: None, lambda self: None) # default name = property(lambda self: object(), lambda self, v: None, lambda self: None) # default newlines = property(lambda self: object(), lambda self, v: None, lambda self: None) # default _CHUNK_SIZE = property(lambda self: object(), lambda self, v: None, lambda self: None) # default _finalizing = property(lambda self: object(), lambda self, v: None, lambda self: None) # default\n3.x\n三、管理上下文\n为了避免打开文件后忘记关闭，可以通过管理上下文，即：\nwith open(\u0026rsquo;log\u0026rsquo;,\u0026lsquo;r\u0026rsquo;) as f:\n... 如此方式，当with代码块执行完毕时，内部会自动关闭并释放文件资源。\n在Python 2.7 及以后，with又支持同时对多个文件的上下文进行管理，即：\nwith open(\u0026rsquo;log1\u0026rsquo;) as obj1, open(\u0026rsquo;log2\u0026rsquo;) as obj2: pass\nlambda表达式 学习条件运算时，对于简单的 if else 语句，可以使用三元运算来表示，即：\n# 普通条件语句 if 1 == 1: name = \u0026lsquo;wupeiqi\u0026rsquo; else: name = \u0026lsquo;alex\u0026rsquo;\n三元运算 name = \u0026lsquo;wupeiqi\u0026rsquo; if 1 == 1 else \u0026lsquo;alex\u0026rsquo;\n对于简单的函数，也存在一种简便的表示方式，即：lambda表达式\n# ###################### 普通函数 ######################\n定义函数（普通方式） def func(arg): return arg + 1\n执行函数 result = func(123)\n###################### lambda 定义函数（lambda表达式） my_lambda = lambda arg : arg + 1\n执行函数 result = my_lambda(123)\n递归 利用函数编写如下数列：\n斐波那契数列指的是这样一个数列 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368\u0026hellip;\ndef func(arg1,arg2): if arg1 == 0: print arg1, arg2 arg3 = arg1 + arg2 print arg3 func(arg2, arg3)\nfunc(0,1)\n练习题 1、简述普通参数、指定参数、默认参数、动态参数的区别\n2、写函数，计算传入字符串中【数字】、【字母】、【空格] 以及 【其他】的个数\n3、写函数，判断用户传入的对象（字符串、列表、元组）长度是否大于5。\n4、写函数，检查用户传入的对象（字符串、列表、元组）的每一个元素是否含有空内容。\n5、写函数，检查传入列表的长度，如果大于2，那么仅保留前两个长度的内容，并将新内容返回给调用者。\n6、写函数，检查获取传入列表或元组对象的所有奇数位索引对应的元素，并将其作为新列表返回给调用者。\n7、写函数，检查传入字典的每一个value的长度,如果大于2，那么仅保留前两个长度的内容，并将新内容返回给调用者。\ndic = {\u0026ldquo;k1\u0026rdquo;: \u0026ldquo;v1v1\u0026rdquo;, \u0026ldquo;k2\u0026rdquo;: [11,22,33,44]}\nPS:字典中的value只能是字符串或列表\n8、写函数，利用递归获取斐波那契数列中的第 10 个数，并将该值返回给调用者。\n","permalink":"https://water711.github.io/posts/2017-04-11-python%E5%BC%80%E5%8F%91%E7%AC%AC%E5%9B%9B%E7%AF%87python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/","tags":null,"title":"Python开发【第四篇】：Python基础之函数"},{"categories":["python"],"contents":"模块，用一砣代码实现了某个功能的代码集合。\n类似于函数式编程和面向过程编程，函数式编程则完成一个功能，其他代码用来调用即可，提供了代码的重用性和代码间的耦合。而对于一个复杂的功能来，可能需要多个函数才能完成（函数又可以在不同的.py文件中），n个 .py 文件组成的代码集合就称为模块。\n如：os 是系统相关的模块；file是文件操作相关的模块\n模块分为三种：\n自定义模块 第三方模块 内置模块 自定义模块 1、定义模块\n情景一：\n情景二：\n情景三：\n2、导入模块\nPython之所以应用越来越广泛，在一定程度上也依赖于其为程序员提供了大量的模块以供使用，如果想要使用模块，则需要导入。导入模块有一下几种方法：\nimport module from module.xx.xx import xx from module.xx.xx import xx as rename\nfrom module.xx.xx import *\n导入模块其实就是告诉Python解释器去解释那个py文件\n导入一个py文件，解释器解释该py文件 导入一个包，解释器解释该包下的 __init__.py 文件 【py2.7】 那么问题来了，导入模块时是根据那个路径作为基准来进行的呢？即：sys.path\nimport sys print sys.path\n结果： [\u0026rsquo;/Users/wupeiqi/PycharmProjects/calculator/p1/pp1\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/setuptools-15.2-py2.7.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/distribute-0.6.28-py2.7.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/MySQL_python-1.2.4b4-py2.7-macosx-10.10-x86_64.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/xlutils-1.7.1-py2.7.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/xlwt-1.0.0-py2.7.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/xlrd-0.9.3-py2.7.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/tornado-4.1-py2.7-macosx-10.10-x86_64.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/backports.ssl_match_hostname-3.4.0.2-py2.7.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/certifi-2015.4.28-py2.7.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/pyOpenSSL-0.15.1-py2.7.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/six-1.9.0-py2.7.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/cryptography-0.9.1-py2.7-macosx-10.10-x86_64.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/cffi-1.1.1-py2.7-macosx-10.10-x86_64.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/ipaddress-1.0.7-py2.7.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/enum34-1.0.4-py2.7.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/pyasn1-0.1.7-py2.7.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/idna-2.0-py2.7.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/pycparser-2.13-py2.7.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/Django-1.7.8-py2.7.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/paramiko-1.10.1-py2.7.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/gevent-1.0.2-py2.7-macosx-10.10-x86_64.egg\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages/greenlet-0.4.7-py2.7-macosx-10.10-x86_64.egg\u0026rsquo;, \u0026lsquo;/Users/wupeiqi/PycharmProjects/calculator\u0026rsquo;, \u0026lsquo;/usr/local/Cellar/python/2.7.9/Frameworks/Python.framework/Versions/2.7/lib/python27.zip\u0026rsquo;, \u0026lsquo;/usr/local/Cellar/python/2.7.9/Frameworks/Python.framework/Versions/2.7/lib/python2.7\u0026rsquo;, \u0026lsquo;/usr/local/Cellar/python/2.7.9/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-darwin\u0026rsquo;, \u0026lsquo;/usr/local/Cellar/python/2.7.9/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac\u0026rsquo;, \u0026lsquo;/usr/local/Cellar/python/2.7.9/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac/lib-scriptpackages\u0026rsquo;, \u0026lsquo;/usr/local/Cellar/python/2.7.9/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-tk\u0026rsquo;, \u0026lsquo;/usr/local/Cellar/python/2.7.9/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-old\u0026rsquo;, \u0026lsquo;/usr/local/Cellar/python/2.7.9/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload\u0026rsquo;, \u0026lsquo;/usr/local/lib/python2.7/site-packages\u0026rsquo;, \u0026lsquo;/Library/Python/2.7/site-packages\u0026rsquo;]\n如果sys.path路径列表没有你想要的路径，可以通过 sys.path.append(\u0026lsquo;路径\u0026rsquo;) 添加。\nimport sys import os project_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) sys.path.append(project_path)\n模块 内置模块是Python自带的功能，在使用内置模块相应的功能时，需要【先导入】再【使用】\n一、sys 用于提供对Python解释器相关的操作：\nsys.argv 命令行参数List，第一个元素是程序本身路径 sys.exit(n) 退出程序，正常退出时exit(0) sys.version 获取Python解释程序的版本信息 sys.maxint 最大的Int值 sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 sys.platform 返回操作系统平台名称 sys.stdin 输入相关 sys.stdout 输出相关 sys.stderror 错误相关\nimport sys import time def view_bar(num, total): rate = float(num) / float(total) rate_num = int(rate * 100) r = \u0026lsquo;\\r%d%%\u0026rsquo; % (rate_num, ) sys.stdout.write(r) sys.stdout.flush() if __name__ == \u0026lsquo;__main__\u0026rsquo;: for i in range(0, 100): time.sleep(0.1) view_bar(i, 100)\n进度百分比\n二、os 用于提供系统级别的操作：\nos.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径 os.chdir(\u0026ldquo;dirname\u0026rdquo;) 改变当前脚本工作目录；相当于shell下cd os.curdir 返回当前目录: (\u0026rsquo;.\u0026rsquo;) os.pardir 获取当前目录的父目录字符串名：(\u0026rsquo;..\u0026rsquo;) os.makedirs(\u0026lsquo;dir1/dir2\u0026rsquo;) 可生成多层递归目录 os.removedirs(\u0026lsquo;dirname1\u0026rsquo;) 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.mkdir(\u0026lsquo;dirname\u0026rsquo;) 生成单级目录；相当于shell中mkdir dirname os.rmdir(\u0026lsquo;dirname\u0026rsquo;) 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname os.listdir(\u0026lsquo;dirname\u0026rsquo;) 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 os.remove() 删除一个文件 os.rename(\u0026ldquo;oldname\u0026rdquo;,\u0026ldquo;new\u0026rdquo;) 重命名文件/目录 os.stat(\u0026lsquo;path/filename\u0026rsquo;) 获取文件/目录信息 os.sep 操作系统特定的路径分隔符，win下为\u0026quot;\\\\\u0026quot;,Linux下为\u0026quot;/\u0026quot; os.linesep 当前平台使用的行终止符，win下为\u0026quot;\\t\\n\u0026quot;,Linux下为\u0026quot;\\n\u0026quot; os.pathsep 用于分割文件路径的字符串 os.name 字符串指示当前使用平台。win-\u0026gt;\u0026lsquo;nt\u0026rsquo;; Linux-\u0026gt;\u0026lsquo;posix\u0026rsquo; os.system(\u0026ldquo;bash command\u0026rdquo;) 运行shell命令，直接显示 os.environ 获取系统环境变量 os.path.abspath(path) 返回path规范化的绝对路径 os.path.split(path) 将path分割成目录和文件名二元组返回 os.path.dirname(path) 返回path的目录。其实就是os.path.split(path)的第一个元素 os.path.basename(path) 返回path最后的文件名。如何path以／或\\结尾，那么就会返回空值。即os.path.split(path)的第二个元素 os.path.exists(path) 如果path存在，返回True；如果path不存在，返回False os.path.isabs(path) 如果path是绝对路径，返回True os.path.isfile(path) 如果path是一个存在的文件，返回True。否则返回False os.path.isdir(path) 如果path是一个存在的目录，则返回True。否则返回False os.path.join(path1[, path2[, \u0026hellip;]]) 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 os.path.getatime(path) 返回path所指向的文件或者目录的最后存取时间 os.path.getmtime(path) 返回path所指向的文件或者目录的最后修改时间\n三、hashlib 用于加密相关的操作，代替了md5模块和sha模块，主要提供 SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法\nimport hashlib\n######## md5 hash = hashlib.md5()\nhelp(hash.update) hash.update(bytes(\u0026lsquo;admin\u0026rsquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;)) print(hash.hexdigest()) print(hash.digest())\n######## sha1 ########\nhash = hashlib.sha1() hash.update(bytes(\u0026lsquo;admin\u0026rsquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;)) print(hash.hexdigest())\n######## sha256 hash = hashlib.sha256() hash.update(bytes(\u0026lsquo;admin\u0026rsquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;)) print(hash.hexdigest())\n######## sha384 hash = hashlib.sha384() hash.update(bytes(\u0026lsquo;admin\u0026rsquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;)) print(hash.hexdigest())\n######## sha512 hash = hashlib.sha512() hash.update(bytes(\u0026lsquo;admin\u0026rsquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;)) print(hash.hexdigest())\n以上加密算法虽然依然非常厉害，但时候存在缺陷，即：通过撞库可以反解。所以，有必要对加密算法中添加自定义key再来做加密。\nimport hashlib\n######## md5 hash = hashlib.md5(bytes(\u0026lsquo;898oaFs09f\u0026rsquo;,encoding=\u0026ldquo;utf-8\u0026rdquo;)) hash.update(bytes(\u0026lsquo;admin\u0026rsquo;,encoding=\u0026ldquo;utf-8\u0026rdquo;)) print(hash.hexdigest())\npython内置还有一个 hmac 模块，它内部对我们创建 key 和 内容 进行进一步的处理然后再加密\nimport hmac\nh = hmac.new(bytes(\u0026lsquo;898oaFs09f\u0026rsquo;,encoding=\u0026ldquo;utf-8\u0026rdquo;)) h.update(bytes(\u0026lsquo;admin\u0026rsquo;,encoding=\u0026ldquo;utf-8\u0026rdquo;)) print(h.hexdigest())\n四、random import random\nprint(random.random()) print(random.randint(1, 2)) print(random.randrange(1, 10))\nimport random checkcode = \u0026rsquo;\u0026rsquo; for i in range(4): current = random.randrange(0,4) if current != i: temp = chr(random.randint(65,90)) else: temp = random.randint(0,9) checkcode += str(temp) print checkcode\n随机验证码\n五、re python中re模块提供了正则表达式相关操作\n字符：\n. 匹配除换行符以外的任意字符\n\\w 匹配字母或数字或下划线或汉字\n\\s 匹配任意的空白符\n\\d 匹配数字\n\\b 匹配单词的开始或结束\n^ 匹配字符串的开始\n$ 匹配字符串的结束\n次数：\n* 重复零次或更多次\n+ 重复一次或更多次\n? 重复零次或一次\n{n} 重复n次\n{n,} 重复n次或更多次\n{n,m} 重复n到m次\nmatch\n# match，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None match(pattern, string, flags=0) # pattern： 正则模型 # string ： 要匹配的字符串 # falgs ： 匹配模式 X VERBOSE Ignore whitespace and comments for nicer looking RE's. I IGNORECASE Perform case-insensitive matching. M MULTILINE \u0026quot;^\u0026quot; matches the beginning of lines (after a newline) as well as the string. \u0026quot;$\u0026quot; matches the end of lines (before a newline) as well as the end of the string. S DOTALL \u0026quot;.\u0026quot; matches any character at all, including the newline. A ASCII For string patterns, make \\\\w, \\\\W, \\\\b, \\\\B, \\\\d, \\\\D match the corresponding ASCII character categories (rather than the whole Unicode categories, which is the default). For bytes patterns, this flag is the only available behaviour and needn't be specified. L LOCALE Make \\\\w, \\\\W, \\\\b, \\\\B, dependent on the current locale. U UNICODE For compatibility only. Ignored for string patterns (it is the default), and forbidden for bytes patterns. # 无分组 r = re.match(\u0026quot;h\\\\w+\u0026quot;, origin) print(r.group()) # 获取匹配到的所有结果 print(r.groups()) # 获取模型中匹配到的分组结果 print(r.groupdict()) # 获取模型中匹配到的分组结果 # 有分组 # 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来） r = re.match(\u0026ldquo;h(\\w+).*(?P\\d)$\u0026rdquo;, origin) print(r.group()) # 获取匹配到的所有结果 print(r.groups()) # 获取模型中匹配到的分组结果 print(r.groupdict()) # 获取模型中匹配到的分组中所有执行了key的组\nDemo\nsearch\n# search,浏览整个字符串去匹配第一个，未匹配成功返回None\nsearch(pattern, string, flags=0) # 无分组 r = re.search(\u0026ldquo;a\\w+\u0026rdquo;, origin) print(r.group()) # 获取匹配到的所有结果 print(r.groups()) # 获取模型中匹配到的分组结果 print(r.groupdict()) # 获取模型中匹配到的分组结果\n# 有分组 r = re.search(\u0026ldquo;a(\\w+).*(?P\\d)$\u0026rdquo;, origin) print(r.group()) # 获取匹配到的所有结果 print(r.groups()) # 获取模型中匹配到的分组结果 print(r.groupdict()) # 获取模型中匹配到的分组中所有执行了key的组\ndemo\nfindall\n# findall，获取非重复的匹配列表；如果有一个组则以列表形式返回，且每一个匹配均是字符串；如果模型中有多个组，则以列表形式返回，且每一个匹配均是元祖； # 空的匹配也会包含在结果中 #findall(pattern, string, flags=0) # 无分组 r = re.findall(\u0026quot;a\\\\w+\u0026quot;,origin) print(r) # 有分组 origin = \u0026quot;hello alex bcd abcd lge acd 19\u0026quot; r \\= re.findall(\u0026quot;a((\\\\w\\*)c)(d)\u0026quot;, origin) print(r) Demo\nsub\n# sub，替换匹配成功的指定位置字符串 sub(pattern, repl, string, count=0, flags=0) # pattern： 正则模型 # repl ： 要替换的字符串或可执行对象 # string ： 要匹配的字符串 # count ： 指定匹配个数 # flags ： 匹配模式 # 与分组无关 origin = \u0026ldquo;hello alex bcd alex lge alex acd 19\u0026rdquo; r = re.sub(\u0026ldquo;a\\w+\u0026rdquo;, \u0026ldquo;999\u0026rdquo;, origin, 2) print(r)\nDemo\nsplit\n# split，根据正则匹配分割字符串 split(pattern, string, maxsplit=0, flags=0) # pattern： 正则模型 # string ： 要匹配的字符串 # maxsplit：指定分割个数 # flags ： 匹配模式 # 无分组 origin = \u0026quot;hello alex bcd alex lge alex acd 19\u0026quot; r \\= re.split(\u0026quot;alex\u0026quot;, origin, 1) print(r) # 有分组 origin = \u0026ldquo;hello alex bcd alex lge alex acd 19\u0026rdquo; r1 = re.split(\u0026quot;(alex)\u0026quot;, origin, 1) print(r1) r2 = re.split(\u0026quot;(al(ex))\u0026quot;, origin, 1) print(r2)\nDemo\nIP： ^(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}$ 手机号： ^1[3|4|5|8][0-9]\\d{8}$ 邮箱： [a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+\n常用正则表达式\n六、序列化 Python中用于序列化的两个模块\njson 用于【字符串】和 【python基本数据类型】 间进行转换 pickle 用于【python特有的类型】 和 【python基本数据类型】间进行转换 Json模块提供了四个功能：dumps、dump、loads、load\npickle模块提供了四个功能：dumps、dump、loads、load\n七、configparser configparser用于处理特定格式的文件，其本质上是利用open来操作文件。\n# 注释1 ; 注释2\n[section1] # 节点 k1 = v1 # 值 k2:v2 # 值 [section2] # 节点 k1 = v1 # 值\n指定格式\n1、获取所有节点\nimport configparser\nconfig = configparser.ConfigParser() config.read(\u0026lsquo;xxxooo\u0026rsquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;) ret = config.sections() print(ret)\n2、获取指定节点下所有的键值对\nimport configparser\nconfig = configparser.ConfigParser() config.read(\u0026lsquo;xxxooo\u0026rsquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;) ret = config.items(\u0026lsquo;section1\u0026rsquo;) print(ret)\n3、获取指定节点下所有的建\nimport configparser\nconfig = configparser.ConfigParser() config.read(\u0026lsquo;xxxooo\u0026rsquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;) ret = config.options(\u0026lsquo;section1\u0026rsquo;) print(ret)\n4、获取指定节点下指定key的值\nimport configparser\nconfig = configparser.ConfigParser() config.read(\u0026lsquo;xxxooo\u0026rsquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;)\nv = config.get(\u0026lsquo;section1\u0026rsquo;, \u0026lsquo;k1\u0026rsquo;)\nv = config.getint(\u0026lsquo;section1\u0026rsquo;, \u0026lsquo;k1\u0026rsquo;) v = config.getfloat(\u0026lsquo;section1\u0026rsquo;, \u0026lsquo;k1\u0026rsquo;) v = config.getboolean(\u0026lsquo;section1\u0026rsquo;, \u0026lsquo;k1\u0026rsquo;) print(v)\n5、检查、删除、添加节点\nimport configparser\nconfig = configparser.ConfigParser() config.read(\u0026lsquo;xxxooo\u0026rsquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;)\n检查 has_sec = config.has_section(\u0026lsquo;section1\u0026rsquo;) print(has_sec)\n添加节点 config.add_section(\u0026ldquo;SEC_1\u0026rdquo;) config.write(open(\u0026lsquo;xxxooo\u0026rsquo;, \u0026lsquo;w\u0026rsquo;))\n删除节点 config.remove_section(\u0026ldquo;SEC_1\u0026rdquo;) config.write(open(\u0026lsquo;xxxooo\u0026rsquo;, \u0026lsquo;w\u0026rsquo;))\n6、检查、删除、设置指定组内的键值对\nimport configparser\nconfig = configparser.ConfigParser() config.read(\u0026lsquo;xxxooo\u0026rsquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;)\n检查 has_opt = config.has_option(\u0026lsquo;section1\u0026rsquo;, \u0026lsquo;k1\u0026rsquo;) print(has_opt)\n删除 config.remove_option(\u0026lsquo;section1\u0026rsquo;, \u0026lsquo;k1\u0026rsquo;) config.write(open(\u0026lsquo;xxxooo\u0026rsquo;, \u0026lsquo;w\u0026rsquo;))\n设置 config.set(\u0026lsquo;section1\u0026rsquo;, \u0026lsquo;k10\u0026rsquo;, \u0026ldquo;123\u0026rdquo;) config.write(open(\u0026lsquo;xxxooo\u0026rsquo;, \u0026lsquo;w\u0026rsquo;))\n八、XML XML是实现不同语言或程序之间进行数据交换的协议，XML文件格式如下：\n\u0026lt;data\u0026gt; \u0026lt;country name=\u0026ldquo;Liechtenstein\u0026rdquo;\u0026gt; \u0026lt;rank updated=\u0026ldquo;yes\u0026rdquo;\u0026gt;2rank\u0026gt; \u0026lt;year\u0026gt;2023year\u0026gt; \u0026lt;gdppc\u0026gt;141100gdppc\u0026gt; \u0026lt;neighbor direction=\u0026ldquo;E\u0026rdquo; name=\u0026ldquo;Austria\u0026rdquo; /\u0026gt; \u0026lt;neighbor direction=\u0026ldquo;W\u0026rdquo; name=\u0026ldquo;Switzerland\u0026rdquo; /\u0026gt; country\u0026gt; \u0026lt;country name=\u0026ldquo;Singapore\u0026rdquo;\u0026gt; \u0026lt;rank updated=\u0026ldquo;yes\u0026rdquo;\u0026gt;5rank\u0026gt; \u0026lt;year\u0026gt;2026year\u0026gt; \u0026lt;gdppc\u0026gt;59900gdppc\u0026gt; \u0026lt;neighbor direction=\u0026ldquo;N\u0026rdquo; name=\u0026ldquo;Malaysia\u0026rdquo; /\u0026gt; country\u0026gt; \u0026lt;country name=\u0026ldquo;Panama\u0026rdquo;\u0026gt; \u0026lt;rank updated=\u0026ldquo;yes\u0026rdquo;\u0026gt;69rank\u0026gt; \u0026lt;year\u0026gt;2026year\u0026gt; \u0026lt;gdppc\u0026gt;13600gdppc\u0026gt; \u0026lt;neighbor direction=\u0026ldquo;W\u0026rdquo; name=\u0026ldquo;Costa Rica\u0026rdquo; /\u0026gt; \u0026lt;neighbor direction=\u0026ldquo;E\u0026rdquo; name=\u0026ldquo;Colombia\u0026rdquo; /\u0026gt; country\u0026gt; data\u0026gt;\n1、解析XML\nfrom xml.etree import ElementTree as ET # 打开文件，读取XML内容 str_xml = open(\u0026lsquo;xo.xml\u0026rsquo;, \u0026lsquo;r\u0026rsquo;).read() # 将字符串解析成xml特殊对象，root代指xml文件的根节点 root = ET.XML(str_xml)\n利用ElementTree.XML将字符串解析成xml对象\nfrom xml.etree import ElementTree as ET # 直接解析xml文件 tree = ET.parse(\u0026ldquo;xo.xml\u0026rdquo;) # 获取xml文件的根节点 root = tree.getroot()\n利用ElementTree.parse将文件直接解析成xml对象\n2、操作XML\nXML格式类型是节点嵌套节点，对于每一个节点均有以下功能，以便对当前节点进行操作：\nclass Element: \u0026ldquo;\u0026ldquo;\u0026ldquo;An XML element.\nThis class is the reference implementation of the Element interface. An element's length is its number of subelements. That means if you want to check if an element is truly empty, you should check BOTH its length AND its text attribute. The element tag, attribute names, and attribute values can be either bytes or strings. \\*tag\\* is the element name. \\*attrib\\* is an optional dictionary containing element attributes. \\*extra\\* are additional element attributes given as keyword arguments. Example form: text...tail \u0026quot;\u0026quot;\u0026quot; 当前节点的标签名 tag \\= None \u0026quot;\u0026quot;\u0026quot;The element's name.\u0026quot;\u0026quot;\u0026quot; 当前节点的属性 attrib \\= None \u0026quot;\u0026quot;\u0026quot;Dictionary of the element's attributes.\u0026quot;\u0026quot;\u0026quot; 当前节点的内容 text \\= None \u0026quot;\u0026quot;\u0026quot; Text before first subelement. This is either a string or the value None. Note that if there is no text, this attribute may be either None or the empty string, depending on the parser. \u0026quot;\u0026quot;\u0026quot; tail \\= None \u0026quot;\u0026quot;\u0026quot; Text after this element's end tag, but before the next sibling element's start tag. This is either a string or the value None. Note that if there was no text, this attribute may be either None or an empty string, depending on the parser. \u0026quot;\u0026quot;\u0026quot; def \\_\\_init\\_\\_(self, tag, attrib={}, \\*\\*extra): if not isinstance(attrib, dict): raise TypeError(\u0026quot;attrib must be dict, not %s\u0026quot; % ( attrib.\\_\\_class\\_\\_.\\_\\_name\\_\\_,)) attrib \\= attrib.copy() attrib.update(extra) self.tag \\= tag self.attrib \\= attrib self.\\_children \\= \\[\\] def \\_\\_repr\\_\\_(self): return \u0026quot;\u0026lt;%s %r at %#x\u0026gt;\u0026quot; % (self.\\_\\_class\\_\\_.\\_\\_name\\_\\_, self.tag, id(self)) def makeelement(self, tag, attrib): 创建一个新节点 \u0026quot;\u0026quot;\u0026quot;Create a new element with the same type. \\*tag\\* is a string containing the element name. \\*attrib\\* is a dictionary containing the element attributes. Do not call this method, use the SubElement factory function instead. \u0026quot;\u0026quot;\u0026quot; return self.\\_\\_class\\_\\_(tag, attrib) def copy(self): \u0026quot;\u0026quot;\u0026quot;Return copy of current element. This creates a shallow copy. Subelements will be shared with the original tree. \u0026quot;\u0026quot;\u0026quot; elem \\= self.makeelement(self.tag, self.attrib) elem.text \\= self.text elem.tail \\= self.tail elem\\[:\\] \\= self return elem def \\_\\_len\\_\\_(self): return len(self.\\_children) def \\_\\_bool\\_\\_(self): warnings.warn( \u0026quot;The behavior of this method will change in future versions. \u0026quot; \u0026quot;Use specific 'len(elem)' or 'elem is not None' test instead.\u0026quot;, FutureWarning, stacklevel\\=2 ) return len(self.\\_children) != 0 # emulate old behaviour, for now def \\_\\_getitem\\_\\_(self, index): return self.\\_children\\[index\\] def \\_\\_setitem\\_\\_(self, index, element): # if isinstance(index, slice): # for elt in element: # assert iselement(elt) # else: # assert iselement(element) self.\\_children\\[index\\] = element def \\_\\_delitem\\_\\_(self, index): del self.\\_children\\[index\\] def append(self, subelement): 为当前节点追加一个子节点 \u0026quot;\u0026quot;\u0026quot;Add \\*subelement\\* to the end of this element. The new element will appear in document order after the last existing subelement (or directly after the text, if it's the first subelement), but before the end tag for this element. \u0026quot;\u0026quot;\u0026quot; self.\\_assert\\_is\\_element(subelement) self.\\_children.append(subelement) def extend(self, elements): 为当前节点扩展 n 个子节点 \u0026quot;\u0026quot;\u0026quot;Append subelements from a sequence. \\*elements\\* is a sequence with zero or more elements. \u0026quot;\u0026quot;\u0026quot; for element in elements: self.\\_assert\\_is\\_element(element) self.\\_children.extend(elements) def insert(self, index, subelement): 在当前节点的子节点中插入某个节点，即：为当前节点创建子节点，然后插入指定位置 \u0026quot;\u0026quot;\u0026quot;Insert \\*subelement\\* at position \\*index\\*.\u0026quot;\u0026quot;\u0026quot; self.\\_assert\\_is\\_element(subelement) self.\\_children.insert(index, subelement) def \\_assert\\_is\\_element(self, e): # Need to refer to the actual Python implementation, not the # shadowing C implementation. if not isinstance(e, \\_Element\\_Py): raise TypeError('expected an Element, not %s' % type(e).\\_\\_name\\_\\_) def remove(self, subelement): 在当前节点在子节点中删除某个节点 \u0026quot;\u0026quot;\u0026quot;Remove matching subelement. Unlike the find methods, this method compares elements based on identity, NOT ON tag value or contents. To remove subelements by other means, the easiest way is to use a list comprehension to select what elements to keep, and then use slice assignment to update the parent element. ValueError is raised if a matching element could not be found. \u0026quot;\u0026quot;\u0026quot; # assert iselement(element) self._children.remove(subelement) def getchildren(self): 获取所有的子节点（废弃） \u0026ldquo;\u0026rdquo;\u0026quot;(Deprecated) Return all subelements.\nElements are returned in document order. \u0026quot;\u0026quot;\u0026quot; warnings.warn( \u0026quot;This method will be removed in future versions. \u0026quot; \u0026quot;Use 'list(elem)' or iteration over elem instead.\u0026quot;, DeprecationWarning, stacklevel\\=2 ) return self.\\_children def find(self, path, namespaces=None): 获取第一个寻找到的子节点 \u0026quot;\u0026quot;\u0026quot;Find first matching element by tag name or path. \\*path\\* is a string having either an element tag or an XPath, \\*namespaces\\* is an optional mapping from namespace prefix to full name. Return the first matching element, or None if no element was found. \u0026quot;\u0026quot;\u0026quot; return ElementPath.find(self, path, namespaces) def findtext(self, path, default=None, namespaces=None): 获取第一个寻找到的子节点的内容 \u0026quot;\u0026quot;\u0026quot;Find text for first matching element by tag name or path. \\*path\\* is a string having either an element tag or an XPath, \\*default\\* is the value to return if the element was not found, \\*namespaces\\* is an optional mapping from namespace prefix to full name. Return text content of first matching element, or default value if none was found. Note that if an element is found having no text content, the empty string is returned. \u0026quot;\u0026quot;\u0026quot; return ElementPath.findtext(self, path, default, namespaces) def findall(self, path, namespaces=None): 获取所有的子节点 \u0026quot;\u0026quot;\u0026quot;Find all matching subelements by tag name or path. \\*path\\* is a string having either an element tag or an XPath, \\*namespaces\\* is an optional mapping from namespace prefix to full name. Returns list containing all matching elements in document order. \u0026quot;\u0026quot;\u0026quot; return ElementPath.findall(self, path, namespaces) def iterfind(self, path, namespaces=None): 获取所有指定的节点，并创建一个迭代器（可以被for循环） \u0026quot;\u0026quot;\u0026quot;Find all matching subelements by tag name or path. \\*path\\* is a string having either an element tag or an XPath, \\*namespaces\\* is an optional mapping from namespace prefix to full name. Return an iterable yielding all matching elements in document order. \u0026quot;\u0026quot;\u0026quot; return ElementPath.iterfind(self, path, namespaces) def clear(self): 清空节点 \u0026quot;\u0026quot;\u0026quot;Reset element. This function removes all subelements, clears all attributes, and sets the text and tail attributes to None. \u0026quot;\u0026quot;\u0026quot; self.attrib.clear() self.\\_children \\= \\[\\] self.text \\= self.tail = None def get(self, key, default=None): 获取当前节点的属性值 \u0026quot;\u0026quot;\u0026quot;Get element attribute. Equivalent to attrib.get, but some implementations may handle this a bit more efficiently. \\*key\\* is what attribute to look for, and \\*default\\* is what to return if the attribute was not found. Returns a string containing the attribute value, or the default if attribute was not found. \u0026quot;\u0026quot;\u0026quot; return self.attrib.get(key, default) def set(self, key, value): 为当前节点设置属性值 \u0026quot;\u0026quot;\u0026quot;Set element attribute. Equivalent to attrib\\[key\\] = value, but some implementations may handle this a bit more efficiently. \\*key\\* is what attribute to set, and \\*value\\* is the attribute value to set it to. \u0026quot;\u0026quot;\u0026quot; self.attrib\\[key\\] \\= value def keys(self): 获取当前节点的所有属性的 key \u0026quot;\u0026quot;\u0026quot;Get list of attribute names. Names are returned in an arbitrary order, just like an ordinary Python dict. Equivalent to attrib.keys() \u0026quot;\u0026quot;\u0026quot; return self.attrib.keys() def items(self): 获取当前节点的所有属性值，每个属性都是一个键值对 \u0026quot;\u0026quot;\u0026quot;Get element attributes as a sequence. The attributes are returned in arbitrary order. Equivalent to attrib.items(). Return a list of (name, value) tuples. \u0026quot;\u0026quot;\u0026quot; return self.attrib.items() def iter(self, tag=None): 在当前节点的子孙中根据节点名称寻找所有指定的节点，并返回一个迭代器（可以被for循环）。 \u0026quot;\u0026quot;\u0026quot;Create tree iterator. The iterator loops over the element and all subelements in document order, returning all elements with a matching tag. If the tree structure is modified during iteration, new or removed elements may or may not be included. To get a stable set, use the list() function on the iterator, and loop over the resulting list. \\*tag\\* is what tags to look for (default is to return all elements) Return an iterator containing all the matching elements. \u0026quot;\u0026quot;\u0026quot; if tag == \u0026quot;\\*\u0026quot;: tag \\= None if tag is None or self.tag == tag: yield self for e in self.\\_children: yield from e.iter(tag) # compatibility def getiterator(self, tag=None): # Change for a DeprecationWarning in 1.4 warnings.warn( \u0026ldquo;This method will be removed in future versions. \u0026quot; \u0026ldquo;Use \u0026rsquo;elem.iter()\u0026rsquo; or \u0026rsquo;list(elem.iter())\u0026rsquo; instead.\u0026rdquo;, PendingDeprecationWarning, stacklevel=2 ) return list(self.iter(tag)) def itertext(self): 在当前节点的子孙中根据节点名称寻找所有指定的节点的内容，并返回一个迭代器（可以被for循环）。 \u0026ldquo;\u0026ldquo;\u0026ldquo;Create text iterator.\nThe iterator loops over the element and all subelements in document order, returning all inner text. \u0026quot;\u0026quot;\u0026quot; tag \\= self.tag if not isinstance(tag, str) and tag is not None: return if self.text: yield self.text for e in self: yield from e.itertext() if e.tail: yield e.tail 节点功能一览表\n由于 每个节点 都具有以上的方法，并且在上一步骤中解析时均得到了root（xml文件的根节点），so 可以利用以上方法进行操作xml文件。\na. 遍历XML文档的所有内容\nfrom xml.etree import ElementTree as ET ############ 解析方式一 ############ \u0026quot;\u0026rdquo;\u0026rdquo; # 打开文件，读取XML内容 str_xml = open(\u0026lsquo;xo.xml\u0026rsquo;, \u0026lsquo;r\u0026rsquo;).read()\n将字符串解析成xml特殊对象，root代指xml文件的根节点 root = ET.XML(str_xml) \u0026quot;\u0026rdquo;\u0026rdquo; ############ 解析方式二 ############\n直接解析xml文件 tree = ET.parse(\u0026ldquo;xo.xml\u0026rdquo;) # 获取xml文件的根节点 root = tree.getroot() ### 操作\n顶层标签 print(root.tag) # 遍历XML文档的第二层 for child in root: # 第二层节点的标签名称和标签属性 print(child.tag, child.attrib) # 遍历XML文档的第三层 for i in child: # 第二层节点的标签名称和内容 print(i.tag,i.text)\nView Code\nb、遍历XML中指定的节点\nfrom xml.etree import ElementTree as ET ############ 解析方式一 ############ \u0026quot;\u0026rdquo;\u0026rdquo; # 打开文件，读取XML内容 str_xml = open(\u0026lsquo;xo.xml\u0026rsquo;, \u0026lsquo;r\u0026rsquo;).read()\n将字符串解析成xml特殊对象，root代指xml文件的根节点 root = ET.XML(str_xml) \u0026quot;\u0026rdquo;\u0026quot; ############ 解析方式二 ############\n直接解析xml文件 tree = ET.parse(\u0026ldquo;xo.xml\u0026rdquo;) # 获取xml文件的根节点 root = tree.getroot() ### 操作\n顶层标签 print(root.tag) # 遍历XML中所有的year节点 for node in root.iter(\u0026lsquo;year\u0026rsquo;): # 节点的标签名称和内容 print(node.tag, node.text)\nView Code\nc、修改节点内容\n由于修改的节点时，均是在内存中进行，其不会影响文件中的内容。所以，如果想要修改，则需要重新将内存中的内容写到文件。\nfrom xml.etree import ElementTree as ET ############ 解析方式一 ############\n打开文件，读取XML内容 str_xml = open(\u0026lsquo;xo.xml\u0026rsquo;, \u0026lsquo;r\u0026rsquo;).read() # 将字符串解析成xml特殊对象，root代指xml文件的根节点 root = ET.XML(str_xml) ############ 操作 ############\n顶层标签 print(root.tag) # 循环所有的year节点 for node in root.iter(\u0026lsquo;year\u0026rsquo;): # 将year节点中的内容自增一 new_year = int(node.text) + 1 node.text = str(new_year) # 设置属性 node.set(\u0026rsquo;name\u0026rsquo;, \u0026lsquo;alex\u0026rsquo;) node.set(\u0026lsquo;age\u0026rsquo;, \u0026lsquo;18\u0026rsquo;) # 删除属性 del node.attrib[\u0026rsquo;name\u0026rsquo;] ############ 保存文件 ############ tree = ET.ElementTree(root) tree.write(\u0026ldquo;newnew.xml\u0026rdquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;)\n解析字符串方式，修改，保存\nfrom xml.etree import ElementTree as ET ############ 解析方式二 ############\n直接解析xml文件 tree = ET.parse(\u0026ldquo;xo.xml\u0026rdquo;) # 获取xml文件的根节点 root = tree.getroot() ############ 操作 ############\n顶层标签 print(root.tag) # 循环所有的year节点 for node in root.iter(\u0026lsquo;year\u0026rsquo;): # 将year节点中的内容自增一 new_year = int(node.text) + 1 node.text = str(new_year) # 设置属性 node.set(\u0026rsquo;name\u0026rsquo;, \u0026lsquo;alex\u0026rsquo;) node.set(\u0026lsquo;age\u0026rsquo;, \u0026lsquo;18\u0026rsquo;) # 删除属性 del node.attrib[\u0026rsquo;name\u0026rsquo;] ############ 保存文件 ############ tree.write(\u0026ldquo;newnew.xml\u0026rdquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;)\n解析文件方式，修改，保存\nd、删除节点\nfrom xml.etree import ElementTree as ET ############ 解析字符串方式打开 ############\n打开文件，读取XML内容 str_xml = open(\u0026lsquo;xo.xml\u0026rsquo;, \u0026lsquo;r\u0026rsquo;).read() # 将字符串解析成xml特殊对象，root代指xml文件的根节点 root = ET.XML(str_xml) ############ 操作 ############\n顶层标签 print(root.tag) # 遍历data下的所有country节点 for country in root.findall(\u0026lsquo;country\u0026rsquo;): # 获取每一个country节点下rank节点的内容 rank = int(country.find(\u0026lsquo;rank\u0026rsquo;).text) if rank \u0026gt; 50: # 删除指定country节点 root.remove(country) ############ 保存文件 ############ tree = ET.ElementTree(root) tree.write(\u0026ldquo;newnew.xml\u0026rdquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;)\n解析字符串方式打开，删除，保存\nfrom xml.etree import ElementTree as ET ############ 解析文件方式 ############\n直接解析xml文件 tree = ET.parse(\u0026ldquo;xo.xml\u0026rdquo;) # 获取xml文件的根节点 root = tree.getroot() ############ 操作 ############\n顶层标签 print(root.tag) # 遍历data下的所有country节点 for country in root.findall(\u0026lsquo;country\u0026rsquo;): # 获取每一个country节点下rank节点的内容 rank = int(country.find(\u0026lsquo;rank\u0026rsquo;).text) if rank \u0026gt; 50: # 删除指定country节点 root.remove(country) ############ 保存文件 ############ tree.write(\u0026ldquo;newnew.xml\u0026rdquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;)\n解析文件方式打开，删除，保存\n3、创建XML文档\nfrom xml.etree import ElementTree as ET # 创建根节点 root = ET.Element(\u0026ldquo;famliy\u0026rdquo;) # 创建节点大儿子 son1 = ET.Element(\u0026lsquo;son\u0026rsquo;, {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿1\u0026rsquo;}) # 创建小儿子 son2 = ET.Element(\u0026lsquo;son\u0026rsquo;, {\u0026ldquo;name\u0026rdquo;: \u0026lsquo;儿2\u0026rsquo;}) # 在大儿子中创建两个孙子 grandson1 = ET.Element(\u0026lsquo;grandson\u0026rsquo;, {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿11\u0026rsquo;}) grandson2 = ET.Element(\u0026lsquo;grandson\u0026rsquo;, {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿12\u0026rsquo;}) son1.append(grandson1) son1.append(grandson2) # 把儿子添加到根节点中 root.append(son1) root.append(son1)\ntree = ET.ElementTree(root) tree.write(\u0026lsquo;oooo.xml\u0026rsquo;,encoding=\u0026lsquo;utf-8\u0026rsquo;, short_empty_elements=False)\n创建方式（一）\nfrom xml.etree import ElementTree as ET # 创建根节点 root = ET.Element(\u0026ldquo;famliy\u0026rdquo;) # 创建大儿子 # son1 = ET.Element(\u0026lsquo;son\u0026rsquo;, {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿1\u0026rsquo;}) son1 = root.makeelement(\u0026lsquo;son\u0026rsquo;, {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿1\u0026rsquo;}) # 创建小儿子 # son2 = ET.Element(\u0026lsquo;son\u0026rsquo;, {\u0026ldquo;name\u0026rdquo;: \u0026lsquo;儿2\u0026rsquo;}) son2 = root.makeelement(\u0026lsquo;son\u0026rsquo;, {\u0026ldquo;name\u0026rdquo;: \u0026lsquo;儿2\u0026rsquo;}) # 在大儿子中创建两个孙子 # grandson1 = ET.Element(\u0026lsquo;grandson\u0026rsquo;, {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿11\u0026rsquo;}) grandson1 = son1.makeelement(\u0026lsquo;grandson\u0026rsquo;, {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿11\u0026rsquo;}) # grandson2 = ET.Element(\u0026lsquo;grandson\u0026rsquo;, {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿12\u0026rsquo;}) grandson2 = son1.makeelement(\u0026lsquo;grandson\u0026rsquo;, {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿12\u0026rsquo;})\nson1.append(grandson1) son1.append(grandson2) # 把儿子添加到根节点中 root.append(son1) root.append(son1)\ntree = ET.ElementTree(root) tree.write(\u0026lsquo;oooo.xml\u0026rsquo;,encoding=\u0026lsquo;utf-8\u0026rsquo;, short_empty_elements=False)\n创建方式（二）\nfrom xml.etree import ElementTree as ET # 创建根节点 root = ET.Element(\u0026ldquo;famliy\u0026rdquo;) # 创建节点大儿子 son1 = ET.SubElement(root, \u0026ldquo;son\u0026rdquo;, attrib={\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿1\u0026rsquo;}) # 创建小儿子 son2 = ET.SubElement(root, \u0026ldquo;son\u0026rdquo;, attrib={\u0026ldquo;name\u0026rdquo;: \u0026ldquo;儿2\u0026rdquo;}) # 在大儿子中创建一个孙子 grandson1 = ET.SubElement(son1, \u0026ldquo;age\u0026rdquo;, attrib={\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿11\u0026rsquo;}) grandson1.text = \u0026lsquo;孙子\u0026rsquo; et = ET.ElementTree(root) #生成文档对象 et.write(\u0026ldquo;test.xml\u0026rdquo;, encoding=\u0026ldquo;utf-8\u0026rdquo;, xml_declaration=True, short_empty_elements=False)\n创建方式（三）\n由于原生保存的XML时默认无缩进，如果想要设置缩进的话， 需要修改保存方式：\nfrom xml.etree import ElementTree as ET from xml.dom import minidom def prettify(elem): \u0026ldquo;\u0026ldquo;\u0026ldquo;将节点转换成字符串，并添加缩进。 \u0026quot;\u0026rdquo;\u0026rdquo; rough_string = ET.tostring(elem, \u0026lsquo;utf-8\u0026rsquo;) reparsed = minidom.parseString(rough_string) return reparsed.toprettyxml(indent=\u0026rdquo;\\t\u0026quot;) # 创建根节点 root = ET.Element(\u0026ldquo;famliy\u0026rdquo;) # 创建大儿子 # son1 = ET.Element(\u0026lsquo;son\u0026rsquo;, {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿1\u0026rsquo;}) son1 = root.makeelement(\u0026lsquo;son\u0026rsquo;, {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿1\u0026rsquo;}) # 创建小儿子 # son2 = ET.Element(\u0026lsquo;son\u0026rsquo;, {\u0026ldquo;name\u0026rdquo;: \u0026lsquo;儿2\u0026rsquo;}) son2 = root.makeelement(\u0026lsquo;son\u0026rsquo;, {\u0026ldquo;name\u0026rdquo;: \u0026lsquo;儿2\u0026rsquo;}) # 在大儿子中创建两个孙子 # grandson1 = ET.Element(\u0026lsquo;grandson\u0026rsquo;, {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿11\u0026rsquo;}) grandson1 = son1.makeelement(\u0026lsquo;grandson\u0026rsquo;, {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿11\u0026rsquo;}) # grandson2 = ET.Element(\u0026lsquo;grandson\u0026rsquo;, {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿12\u0026rsquo;}) grandson2 = son1.makeelement(\u0026lsquo;grandson\u0026rsquo;, {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;儿12\u0026rsquo;})\nson1.append(grandson1) son1.append(grandson2) # 把儿子添加到根节点中 root.append(son1) root.append(son1)\nraw_str = prettify(root)\nf = open(\u0026ldquo;xxxoo.xml\u0026rdquo;,\u0026lsquo;w\u0026rsquo;,encoding=\u0026lsquo;utf-8\u0026rsquo;) f.write(raw_str) f.close()\nView Code\n4、命名空间\n详细介绍，猛击这里\nfrom xml.etree import ElementTree as ET\nET.register_namespace(\u0026lsquo;com\u0026rsquo;,\u0026ldquo;http://www.company.com\u0026rdquo;) #some name\nbuild a tree structure root = ET.Element(\u0026quot;{http://www.company.com}STUFF\u0026quot;) body = ET.SubElement(root, \u0026ldquo;{http://www.company.com}MORE_STUFF\u0026rdquo;, attrib={\u0026quot;{http://www.company.com}hhh\u0026quot;: \u0026ldquo;123\u0026rdquo;}) body.text = \u0026ldquo;STUFF EVERYWHERE!\u0026rdquo;\nwrap it in an ElementTree instance, and save as XML tree = ET.ElementTree(root)\ntree.write(\u0026ldquo;page.xml\u0026rdquo;, xml_declaration=True, encoding=\u0026lsquo;utf-8\u0026rsquo;, method=\u0026ldquo;xml\u0026rdquo;)\n命名空间\n九、requests Python标准库中提供了：urllib等模块以供Http请求，但是，它的 API 太渣了。它是为另一个时代、另一个互联网所创建的。它需要巨量的工作，甚至包括各种方法覆盖，来完成最简单的任务。\nimport urllib.request\nf = urllib.request.urlopen(\u0026lsquo;http://www.webxml.com.cn//webservices/qqOnlineWebService.asmx/qqCheckOnline?qqCode=424662508') result = f.read().decode(\u0026lsquo;utf-8\u0026rsquo;)\n发送GET请求\nimport urllib.request\nreq = urllib.request.Request(\u0026lsquo;http://www.example.com/') req.add_header(\u0026lsquo;Referer\u0026rsquo;, \u0026lsquo;http://www.python.org/') r = urllib.request.urlopen(req)\nresult = f.read().decode(\u0026lsquo;utf-8\u0026rsquo;)\n发送携带请求头的GET请求\n注：更多见Python官方文档：https://docs.python.org/3.5/library/urllib.request.html#module-urllib.request\nRequests 是使用 Apache2 Licensed 许可证的 基于Python开发的HTTP 库，其在Python内置模块的基础上进行了高度的封装，从而使得Pythoner进行网络请求时，变得美好了许多，使用Requests可以轻而易举的完成浏览器可有的任何操作。\n1、安装模块\npip3 install requests\n2、使用模块\n1、无参数实例 import requests\nret = requests.get(\u0026lsquo;https://github.com/timeline.json') print(ret.url) print(ret.text) # 2、有参数实例\nimport requests\npayload = {\u0026lsquo;key1\u0026rsquo;: \u0026lsquo;value1\u0026rsquo;, \u0026lsquo;key2\u0026rsquo;: \u0026lsquo;value2\u0026rsquo;} ret = requests.get(\u0026ldquo;http://httpbin.org/get\u0026quot;, params=payload) print(ret.url) print(ret.text)\nGET请求\n1、基本POST实例 import requests\npayload = {\u0026lsquo;key1\u0026rsquo;: \u0026lsquo;value1\u0026rsquo;, \u0026lsquo;key2\u0026rsquo;: \u0026lsquo;value2\u0026rsquo;} ret = requests.post(\u0026ldquo;http://httpbin.org/post\u0026quot;, data=payload) print(ret.text) # 2、发送请求头和数据实例\nimport requests import json\nurl = \u0026lsquo;https://api.github.com/some/endpoint' payload = {\u0026lsquo;some\u0026rsquo;: \u0026lsquo;data\u0026rsquo;} headers = {\u0026lsquo;content-type\u0026rsquo;: \u0026lsquo;application/json\u0026rsquo;}\nret = requests.post(url, data=json.dumps(payload), headers=headers) print(ret.text) print(ret.cookies)\nPOST请求\nrequests.get(url, params=None, **kwargs) requests.post(url, data=None, json=None, **kwargs) requests.put(url, data=None, **kwargs) requests.head(url, **kwargs) requests.delete(url, **kwargs) requests.patch(url, data=None, **kwargs) requests.options(url, **kwargs) # 以上方法均是在此方法的基础上构建 requests.request(method, url, **kwargs)\n其他请求\n更多requests模块相关的文档见：http://cn.python-requests.org/zh_CN/latest/\n3、Http请求和XML实例\n实例：检测QQ账号是否在线\nimport urllib import requests from xml.etree import ElementTree as ET # 使用内置模块urllib发送HTTP请求，或者XML格式内容 \u0026quot;\u0026rdquo;\u0026rdquo; f = urllib.request.urlopen(\u0026lsquo;http://www.webxml.com.cn//webservices/qqOnlineWebService.asmx/qqCheckOnline?qqCode=424662508') result = f.read().decode(\u0026lsquo;utf-8\u0026rsquo;) \u0026quot;\u0026quot;\u0026quot;\n使用第三方模块requests发送HTTP请求，或者XML格式内容 r = requests.get(\u0026lsquo;http://www.webxml.com.cn//webservices/qqOnlineWebService.asmx/qqCheckOnline?qqCode=424662508') result = r.text # 解析XML格式内容 node = ET.XML(result) # 获取内容 if node.text == \u0026ldquo;Y\u0026rdquo;: print(\u0026ldquo;在线\u0026rdquo;) else: print(\u0026ldquo;离线\u0026rdquo;)\nView Code\n实例：查看火车停靠信息\nimport urllib import requests from xml.etree import ElementTree as ET # 使用内置模块urllib发送HTTP请求，或者XML格式内容 \u0026quot;\u0026quot;\u0026quot; f = urllib.request.urlopen(\u0026lsquo;http://www.webxml.com.cn/WebServices/TrainTimeWebService.asmx/getDetailInfoByTrainCode?TrainCode=G666\u0026amp;UserID=') result = f.read().decode(\u0026lsquo;utf-8\u0026rsquo;) \u0026quot;\u0026quot;\u0026quot;\n使用第三方模块requests发送HTTP请求，或者XML格式内容 r = requests.get(\u0026lsquo;http://www.webxml.com.cn/WebServices/TrainTimeWebService.asmx/getDetailInfoByTrainCode?TrainCode=G666\u0026amp;UserID=') result = r.text # 解析XML格式内容 root = ET.XML(result) for node in root.iter(\u0026lsquo;TrainDetailInfo\u0026rsquo;): print(node.find(\u0026lsquo;TrainStation\u0026rsquo;).text,node.find(\u0026lsquo;StartTime\u0026rsquo;).text,node.tag,node.attrib)\nView Code\n注：更多接口猛击这里\n十、logging 用于便捷记录日志且线程安全的模块\n1、单文件日志\nimport logging\nlogging.basicConfig(filename=\u0026lsquo;log.log\u0026rsquo;, format=\u0026rsquo;%(asctime)s - %(name)s - %(levelname)s -%(module)s: %(message)s\u0026rsquo;, datefmt=\u0026rsquo;%Y-%m-%d %H:%M:%S %p\u0026rsquo;, level=10)\nlogging.debug(\u0026lsquo;debug\u0026rsquo;) logging.info(\u0026lsquo;info\u0026rsquo;) logging.warning(\u0026lsquo;warning\u0026rsquo;) logging.error(\u0026rsquo;error\u0026rsquo;) logging.critical(\u0026lsquo;critical\u0026rsquo;) logging.log(10,\u0026rsquo;log\u0026rsquo;)\n日志等级：\nCRITICAL = 50 FATAL = CRITICAL ERROR = 40 WARNING = 30 WARN = WARNING INFO = 20 DEBUG = 10 NOTSET = 0\n注：只有【当前写等级】大于【日志等级】时，日志文件才被记录。\n日志记录格式：\n2、多文件日志\n对于上述记录日志的功能，只能将日志记录在单文件中，如果想要设置多个日志文件，logging.basicConfig将无法完成，需要自定义文件和日志操作对象。\n# 定义文件 file_1_1 = logging.FileHandler(\u0026rsquo;l1_1.log\u0026rsquo;, \u0026lsquo;a\u0026rsquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;) fmt = logging.Formatter(fmt=\u0026quot;%(asctime)s - %(name)s - %(levelname)s -%(module)s: %(message)s\u0026quot;) file_1_1.setFormatter(fmt)\nfile_1_2 = logging.FileHandler(\u0026rsquo;l1_2.log\u0026rsquo;, \u0026lsquo;a\u0026rsquo;, encoding=\u0026lsquo;utf-8\u0026rsquo;) fmt = logging.Formatter() file_1_2.setFormatter(fmt)\n定义日志 logger1 = logging.Logger(\u0026lsquo;s1\u0026rsquo;, level=logging.ERROR) logger1.addHandler(file_1_1) logger1.addHandler(file_1_2)\n写日志 logger1.critical(\u0026lsquo;1111\u0026rsquo;)\n日志一\n定义文件 file_2_1 = logging.FileHandler(\u0026rsquo;l2_1.log\u0026rsquo;, \u0026lsquo;a\u0026rsquo;) fmt = logging.Formatter() file_2_1.setFormatter(fmt) # 定义日志 logger2 = logging.Logger(\u0026lsquo;s2\u0026rsquo;, level=logging.INFO) logger2.addHandler(file_2_1)\n日志（二）\n如上述创建的两个日志对象\n当使用【logger1】写日志时，会将相应的内容写入 l1_1.log 和 l1_2.log 文件中 当使用【logger2】写日志时，会将相应的内容写入 l2_1.log 文件中 十一、系统命令 可以执行shell命令的相关模块和函数有：\nos.system os.spawn* os.popen* \u0026ndash;废弃 popen2.* \u0026ndash;废弃 commands.* \u0026ndash;废弃，3.x中被移除 import commands\nresult = commands.getoutput(\u0026lsquo;cmd\u0026rsquo;) result = commands.getstatus(\u0026lsquo;cmd\u0026rsquo;) result = commands.getstatusoutput(\u0026lsquo;cmd\u0026rsquo;)\ncommands\n以上执行shell命令的相关的模块和函数的功能均在 subprocess 模块中实现，并提供了更丰富的功能。\ncall\n执行命令，返回状态码\nret = subprocess.call([\u0026ldquo;ls\u0026rdquo;, \u0026ldquo;-l\u0026rdquo;], shell=False) ret = subprocess.call(\u0026ldquo;ls -l\u0026rdquo;, shell=True)\ncheck_call\n执行命令，如果执行状态码是 0 ，则返回0，否则抛异常\nsubprocess.check_call([\u0026ldquo;ls\u0026rdquo;, \u0026ldquo;-l\u0026rdquo;]) subprocess.check_call(\u0026ldquo;exit 1\u0026rdquo;, shell=True)\ncheck_output\n执行命令，如果状态码是 0 ，则返回执行结果，否则抛异常\nsubprocess.check_output([\u0026ldquo;echo\u0026rdquo;, \u0026ldquo;Hello World!\u0026rdquo;]) subprocess.check_output(\u0026ldquo;exit 1\u0026rdquo;, shell=True)\nsubprocess.Popen(\u0026hellip;)\n用于执行复杂的系统命令\n参数：\nargs：shell命令，可以是字符串或者序列类型（如：list，元组） bufsize：指定缓冲。0 无缓冲,1 行缓冲,其他 缓冲区大小,负值 系统缓冲 stdin, stdout, stderr：分别表示程序的标准输入、输出、错误句柄 preexec_fn：只在Unix平台下有效，用于指定一个可执行对象（callable object），它将在子进程运行之前被调用 close_sfs：在windows平台下，如果close_fds被设置为True，则新创建的子进程将不会继承父进程的输入、输出、错误管道。\n所以不能将close_fds设置为True同时重定向子进程的标准输入、输出与错误(stdin, stdout, stderr)。 shell：同上 cwd：用于设置子进程的当前目录 env：用于指定子进程的环境变量。如果env = None，子进程的环境变量将从父进程中继承。 universal_newlines：不同系统的换行符不同，True -\u0026gt; 同意使用 \\n startupinfo与createionflags只在windows下有效\n将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等 import subprocess ret1 = subprocess.Popen([\u0026ldquo;mkdir\u0026rdquo;,\u0026ldquo;t1\u0026rdquo;]) ret2 = subprocess.Popen(\u0026ldquo;mkdir t2\u0026rdquo;, shell=True)\n执行普通命令\n终端输入的命令分为两种：\n输入即可得到输出，如：ifconfig 输入进行某环境，依赖再输入，如：python import subprocess\nobj = subprocess.Popen(\u0026ldquo;mkdir t3\u0026rdquo;, shell=True, cwd=\u0026rsquo;/home/dev\u0026rsquo;,)\nView Code\nimport subprocess\nobj = subprocess.Popen([\u0026ldquo;python\u0026rdquo;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True) obj.stdin.write(\u0026ldquo;print(1)\\n\u0026rdquo;) obj.stdin.write(\u0026ldquo;print(2)\u0026rdquo;) obj.stdin.close()\ncmd_out = obj.stdout.read() obj.stdout.close() cmd_error = obj.stderr.read() obj.stderr.close() print(cmd_out) print(cmd_error)\nView Code\nimport subprocess\nobj = subprocess.Popen([\u0026ldquo;python\u0026rdquo;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True) obj.stdin.write(\u0026ldquo;print(1)\\n\u0026rdquo;) obj.stdin.write(\u0026ldquo;print(2)\u0026rdquo;)\nout_error_list = obj.communicate() print(out_error_list)\nView Code\nimport subprocess\nobj = subprocess.Popen([\u0026ldquo;python\u0026rdquo;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True) out_error_list = obj.communicate(\u0026lsquo;print(\u0026ldquo;hello\u0026rdquo;)\u0026rsquo;) print(out_error_list)\nView Code\n十二、shutil 高级的 文件、文件夹、压缩包 处理模块\nshutil.copyfileobj(fsrc, fdst[, length])\n将文件内容拷贝到另一个文件中\nimport shutil\nshutil.copyfileobj(open(\u0026lsquo;old.xml\u0026rsquo;,\u0026lsquo;r\u0026rsquo;), open(\u0026rsquo;new.xml\u0026rsquo;, \u0026lsquo;w\u0026rsquo;))\nshutil.copyfile(src, dst)\n拷贝文件\nshutil.copyfile(\u0026lsquo;f1.log\u0026rsquo;, \u0026lsquo;f2.log\u0026rsquo;)\nshutil.copymode(src, dst)\n仅拷贝权限。内容、组、用户均不变\nshutil.copymode(\u0026lsquo;f1.log\u0026rsquo;, \u0026lsquo;f2.log\u0026rsquo;)\nshutil.copystat(src, dst)\n仅拷贝状态的信息，包括：mode bits, atime, mtime, flags\nshutil.copystat(\u0026lsquo;f1.log\u0026rsquo;, \u0026lsquo;f2.log\u0026rsquo;)\nshutil.copy(src, dst)\n拷贝文件和权限\nimport shutil\nshutil.copy(\u0026lsquo;f1.log\u0026rsquo;, \u0026lsquo;f2.log\u0026rsquo;)\nshutil.copy2(src, dst)\n拷贝文件和状态信息\nimport shutil\nshutil.copy2(\u0026lsquo;f1.log\u0026rsquo;, \u0026lsquo;f2.log\u0026rsquo;)\nshutil.ignore_patterns(*patterns)\nshutil.copytree(src, dst, symlinks=False, ignore=None)\n递归的去拷贝文件夹\nimport shutil\nshutil.copytree(\u0026lsquo;folder1\u0026rsquo;, \u0026lsquo;folder2\u0026rsquo;, ignore=shutil.ignore_patterns(\u0026rsquo;*.pyc\u0026rsquo;, \u0026rsquo;tmp*\u0026rsquo;))\nimport shutil\nshutil.copytree(\u0026lsquo;f1\u0026rsquo;, \u0026lsquo;f2\u0026rsquo;, symlinks=True, ignore=shutil.ignore_patterns(\u0026rsquo;*.pyc\u0026rsquo;, \u0026rsquo;tmp*\u0026rsquo;))\nView Code\nshutil.rmtree(path[, ignore_errors[, onerror]])\n递归的去删除文件\nimport shutil\nshutil.rmtree(\u0026lsquo;folder1\u0026rsquo;)\nshutil.move(src, dst)\n递归的去移动文件，它类似mv命令，其实就是重命名。\nimport shutil\nshutil.move(\u0026lsquo;folder1\u0026rsquo;, \u0026lsquo;folder3\u0026rsquo;)\nshutil.make_archive(base_name, format,\u0026hellip;)\n创建压缩包并返回文件路径，例如：zip、tar\n创建压缩包并返回文件路径，例如：zip、tar\nbase_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径，\n如：www =\u0026gt;保存至当前路径\n如：/Users/wupeiqi/www =\u0026gt;保存至/Users/wupeiqi/ format： 压缩包种类，“zip”, “tar”, “bztar”，“gztar” root_dir： 要压缩的文件夹路径（默认当前目录） owner： 用户，默认当前用户 group： 组，默认当前组 logger： 用于记录日志，通常是logging.Logger对象 #将 /Users/wupeiqi/Downloads/test 下的文件打包放置当前程序目录 import shutil ret = shutil.make_archive(\u0026ldquo;wwwwwwwwww\u0026rdquo;, \u0026lsquo;gztar\u0026rsquo;, root_dir=\u0026rsquo;/Users/wupeiqi/Downloads/test\u0026rsquo;)\n#将 /Users/wupeiqi/Downloads/test 下的文件打包放置 /Users/wupeiqi/目录 import shutil ret = shutil.make_archive(\u0026quot;/Users/wupeiqi/wwwwwwwwww\u0026quot;, \u0026lsquo;gztar\u0026rsquo;, root_dir=\u0026rsquo;/Users/wupeiqi/Downloads/test\u0026rsquo;)\nshutil 对压缩包的处理是调用 ZipFile 和 TarFile 两个模块来进行的，详细：\nimport zipfile # 压缩 z = zipfile.ZipFile(\u0026rsquo;laxi.zip\u0026rsquo;, \u0026lsquo;w\u0026rsquo;) z.write(\u0026lsquo;a.log\u0026rsquo;) z.write(\u0026lsquo;data.data\u0026rsquo;) z.close() # 解压 z = zipfile.ZipFile(\u0026rsquo;laxi.zip\u0026rsquo;, \u0026lsquo;r\u0026rsquo;) z.extractall() z.close()\nzipfile解压缩\nimport tarfile # 压缩 tar = tarfile.open(\u0026lsquo;your.tar\u0026rsquo;,\u0026lsquo;w\u0026rsquo;) tar.add(\u0026rsquo;/Users/wupeiqi/PycharmProjects/bbs2.log\u0026rsquo;, arcname=\u0026lsquo;bbs2.log\u0026rsquo;) tar.add(\u0026rsquo;/Users/wupeiqi/PycharmProjects/cmdb.log\u0026rsquo;, arcname=\u0026lsquo;cmdb.log\u0026rsquo;) tar.close() # 解压 tar = tarfile.open(\u0026lsquo;your.tar\u0026rsquo;,\u0026lsquo;r\u0026rsquo;) tar.extractall() # 可设置解压地址 tar.close()\ntarfile解压缩\n十三、paramiko paramiko是一个用于做远程控制的模块，使用该模块可以对远程服务器进行命令或文件操作，值得一说的是，fabric和ansible内部的远程管理就是使用的paramiko来现实。\n1、下载安装\npycrypto，由于 paramiko 模块内部依赖pycrypto，所以先下载安装pycrypto pip3 install pycrypto pip3 install paramiko\n2、模块使用\n#!/usr/bin/env python #coding:utf-8\nimport paramiko\nssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(\u0026lsquo;192.168.1.108\u0026rsquo;, 22, \u0026lsquo;alex\u0026rsquo;, \u0026lsquo;123\u0026rsquo;) stdin, stdout, stderr = ssh.exec_command(\u0026lsquo;df\u0026rsquo;) print stdout.read() ssh.close();\n执行命令 - 用户名+密码\nimport paramiko\nprivate_key_path = \u0026lsquo;/home/auto/.ssh/id_rsa\u0026rsquo; key = paramiko.RSAKey.from_private_key_file(private_key_path)\nssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(\u0026lsquo;主机名 \u0026lsquo;, 端口, \u0026lsquo;用户名\u0026rsquo;, key)\nstdin, stdout, stderr = ssh.exec_command(\u0026lsquo;df\u0026rsquo;) print stdout.read() ssh.close()\n执行命令 - 密钥\nimport os,sys import paramiko\nt = paramiko.Transport((\u0026lsquo;182.92.219.86\u0026rsquo;,22)) t.connect(username=\u0026lsquo;wupeiqi\u0026rsquo;,password=\u0026lsquo;123\u0026rsquo;) sftp = paramiko.SFTPClient.from_transport(t) sftp.put(\u0026rsquo;/tmp/test.py\u0026rsquo;,\u0026rsquo;/tmp/test.py\u0026rsquo;) t.close() import os,sys import paramiko\nt = paramiko.Transport((\u0026lsquo;182.92.219.86\u0026rsquo;,22)) t.connect(username=\u0026lsquo;wupeiqi\u0026rsquo;,password=\u0026lsquo;123\u0026rsquo;) sftp = paramiko.SFTPClient.from_transport(t) sftp.get(\u0026rsquo;/tmp/test.py\u0026rsquo;,\u0026rsquo;/tmp/test2.py\u0026rsquo;) t.close()\n上传或下载文件 - 用户名+密码\nimport paramiko\npravie_key_path = \u0026lsquo;/home/auto/.ssh/id_rsa\u0026rsquo; key = paramiko.RSAKey.from_private_key_file(pravie_key_path)\nt = paramiko.Transport((\u0026lsquo;182.92.219.86\u0026rsquo;,22)) t.connect(username=\u0026lsquo;wupeiqi\u0026rsquo;,pkey=key)\nsftp = paramiko.SFTPClient.from_transport(t) sftp.put(\u0026rsquo;/tmp/test3.py\u0026rsquo;,\u0026rsquo;/tmp/test3.py\u0026rsquo;)\nt.close() import paramiko\npravie_key_path = \u0026lsquo;/home/auto/.ssh/id_rsa\u0026rsquo; key = paramiko.RSAKey.from_private_key_file(pravie_key_path)\nt = paramiko.Transport((\u0026lsquo;182.92.219.86\u0026rsquo;,22)) t.connect(username=\u0026lsquo;wupeiqi\u0026rsquo;,pkey=key)\nsftp = paramiko.SFTPClient.from_transport(t) sftp.get(\u0026rsquo;/tmp/test3.py\u0026rsquo;,\u0026rsquo;/tmp/test4.py\u0026rsquo;)\nt.close()\n上传或下载文件 - 密钥\n十四、time 时间相关的操作，时间有三种表示方式：\n时间戳 1970年1月1日之后的秒，即：time.time() 格式化的字符串 2014-11-11 11:11， 即：time.strftime(\u0026rsquo;%Y-%m-%d\u0026rsquo;) 结构化时间 元组包含了：年、日、星期等\u0026hellip; time.struct_time 即：time.localtime() print time.time() print time.mktime(time.localtime())\nprint time.gmtime() #可加时间戳参数 print time.localtime() #可加时间戳参数 print time.strptime(\u0026lsquo;2014-11-11\u0026rsquo;, \u0026lsquo;%Y-%m-%d\u0026rsquo;)\nprint time.strftime(\u0026rsquo;%Y-%m-%d\u0026rsquo;) #默认当前时间 print time.strftime(\u0026rsquo;%Y-%m-%d\u0026rsquo;,time.localtime()) #默认当前时间 print time.asctime() print time.asctime(time.localtime()) print time.ctime(time.time())\nimport datetime \u0026rsquo;\u0026rsquo;\u0026rsquo; datetime.date：表示日期的类。常用的属性有year, month, day datetime.time：表示时间的类。常用的属性有hour, minute, second, microsecond datetime.datetime：表示日期时间 datetime.timedelta：表示时间间隔，即两个时间点之间的长度 timedelta([days[, seconds[, microseconds[, milliseconds[, minutes[, hours[, weeks]]]]]]]) strftime(\u0026quot;%Y-%m-%d\u0026quot;) \u0026rsquo;\u0026rsquo;\u0026rsquo; import datetime print datetime.datetime.now() print datetime.datetime.now() - datetime.timedelta(days=5)\n%Y Year with century as a decimal number. %m Month as a decimal number \\[01,12\\]. %d Day of the month as a decimal number \\[01,31\\]. %H Hour (24-hour clock) as a decimal number \\[00,23\\]. %M Minute as a decimal number \\[00,59\\]. %S Second as a decimal number \\[00,61\\]. %z Time zone offset from UTC. %a Locale's abbreviated weekday name. %A Locale's full weekday name. %b Locale's abbreviated month name. %B Locale's full month name. %c Locale's appropriate date and time representation. %I Hour (12-hour clock) as a decimal number \\[01,12\\]. %p Locale's equivalent of either AM or PM. 格式化占位符\n练习题： 1、通过HTTP请求和XML实现获取电视节目\nAPI：http://www.webxml.com.cn/webservices/ChinaTVprogramWebService.asmx 2、通过HTTP请求和JSON实现获取天气状况\nAPI：http://wthrcdn.etouch.cn/weather_mini?city=北京\n","permalink":"https://water711.github.io/posts/2017-04-10-python%E5%BC%80%E5%8F%91%E7%AC%AC%E5%85%AD%E7%AF%87%E6%A8%A1%E5%9D%97/","tags":null,"title":"Python开发【第六篇】：模块"},{"categories":["python"],"contents":"递减\nfor i in range(10,1,-1): #range默认递增步长1，递减必需指定负数步长 print(i)\n","permalink":"https://water711.github.io/posts/2017-03-30-range%E7%94%A8%E6%B3%95/","tags":null,"title":"range用法"},{"categories":["python"],"contents":"需求：把一个列表中每个元素的值加1\n第一种方法（for\u0026hellip;in循环 + append到新列表）\na = [5, 8, 11, 14, 17, 20, 23, 26] b = [] for i in a: b.append(i+1) a = b print(a)\n第二种方法（使用for\u0026hellip;in循环 + enumerate函数）\na = [5, 8, 11, 14, 17, 20, 23, 26] for i,j in enumerate(a): a[i] = j+1 # 或者 a[i]+=1 print(a)\n第三种方法(使用map函数 + lambda表达式)\na = [5, 8, 11, 14, 17, 20, 23, 26] a = map(lambda x:x+1,a) print(list(a))\n第四种方法(使用列表生成式)\na = [5, 8, 11, 14, 17, 20, 23, 26] a = [i+1 for i in a] print(a)\n","permalink":"https://water711.github.io/posts/2017-03-26-python%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F/","tags":null,"title":"python 列表生成式"},{"categories":["python"],"contents":"步骤：打开文件-》操作文件-》关闭文件\n打开文件\n文件句柄 = open(\u0026lsquo;文件路径\u0026rsquo;, \u0026lsquo;模式\u0026rsquo;)\n指定文件编码\n文件句柄= open(\u0026lsquo;文件路径\u0026rsquo;,\u0026lsquo;模式\u0026rsquo;,encoding=\u0026lsquo;utf-8\u0026rsquo;)\n为了防止忘记关闭文件，可以使用上下文管理器来打开文件\nwith open(\u0026lsquo;文件路径\u0026rsquo;,\u0026lsquo;模式\u0026rsquo;) as 文件句柄:\n打开文件的模式有：\nr，只读模式（默认）。\nw，只写模式。【不可读；不存在则创建；存在则删除内容；】\na，追加模式。【可读； 不存在则创建；存在则只追加内容；】\nr+，可读写文件。【可读；可写；可追加】\nw+，写读\n\u0026ldquo;U\u0026quot;表示在读取时，可以将 \\r \\n \\r\\n自动转换成 \\n （与 r 或 r+ 模式同使用）\nrU r+U \u0026ldquo;b\u0026quot;表示处理二进制文件（如：FTP发送上传ISO镜像文件，linux可忽略，windows处理二进制文件时需标注）\nrb wb ab 关闭文件\n文件句柄.close()\n操作文件：\ndetach\n#占位\nfileno（返回文件描述符,用于底层操作系统的 I/O 操作）\nfid = 文件句柄.fileno() print(fid)\nflush（刷新缓冲区，将缓冲区中的数据立刻写入文件）\n文件句柄.flush()\nisatty（判断文件是否连接到一个终端设备，返回布尔值）\n文件句柄.isatty()\nread（从文件中读取指定的字符数，默认读取全部）\nstr = 文件句柄.read() #读取整个文件 str1 = 文件句柄.read(10) #读取文件前10个字符\nreadable（判断文件是否可读，返回布尔值）\n文件句柄.readable()\nreadline（每次最多读取一行数据，每行的最后包含换行符\u0026rsquo;\\n\u0026rsquo;）\nprint(文件句柄.readline()) #读取第一行数据 print(文件句柄.readline(3)) #读取第二行前3个字符 print(文件句柄.readline()) #读取第二行剩余字符 print(文件句柄.readline()) #读取第三行\nseek（移动文件读取的指针，如果文件中包含中文，移动指针必须是3的倍数，不然会报错，因为一个中文字符等于3个字节）\n文件句柄.seek(6)\nseekable（判断文件指针是否可用，返回布尔值）\n文件句柄.seekable()\ntell（获取指针位置）\n文件句柄.tell()\ntruncate（截断，把指针后面的内容删除，并写入文件，要在可写模式下操作）\nf = open(\u0026rsquo;text.txt\u0026rsquo;,\u0026lsquo;r+\u0026rsquo;,encoding=\u0026lsquo;utf-8\u0026rsquo;) f.seek(9) #把指针移动到第9个字节后面（即第3个中文后面） f.truncate() #把第3个中文后面的字符删除，并写入文件 f.close()\nwritable（判断文件是否可写，返回布尔值）\n文件句柄.writable()\nwrite（把字符串写入文件，并返回字符数）\n文件句柄.write(\u0026lsquo;字符串\u0026rsquo;)\n","permalink":"https://water711.github.io/posts/2017-03-24-python3%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","tags":null,"title":"python3 文件操作"},{"categories":["python"],"contents":"官方说明文档：https://docs.python.org/3/library/functions.html\nabs(求绝对值)\nprint(abs(-5)) #输出：5\nall(判断可迭代对象的每个元素是否都为True，只要有一个元素为0、None、空字符 \u0026rsquo; \u0026lsquo;、空列表、空元组、空字典，都返回False) 可迭代对象：就是可循环遍历的对象\nprint(all([])) #空列表，返回True print(all([\u0026rsquo;\u0026rsquo;,])) #列表元素有1个为空，返回False print(all((0,1,2))) #元组元素有一个为0，返回False\n#输出：True # False # False\nany(判断可迭代对象的每个元素是否都为True，和all函数相反)\nprint(any([0,\u0026rsquo;\u0026rsquo;,None,{},1])) #只要有一个元素为真，返回真 print(any([0,\u0026rsquo;\u0026rsquo;,None,{}])) #所有元素为假，才为假\n#输出：True # False\nascii（返回一个用ASCII表示的对象，非ascii字符，会输出\\x，\\u或\\U等字符来表示）\n补充：到对象的类中执行__repr__方法，获取其返回值\nprint(ascii(\u0026lsquo;hello\u0026rsquo;)) print(ascii(\u0026lsquo;中文\u0026rsquo;)) #输出：\u0026lsquo;hello\u0026rsquo; # \u0026lsquo;\\u4e2d\\u6587\u0026rsquo;\nbin（返回二进制数）\nprint(bin(57)) #输出：0b111001\nbool（返回布尔值）\nprint(bool(5)) #输出：True\nbytearray（转换成字节数组）\nprint(bytearray(3)) print(bytearray(\u0026lsquo;hello\u0026rsquo;,encoding=\u0026lsquo;utf-8\u0026rsquo;)) #参数为字符串要指定编码 print(bytearray(\u0026lsquo;中文\u0026rsquo;,\u0026lsquo;utf-8\u0026rsquo;)) print(bytearray([11,22,33])) #参数为可迭代类型，则元素必须为[0 ,255]中的整数；\n#输出：bytearray(b\u0026rsquo;\\x00\\x00\\x00\u0026rsquo;) # bytearray(b\u0026rsquo;hello\u0026rsquo;) # bytearray(b\u0026rsquo;\\xe4\\xb8\\xad\\xe6\\x96\\x87\u0026rsquo;) # bytearray(b\u0026rsquo;\\x0b\\x16!\u0026rsquo;)\nbytes（转换成字节）\nprint(bytes(2)) print(bytes(\u0026lsquo;中文\u0026rsquo;,encoding=\u0026lsquo;utf-8\u0026rsquo;)) #字符转换成字节，utf-8编码1个字符为3个字节，GBK编码1个字符为2个字节\n#输出：b\u0026rsquo;\\x00\\x00\u0026rsquo; # b\u0026rsquo;\\xe4\\xb8\\xad\\xe6\\x96\\x87\u0026rsquo;\ncallable（检测对象是否可被执行）\ndef test(): print(\u0026lsquo;succeed\u0026rsquo;)\nn = 5 print(callable(test)) print(callable(n)) #输出：True # False\nchr（将数字转换成ASCII码中的字符）\nprint(chr(65)) #输出：A\nord（将ASCII码中的字符转换成数值）\nprint(ord(\u0026lsquo;A\u0026rsquo;)) #输出：65\nclassmethod\n#占位\ncompile （编译）\n#占位\ncomplex（返回复数）\n#占位\ndelattr\n#占位\ndict（创建字典）\nd = dict(a=1,b=2) print(d) #输出：{\u0026lsquo;b\u0026rsquo;: 2, \u0026lsquo;a\u0026rsquo;: 1}\ndir（查看某个对象或模块提供了哪些功能）\nprint(dir(str)) #输出：[\u0026rsquo;__add__\u0026rsquo;, \u0026lsquo;__class__\u0026rsquo;, \u0026lsquo;__contains__\u0026rsquo;,\u0026hellip;\u0026hellip;\u0026rsquo;translate\u0026rsquo;, \u0026lsquo;upper\u0026rsquo;, \u0026lsquo;zfill\u0026rsquo;]\ndivmod（传入除数和被除数，返回商和余数）\nprint(divmod(13,5)) #输出：(2, 3)\nenumerate（传入可迭代对象，获得它的索引和值）\nname = [\u0026lsquo;Tom\u0026rsquo;,\u0026lsquo;Lucy\u0026rsquo;,\u0026lsquo;Ben\u0026rsquo;] for i,j in enumerate(name): #i为索引，j为值 print(i,j) #输出：0 Tom # 1 Lucy # 2 Ben\neval(执行字符串里面的表达式,并返回结果)\nprint(eval(\u0026lsquo;5*10\u0026rsquo;)) #输出：50\nexec（执行字符串里面的代码）\nexec(\u0026lsquo;a=2+3\u0026rsquo;) print(a) #输出：5\nmap（遍历可迭代对象的元素，把每个元素传入指定方法或函数中执行，并生成的可迭代对象）\ndef func(a): return a*2 li = [11,22,33,44] new_li = map(func,li) print(list(new_li)) #new_li是map对象，要转成list才能输出结果\n#输出：[22, 44, 66, 88]\nfilter（使用指定方法或函数，过滤可迭代对象的元素，并生成新的可迭代对象）\ndef func(a): if a\u0026gt;50: return True else: return False\nli = [33,44,55,66,77] new_li = filter(func,li) print(list(new_li)) #new_li是filter对象，要转成list才能输出结果\n#输出：[55, 66, 77]\nfloat（把数字转换为浮点型）\nprint(float(22)) #输出：22.0\nformat（格式化输出）\nprint(format(9,\u0026lsquo;b\u0026rsquo;)) #转换成二进制,输出1001 print(format(9,\u0026lsquo;o\u0026rsquo;)) #转换成八进制,输出11 print(format(9,\u0026rsquo;d\u0026rsquo;)) #转换成十进制,输出9 print(format(12,\u0026lsquo;x\u0026rsquo;)) #转换成十六进制,小写显示，输出c print(format(12,\u0026lsquo;X\u0026rsquo;)) #转换成十六进制,大写显示，输出C print(format(65,\u0026lsquo;c\u0026rsquo;)) #转换成ASCII,输出A\ngetattr\n#占位\nglobals（返回当前所有全局变量）\na = 3 print(globals()) #输出：{\u0026lsquo;a\u0026rsquo;: 3, \u0026lsquo;__package__\u0026rsquo;: None, \u0026lsquo;__builtins__\u0026rsquo;\u0026hellip;\u0026hellip;\u0026rsquo;__name__\u0026rsquo;: \u0026lsquo;__main__\u0026rsquo;}\nhasattr\n#占位\nhash（获取对象的哈希值）\nprint(hash(\u0026lsquo;xxoo\u0026rsquo;)) #输出：1068037005\nhelp（获取对象的帮助信息）\nprint(help(dict))\nhex（输出整数的16进制）\nprint(hex(123)) #输出：0x7b\nid（查看变量的内存地址）\na = 3 print(id(a)) #输出：490363184\ninput（获取用户输入值）\nname = input(\u0026lsquo;please input your name:\u0026rsquo;) print(name) #运行,please input your name:Tom #输出：Tom\nint（创建一个整型的数值）\na = int(1314)\nisinstance（判断对象是否为某个类型，返回布尔值）\nprint(isinstance(123,int)) #输出True print(isinstance([\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;],list)) #输出True print(isinstance((\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;),tuple)) #输出True print(isinstance(\u0026lsquo;abc\u0026rsquo;,(int,str,list))) #输出True print(isinstance(\u0026lsquo;ab\u0026rsquo;,int)) #输出False\nissubclass\n#占位\niter（传入一个可迭代对象，获取一个生成器）\nl1 = iter([1,2,3,4,5]) print(l1) #\nlen（获取对象的长度）\na = [1,2,3,4] print(len(a)) #输出：4\nlist（创建一个列表）\nli = list([1,2,3,4])\nlocals（返回当前所有局部变量）\nprint(locals())\nmax（获取最大值）\nprint(max(2,4,6,8)) #输出：8\nmin（获取最小值）\nprint(min(2,4,6,8)) #输出：2\nnext\n#占位\nobject\n#占位\noct（返回八进制）\nprint(oct(12)) #输出：0o14\nopen（打开文件）\n#占位\npow（求指数）\nret = pow(2,3) #求2的3次方 print(ret) #输出：8\nprint(打印输出)\nprint(123)\nproperty\n#占位\nrange（创建一个连续的整数序列）\nfor i in range(1,10): print(i) #打印1到9的数字\nrepr\n#占位\nreversed（反转）\nn = [1,2,3,4,5] m = reversed(n) print(list(m)) #m是reversed对象，要转成list输出\n#输出：[5, 4, 3, 2, 1]\nround（求四舍五入后的值）\nprint(round(4.3)) print(round(4.8)) #输出：4 # 5\nset（创建set集合，无序且元素不重复的集合）\nn = set([1,2,2,3,3]) print(n) #输出：{1, 2, 3}\nsetattr\n#占位\nslice\n#占位\nsorted（排序）\ns = [5,2,7,9,3] print(sorted(s)) #输出：[2, 3, 5, 7, 9]\nstaticmethod\n#占位\nstr（创建字符串）\ns = str(\u0026lsquo;123abc\u0026rsquo;)\nsum（求和）\nprint(sum([1,2,3])) #输出：6\nsuper\n#占位\ntuple（创建一个元组）\nt = tuple([1,2,3])\ntype（查看对象的类型）\nn = 123 print(type(n)) #输出：\nvars(查看某个对象或模块提供了哪些功能，返回字典，dir是返回列表)\nprint(vars(str))\nzip（把传入所有的迭代对象，相同位置的元素，组合起来，形成新的迭代对象）\nx = [1,2,3] y = [6,7,8,9] z = zip(x,y) print(list(z)) #取到最短的序列\n#输出：[(1, 6), (2, 7), (3, 8)]\n","permalink":"https://water711.github.io/posts/2017-03-23-python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/","tags":null,"title":"python 内置函数"},{"categories":["python"],"contents":"创建双向队列\nimport collections d = collections.deque()\nappend(往右边添加一个元素)\nimport collections d = collections.deque() d.append(1) d.append(2) print(d) #输出：deque([1, 2])\nappendleft（往左边添加一个元素）\nimport collections d = collections.deque() d.append(1) d.appendleft(2) print(d) #输出：deque([2, 1])\nclear(清空队列)\nimport collections d = collections.deque() d.append(1) d.clear() print(d) #输出：deque([])\ncopy(浅拷贝)\nimport collections d = collections.deque() d.append(1) new_d = d.copy() print(new_d) #输出：deque([1])\ncount(返回指定元素的出现次数)\nimport collections d = collections.deque() d.append(1) d.append(1) print(d.count(1)) #输出：2\nextend(从队列右边扩展一个列表的元素)\nimport collections d = collections.deque() d.append(1) d.extend([3,4,5]) print(d) #输出：deque([1, 3, 4, 5])\nextendleft(从队列左边扩展一个列表的元素)\nimport collections d = collections.deque() d.append(1) d.extendleft([3,4,5]) print(d) #\n#输出：deque([5, 4, 3, 1]) index（查找某个元素的索引位置）\nimport collections d = collections.deque() d.extend([\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;,\u0026rsquo;d\u0026rsquo;,\u0026rsquo;e\u0026rsquo;]) print(d) print(d.index(\u0026rsquo;e\u0026rsquo;)) print(d.index(\u0026lsquo;c\u0026rsquo;,0,3)) #指定查找区间\n#输出：deque([\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026rsquo;d\u0026rsquo;, \u0026rsquo;e\u0026rsquo;]) # 4 # 2\ninsert（在指定位置插入元素）\nimport collections d = collections.deque() d.extend([\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;,\u0026rsquo;d\u0026rsquo;,\u0026rsquo;e\u0026rsquo;]) d.insert(2,\u0026lsquo;z\u0026rsquo;) print(d) #输出：deque([\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;z\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026rsquo;d\u0026rsquo;, \u0026rsquo;e\u0026rsquo;])\npop（获取最右边一个元素，并在队列中删除）\nimport collections d = collections.deque() d.extend([\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;,\u0026rsquo;d\u0026rsquo;,\u0026rsquo;e\u0026rsquo;]) x = d.pop() print(x,d) #输出：e deque([\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026rsquo;d\u0026rsquo;])\npopleft（获取最左边一个元素，并在队列中删除）\nimport collections d = collections.deque() d.extend([\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;,\u0026rsquo;d\u0026rsquo;,\u0026rsquo;e\u0026rsquo;]) x = d.popleft() print(x,d) #输出：a deque([\u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026rsquo;d\u0026rsquo;, \u0026rsquo;e\u0026rsquo;])\nremove（删除指定元素）\nimport collections d = collections.deque() d.extend([\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;,\u0026rsquo;d\u0026rsquo;,\u0026rsquo;e\u0026rsquo;]) d.remove(\u0026lsquo;c\u0026rsquo;) print(d) #输出：deque([\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026rsquo;d\u0026rsquo;, \u0026rsquo;e\u0026rsquo;])\nreverse（队列反转）\nimport collections d = collections.deque() d.extend([\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;,\u0026rsquo;d\u0026rsquo;,\u0026rsquo;e\u0026rsquo;]) d.reverse() print(d) #输出：deque([\u0026rsquo;e\u0026rsquo;, \u0026rsquo;d\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;a\u0026rsquo;])\nrotate（把右边元素放到左边）\nimport collections d = collections.deque() d.extend([\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;,\u0026rsquo;d\u0026rsquo;,\u0026rsquo;e\u0026rsquo;]) d.rotate(2) #指定次数，默认1次 print(d) #输出：deque([\u0026rsquo;d\u0026rsquo;, \u0026rsquo;e\u0026rsquo;, \u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;])\n","permalink":"https://water711.github.io/posts/2017-03-22-python3deque%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/","tags":null,"title":"python3 deque（双向队列）"},{"categories":["python"],"contents":"创建队列\nimport queue q = queue.Queue()\nempty（如果队列为空，返回True）\nimport queue q = queue.Queue() print(q.empty()) #输出：True\nfull（如果队列满了，返回True）\nimport queue q = queue.Queue(1) #指定队列大小 q.put(\u0026lsquo;a\u0026rsquo;) print(q.full()) #输出：True\nput（放一个元素进队列） get（从队列中取出一个元素） 先进先出原则\nimport queue q = queue.Queue() q.put(\u0026lsquo;a\u0026rsquo;) q.put(\u0026lsquo;b\u0026rsquo;) print(q.get()) #输出：a\nget_nowait（立即取出一个元素，不等待）\n#占位\nput_nowait（立即放入一个元素，不等待）\n#占位\njoin(阻塞调用线程，直到队列中的所有任务被处理掉)\n#占位\nqsize(返回队列里元素个数)\nimport queue q = queue.Queue() q.put(\u0026lsquo;a\u0026rsquo;) q.put(\u0026lsquo;b\u0026rsquo;) print(q.qsize()) #输出：2\ntask_done（在完成一项任务之后，向任务已经完成的队列发送一个信号）\n#占位\n","permalink":"https://water711.github.io/posts/2017-03-22-python3queue%E5%8D%95%E5%90%91%E9%98%9F%E5%88%97/","tags":null,"title":"python3 Queue（单向队列）"},{"categories":["python"],"contents":"Counter（计数器）：用于追踪值的出现次数\nCounter类继承dict类，所以它能使用dict类里面的方法\n创建一个Counter类\nimport collections obj = collections.Counter(\u0026lsquo;aabbccc\u0026rsquo;) print(obj) #输出：Counter({\u0026lsquo;c\u0026rsquo;: 3, \u0026lsquo;a\u0026rsquo;: 2, \u0026lsquo;b\u0026rsquo;: 2})\nelements()\nimport collections obj = collections.Counter(\u0026lsquo;aabbccc\u0026rsquo;) print(sorted(obj.elements())) #输出：[\u0026lsquo;a\u0026rsquo;, \u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026lsquo;c\u0026rsquo;]\nfor k in obj.elements(): #遍历打印obj所有元素 print(k)\nmost_common(指定一个参数n，列出前n个元素，不指定参数，则列出所有)\nimport collections obj = collections.Counter(\u0026lsquo;aabbbcccc\u0026rsquo;) print(obj.most_common(2)) #输出：[(\u0026lsquo;c\u0026rsquo;, 4), (\u0026lsquo;b\u0026rsquo;, 3)]\nitems(从dict类中继承的方法)\nimport collections obj = collections.Counter(\u0026lsquo;aabbbcccc\u0026rsquo;) print(obj.items()) for k,v in obj.items(): print(k,v) #输出：dict_items([(\u0026lsquo;b\u0026rsquo;, 3), (\u0026lsquo;c\u0026rsquo;, 4), (\u0026lsquo;a\u0026rsquo;, 2)]) # b 3 # c 4 # a 2\nupdate(增加元素)\nimport collections obj = collections.Counter([\u0026lsquo;11\u0026rsquo;,\u0026lsquo;22\u0026rsquo;]) obj.update([\u0026lsquo;22\u0026rsquo;,\u0026lsquo;55\u0026rsquo;]) print(obj) #输出：Counter({\u0026lsquo;22\u0026rsquo;: 2, \u0026lsquo;11\u0026rsquo;: 1, \u0026lsquo;55\u0026rsquo;: 1})\nsubtract(原来的元素减去新传入的元素)\nimport collections obj = collections.Counter([\u0026lsquo;11\u0026rsquo;,\u0026lsquo;22\u0026rsquo;,\u0026lsquo;33\u0026rsquo;]) obj.subtract([\u0026lsquo;22\u0026rsquo;,\u0026lsquo;55\u0026rsquo;]) print(obj) #输出：Counter({\u0026lsquo;11\u0026rsquo;: 1, \u0026lsquo;33\u0026rsquo;: 1, \u0026lsquo;22\u0026rsquo;: 0, \u0026lsquo;55\u0026rsquo;: -1})\n未完待续。。。\n","permalink":"https://water711.github.io/posts/2017-03-21-python3counter%E7%B1%BB%E8%AE%A1%E6%95%B0%E5%99%A8/","tags":null,"title":"python3 Counter类（计数器）"},{"categories":["python"],"contents":"clear(清空字典内容)\nstu = { \u0026rsquo;num1\u0026rsquo;:\u0026lsquo;Tom\u0026rsquo;, \u0026rsquo;num2\u0026rsquo;:\u0026lsquo;Lucy\u0026rsquo;, \u0026rsquo;num3\u0026rsquo;:\u0026lsquo;Sam\u0026rsquo;, } print(stu.clear()) #输出：None\ncopy（拷贝字典）\nstu = { \u0026rsquo;num1\u0026rsquo;:\u0026lsquo;Tom\u0026rsquo;, \u0026rsquo;num2\u0026rsquo;:\u0026lsquo;Lucy\u0026rsquo;, \u0026rsquo;num3\u0026rsquo;:\u0026lsquo;Sam\u0026rsquo;, } stu2 = stu.copy() print(stu2)\nfromkeys(指定一个列表，把列表中的值作为字典的key,生成一个字典)\nname = [\u0026rsquo;tom\u0026rsquo;,\u0026rsquo;lucy\u0026rsquo;,\u0026lsquo;sam\u0026rsquo;] print(dict.fromkeys(name)) print(dict.fromkeys(name,25)) #指定默认值\n#输出：{\u0026rsquo;tom\u0026rsquo;: None, \u0026rsquo;lucy\u0026rsquo;: None, \u0026lsquo;sam\u0026rsquo;: None} # {\u0026rsquo;tom\u0026rsquo;: 25, \u0026rsquo;lucy\u0026rsquo;: 25, \u0026lsquo;sam\u0026rsquo;: 25}\nget(指定key，获取对应的值)\nstu = { \u0026rsquo;num1\u0026rsquo;:\u0026lsquo;Tom\u0026rsquo;, \u0026rsquo;num2\u0026rsquo;:\u0026lsquo;Lucy\u0026rsquo;, \u0026rsquo;num3\u0026rsquo;:\u0026lsquo;Sam\u0026rsquo;, } print(stu.get(\u0026rsquo;num2\u0026rsquo;)) #输出：Lucy\nitems(返回由“键值对组成元素“的列表)\nstu = { \u0026rsquo;num1\u0026rsquo;:\u0026lsquo;Tom\u0026rsquo;, \u0026rsquo;num2\u0026rsquo;:\u0026lsquo;Lucy\u0026rsquo;, \u0026rsquo;num3\u0026rsquo;:\u0026lsquo;Sam\u0026rsquo;, } print(stu.items()) #输出：dict_items([(\u0026rsquo;num2\u0026rsquo;, \u0026lsquo;Lucy\u0026rsquo;), (\u0026rsquo;num3\u0026rsquo;, \u0026lsquo;Sam\u0026rsquo;), (\u0026rsquo;num1\u0026rsquo;, \u0026lsquo;Tom\u0026rsquo;)])\nkeys(获取字典所有的key)\nstu = { \u0026rsquo;num1\u0026rsquo;:\u0026lsquo;Tom\u0026rsquo;, \u0026rsquo;num2\u0026rsquo;:\u0026lsquo;Lucy\u0026rsquo;, \u0026rsquo;num3\u0026rsquo;:\u0026lsquo;Sam\u0026rsquo;, } print(stu.keys()) #输出：dict_keys([\u0026rsquo;num3\u0026rsquo;, \u0026rsquo;num1\u0026rsquo;, \u0026rsquo;num2\u0026rsquo;])\npop(获取指定key的value，并在字典中删除)\nstu = { \u0026rsquo;num1\u0026rsquo;:\u0026lsquo;Tom\u0026rsquo;, \u0026rsquo;num2\u0026rsquo;:\u0026lsquo;Lucy\u0026rsquo;, \u0026rsquo;num3\u0026rsquo;:\u0026lsquo;Sam\u0026rsquo;, } name = stu.pop(\u0026rsquo;num2\u0026rsquo;) print(name,stu) #输出：Lucy {\u0026rsquo;num1\u0026rsquo;: \u0026lsquo;Tom\u0026rsquo;, \u0026rsquo;num3\u0026rsquo;: \u0026lsquo;Sam\u0026rsquo;}\npopitem(随机获取某个键值对，并在字典中删除)\nstu = { \u0026rsquo;num1\u0026rsquo;:\u0026lsquo;Tom\u0026rsquo;, \u0026rsquo;num2\u0026rsquo;:\u0026lsquo;Lucy\u0026rsquo;, \u0026rsquo;num3\u0026rsquo;:\u0026lsquo;Sam\u0026rsquo;, } name = stu.popitem() print(name,stu) #输出：(\u0026rsquo;num2\u0026rsquo;, \u0026lsquo;Lucy\u0026rsquo;) {\u0026rsquo;num3\u0026rsquo;: \u0026lsquo;Sam\u0026rsquo;, \u0026rsquo;num1\u0026rsquo;: \u0026lsquo;Tom\u0026rsquo;}\nsetdefault(获取指定key的value，如果key不存在，则创建)\nstu = { \u0026rsquo;num1\u0026rsquo;:\u0026lsquo;Tom\u0026rsquo;, \u0026rsquo;num2\u0026rsquo;:\u0026lsquo;Lucy\u0026rsquo;, \u0026rsquo;num3\u0026rsquo;:\u0026lsquo;Sam\u0026rsquo;, } name = stu.setdefault(\u0026rsquo;num5\u0026rsquo;) print(name,stu) #输出：None {\u0026rsquo;num1\u0026rsquo;: \u0026lsquo;Tom\u0026rsquo;, \u0026rsquo;num2\u0026rsquo;: \u0026lsquo;Lucy\u0026rsquo;, \u0026rsquo;num5\u0026rsquo;: None, \u0026rsquo;num3\u0026rsquo;: \u0026lsquo;Sam\u0026rsquo;}\nupdate(添加键 - 值对到字典)\nstu = { \u0026rsquo;num1\u0026rsquo;:\u0026lsquo;Tom\u0026rsquo;, \u0026rsquo;num2\u0026rsquo;:\u0026lsquo;Lucy\u0026rsquo;, \u0026rsquo;num3\u0026rsquo;:\u0026lsquo;Sam\u0026rsquo;, } stu.update({\u0026rsquo;num4\u0026rsquo;:\u0026lsquo;Ben\u0026rsquo;}) print(stu) #输出：{\u0026rsquo;num2\u0026rsquo;: \u0026lsquo;Lucy\u0026rsquo;, \u0026rsquo;num3\u0026rsquo;: \u0026lsquo;Sam\u0026rsquo;, \u0026rsquo;num1\u0026rsquo;: \u0026lsquo;Tom\u0026rsquo;, \u0026rsquo;num4\u0026rsquo;: \u0026lsquo;Ben\u0026rsquo;}\n","permalink":"https://water711.github.io/posts/2017-03-21-python3dict%E5%AD%97%E5%85%B8/","tags":null,"title":"python3 dict（字典）"},{"categories":["python"],"contents":"创建有序字典\nimport collections\ndic = collections.OrderedDict() dic[\u0026lsquo;k1\u0026rsquo;] = \u0026lsquo;v1\u0026rsquo; dic[\u0026lsquo;k2\u0026rsquo;] = \u0026lsquo;v2\u0026rsquo; dic[\u0026lsquo;k3\u0026rsquo;] = \u0026lsquo;v3\u0026rsquo; print(dic) #输出：OrderedDict([(\u0026lsquo;k1\u0026rsquo;, \u0026lsquo;v1\u0026rsquo;), (\u0026lsquo;k2\u0026rsquo;, \u0026lsquo;v2\u0026rsquo;), (\u0026lsquo;k3\u0026rsquo;, \u0026lsquo;v3\u0026rsquo;)])\nclear(清空有序字典)\nimport collections\ndic = collections.OrderedDict() dic[\u0026lsquo;k1\u0026rsquo;] = \u0026lsquo;v1\u0026rsquo; dic[\u0026lsquo;k2\u0026rsquo;] = \u0026lsquo;v2\u0026rsquo; dic.clear() print(dic) #输出：OrderedDict()\ncopy(拷贝)\nimport collections\ndic = collections.OrderedDict() dic[\u0026lsquo;k1\u0026rsquo;] = \u0026lsquo;v1\u0026rsquo; dic[\u0026lsquo;k2\u0026rsquo;] = \u0026lsquo;v2\u0026rsquo; new_dic = dic.copy() print(new_dic) #输出：OrderedDict([(\u0026lsquo;k1\u0026rsquo;, \u0026lsquo;v1\u0026rsquo;), (\u0026lsquo;k2\u0026rsquo;, \u0026lsquo;v2\u0026rsquo;)])\nfromkeys(指定一个列表，把列表中的值作为字典的key,生成一个字典)\nimport collections\ndic = collections.OrderedDict() name = [\u0026rsquo;tom\u0026rsquo;,\u0026rsquo;lucy\u0026rsquo;,\u0026lsquo;sam\u0026rsquo;] print(dic.fromkeys(name)) print(dic.fromkeys(name,20)) #输出：OrderedDict([(\u0026rsquo;tom\u0026rsquo;, None), (\u0026rsquo;lucy\u0026rsquo;, None), (\u0026lsquo;sam\u0026rsquo;, None)]) # OrderedDict([(\u0026rsquo;tom\u0026rsquo;, 20), (\u0026rsquo;lucy\u0026rsquo;, 20), (\u0026lsquo;sam\u0026rsquo;, 20)])\nitems(返回由“键值对组成元素“的列表)\nimport collections\ndic = collections.OrderedDict() dic[\u0026lsquo;k1\u0026rsquo;] = \u0026lsquo;v1\u0026rsquo; dic[\u0026lsquo;k2\u0026rsquo;] = \u0026lsquo;v2\u0026rsquo; print(dic.items()) #输出：odict_items([(\u0026lsquo;k1\u0026rsquo;, \u0026lsquo;v1\u0026rsquo;), (\u0026lsquo;k2\u0026rsquo;, \u0026lsquo;v2\u0026rsquo;)])\nkeys(获取字典所有的key)\nimport collections\ndic = collections.OrderedDict() dic[\u0026lsquo;k1\u0026rsquo;] = \u0026lsquo;v1\u0026rsquo; dic[\u0026lsquo;k2\u0026rsquo;] = \u0026lsquo;v2\u0026rsquo; print(dic.keys()) # 输出：odict_keys([\u0026lsquo;k1\u0026rsquo;, \u0026lsquo;k2\u0026rsquo;])\nmove_to_end(指定一个key，把对应的key-value移到最后)\nimport collections\ndic = collections.OrderedDict() dic[\u0026lsquo;k1\u0026rsquo;] = \u0026lsquo;v1\u0026rsquo; dic[\u0026lsquo;k2\u0026rsquo;] = \u0026lsquo;v2\u0026rsquo; dic[\u0026lsquo;k3\u0026rsquo;] = \u0026lsquo;v3\u0026rsquo; dic.move_to_end(\u0026lsquo;k1\u0026rsquo;) print(dic) # 输出：OrderedDict([(\u0026lsquo;k2\u0026rsquo;, \u0026lsquo;v2\u0026rsquo;), (\u0026lsquo;k3\u0026rsquo;, \u0026lsquo;v3\u0026rsquo;), (\u0026lsquo;k1\u0026rsquo;, \u0026lsquo;v1\u0026rsquo;)])\npop(获取指定key的value，并在字典中删除)\nimport collections\ndic = collections.OrderedDict() dic[\u0026lsquo;k1\u0026rsquo;] = \u0026lsquo;v1\u0026rsquo; dic[\u0026lsquo;k2\u0026rsquo;] = \u0026lsquo;v2\u0026rsquo; dic[\u0026lsquo;k3\u0026rsquo;] = \u0026lsquo;v3\u0026rsquo; k = dic.pop(\u0026lsquo;k2\u0026rsquo;) print(k,dic) # 输出：v2 OrderedDict([(\u0026lsquo;k1\u0026rsquo;, \u0026lsquo;v1\u0026rsquo;), (\u0026lsquo;k3\u0026rsquo;, \u0026lsquo;v3\u0026rsquo;)])\npopitem(按照后进先出原则，删除最后加入的元素，返回key-value)\nimport collections\ndic = collections.OrderedDict() dic[\u0026lsquo;k1\u0026rsquo;] = \u0026lsquo;v1\u0026rsquo; dic[\u0026lsquo;k2\u0026rsquo;] = \u0026lsquo;v2\u0026rsquo; dic[\u0026lsquo;k3\u0026rsquo;] = \u0026lsquo;v3\u0026rsquo; print(dic.popitem(),dic) print(dic.popitem(),dic) # 输出：(\u0026lsquo;k3\u0026rsquo;, \u0026lsquo;v3\u0026rsquo;) OrderedDict([(\u0026lsquo;k1\u0026rsquo;, \u0026lsquo;v1\u0026rsquo;), (\u0026lsquo;k2\u0026rsquo;, \u0026lsquo;v2\u0026rsquo;)]) # (\u0026lsquo;k2\u0026rsquo;, \u0026lsquo;v2\u0026rsquo;) OrderedDict([(\u0026lsquo;k1\u0026rsquo;, \u0026lsquo;v1\u0026rsquo;)])\nsetdefault(获取指定key的value，如果key不存在，则创建)\nimport collections\ndic = collections.OrderedDict() dic[\u0026lsquo;k1\u0026rsquo;] = \u0026lsquo;v1\u0026rsquo; dic[\u0026lsquo;k2\u0026rsquo;] = \u0026lsquo;v2\u0026rsquo; dic[\u0026lsquo;k3\u0026rsquo;] = \u0026lsquo;v3\u0026rsquo; val = dic.setdefault(\u0026lsquo;k5\u0026rsquo;) print(val,dic) # 输出：None OrderedDict([(\u0026lsquo;k1\u0026rsquo;, \u0026lsquo;v1\u0026rsquo;), (\u0026lsquo;k2\u0026rsquo;, \u0026lsquo;v2\u0026rsquo;), (\u0026lsquo;k3\u0026rsquo;, \u0026lsquo;v3\u0026rsquo;), (\u0026lsquo;k5\u0026rsquo;, None)])\nvalues(获取字典所有的value，返回一个列表)\nimport collections\ndic = collections.OrderedDict() dic[\u0026lsquo;k1\u0026rsquo;] = \u0026lsquo;v1\u0026rsquo; dic[\u0026lsquo;k2\u0026rsquo;] = \u0026lsquo;v2\u0026rsquo; dic[\u0026lsquo;k3\u0026rsquo;] = \u0026lsquo;v3\u0026rsquo; print(dic.values()) # 输出：odict_values([\u0026lsquo;v1\u0026rsquo;, \u0026lsquo;v2\u0026rsquo;, \u0026lsquo;v3\u0026rsquo;])\n","permalink":"https://water711.github.io/posts/2017-03-21-python3ordereddict%E7%B1%BB%E6%9C%89%E5%BA%8F%E5%AD%97%E5%85%B8/","tags":null,"title":"python3 OrderedDict类（有序字典）"},{"categories":["python"],"contents":"add（增加元素）\nname = set([\u0026lsquo;Tom\u0026rsquo;,\u0026lsquo;Lucy\u0026rsquo;,\u0026lsquo;Ben\u0026rsquo;]) name.add(\u0026lsquo;Juny\u0026rsquo;) print(name) #输出：{\u0026lsquo;Lucy\u0026rsquo;, \u0026lsquo;Juny\u0026rsquo;, \u0026lsquo;Ben\u0026rsquo;, \u0026lsquo;Tom\u0026rsquo;}\nclear（清空所有元素）\nname = set([\u0026lsquo;Tom\u0026rsquo;,\u0026lsquo;Lucy\u0026rsquo;,\u0026lsquo;Ben\u0026rsquo;]) name.clear() print(name) #输出：set()\ncopy(拷贝set集合)\nname = set([\u0026lsquo;Tom\u0026rsquo;,\u0026lsquo;Lucy\u0026rsquo;,\u0026lsquo;Ben\u0026rsquo;]) new_name = name.copy() print(new_name) #输出：{\u0026lsquo;Tom\u0026rsquo;, \u0026lsquo;Lucy\u0026rsquo;, \u0026lsquo;Ben\u0026rsquo;}\ndifference(返回两个或多个集合中不同的元素，并生成新的集合)\nA = set([2,3,4,5]) B = set([3,4]) C = set([2]) n = A.difference(B,C) print(n) #输出：{5}\n#返回A集合里面，在B和C集合中没有的元素，并生成新的集合\ndifference_update（删除A集合里面，在B集合中存在的元素。）\nA = set([2,3,4,5]) B = set([4,5]) A.difference_update(B) print(A) #输出：{2, 3}\ndiscard(移除元素,如果元素不存在不报错)\nn = set([2,3,4]) n.discard(3) print(n) #输出：{2, 4}\nintersection(取交集，并生成新的集合)\nn1 = set([2,3,4,5]) n2 = set([4,5,6,7]) n = n1.intersection(n2) print(n) #输出：{4, 5}\nintersection_update(取交集，修改原来的集合)\nn1 = set([2,3,4,5]) n2 = set([4,5,6,7]) n1.intersection_update(n2) print(n1) #输出：{4, 5}\nisdisjoint(判断交集，是返回False，否返回True)\nn1 = set([2,3,4,5]) n2 = set([4,5,6,7]) print(n1.isdisjoint(n2)) #输出：False\nissubset(判断子集)\nA = set([2,3]) B = set([2,3,4,5]) print(A.issubset(B)) #输出：True #A是B的子集\nissuperset(判断父集)\nA = set([2,3]) B = set([2,3,4,5]) print(B.issuperset(A)) # 输出：True #B是A的父集\npop(随机移除一个元素)\nn = set([2,3,4,5]) n1 = n.pop() print(n,n1) # 输出：{3, 4, 5} 2\nremove(移除指定元素,元素不存在会报错)\nn = set([2,3,4,5]) n.remove(2) print(n) # 输出：{3, 4, 5}\nsymmetric_difference(取交集，并生成新的集合)\nA = set([2,3,4,5]) B = set([4,5,6,7]) print(A.symmetric_difference(B)) # 输出：{2, 3, 6, 7}\nsymmetric_difference_update(取交集，改变原来的集合)\nA = set([2,3,4,5]) B = set([4,5,6,7]) A.symmetric_difference_update(B) print(A) # 输出：{2, 3, 6, 7}\nunion（取并集，并生成新的集合）\nA = set([2,3,4,5]) B = set([4,5,6,7]) print(A.union(B)) # 输出：{2, 3, 4, 5, 6, 7}\nupdate(取并集，改变原来的集合)\nA = set([2,3,4,5]) B = set([4,5,6,7]) A.update(B) print(A) # 输出：{2, 3, 4, 5, 6, 7}\n","permalink":"https://water711.github.io/posts/2017-03-21-python3set%E9%9B%86%E5%90%88/","tags":null,"title":"python3 set（集合）"},{"categories":["python"],"contents":"__abs__(返回绝对值)\nn = -5 print(n.__abs__()) #输出：5\n__add__(相加，运算符：+)\nn = 3 print(n.__add__(5)) #输出：8\n__and__（按位与运算，运算符：\u0026amp;）\nn = 5 print(n.__and__(7)) #输出：5 # 00000110 #与运算\n00000111 #等于 00000110 __bool__\n#占位\n__ceil__（返回自身）\nn = 1234 print(n.__ceil__()) #输出：1234\n__divmod__(返回除数和余数)\nn = 13 print(n.__divmod__(5)) #输出：(2, 3)\n__eq__（判断两数是否相等，运算符：==）\nn = 5 print(n.__eq__(3)) #输出：False\n__float__（转换成浮点型）\nn = 5 print(n.__float__()) #输出：5.0\n__floordiv__（取整除，返回商的整数部分，运算符：//）\nn = 9 print(n.__floordiv__(4)) #输出：2\n__floor__\n#占位\n__format__\n#占位\n__getattribute__\n#占位\n__getnewargs__\n#占位\n__ge__(判断是否 \u0026gt;=)\nn = 5 print(n.__ge__(3)) #输出：True\n__gt__(判断是否 \u0026gt; )\nn = 5 print(n.__gt__(3)) #输出：True\n__hash__\n#占位\n__index__\n#占位\n__invert__（二进制按位取反，运算符：~）\nn = 11 print(n.__invert__()) #输出：-12 #ps:二进制的负数表示方法：正数按位取反再加1\n__le__（判断是否 \u0026lt;=）\nn = 5 print(n.__le__(3)) #输出：False\n__lshift__(二进制左移运算，运算符：\u0026laquo;)\nn = 12 print(n.__lshift__(2)) #输出：48 #ps:二进制左移1位等于十进制乘2，右移一位等于十进制除2\n__lt__(判断是否 \u0026lt;)\nn = 5 print(n.__lt__(3)) # #输出：False\n__mod__(取模-返回除法的余数，运算符：%)\nn = 14 print(n.__mod__(3)) #输出：2\n__mul__(相乘，运算符：*)\nn = 3 print(n.__mul__(6)) #输出：18\n__neg__(取反，正数变负数，负数变正数，运算符：-)\nn = 5 print(n.__neg__()) #输出：-5\n__new__\n#占位\n__ne__(判断两值是否不相等，运算符：!= )\nn = 5 print(n.__ne__(3)) #输出：True\n__or__(按位或运算，运算符：|)\nn = 3 print(n.__or__(5)) #输出：7 # # 00000011 # #或 # # 00000110 # # 00000111\n__pos__\n\u0026quot;\u0026quot;\u0026quot; +self \u0026quot;\u0026quot;\u0026quot; （不知道有啥意义） __pow__(返回 xy [x的y次方] 的值)\nn = 2 print(n.__pow__(3)) #输出：8\n__radd__(相加，运算符：+)\nn = 5 print(n.__radd__(3)) #输出：8\n__rand__\n#\u0026quot;\u0026quot;\u0026quot; Return value\u0026amp;self. \u0026quot;\u0026quot;\u0026quot;\n__rdivmod__\n#\u0026quot;\u0026quot;\u0026quot; Return divmod(value, self). \u0026quot;\u0026quot;\u0026quot;\n__repr__（返回自身）\n#\u0026quot;\u0026quot;\u0026quot; Return repr(self). \u0026quot;\u0026quot;\u0026quot;\n__rfloordiv__（取整除，返回商的整数部分，运算符：//）\n#\u0026quot;\u0026quot;\u0026quot; Return value//self. \u0026quot;\u0026quot;\u0026quot;\n__rlshift__(二进制左移运算，运算符：\u0026laquo;)\n#\u0026quot;\u0026quot;\u0026quot; Return value\u0026lt;\n__rmod__(取模-返回除法的余数，运算符：%)\n#\u0026quot;\u0026quot;\u0026quot; Return value%self. \u0026quot;\u0026quot;\u0026quot;\n__rmul__(相乘，运算符：*)\n#\u0026quot;\u0026quot;\u0026quot; Return value*self. \u0026quot;\u0026quot;\u0026quot;\n__ror__\n#\u0026quot;\u0026quot;\u0026quot; Return value|self. \u0026quot;\u0026quot;\u0026quot;\n__round__\n#占位\n__rpow__(返回 yx [y的x次方] 的值)\nn = 3 print(n.__rpow__(2)) #输出：8\n__rrshift__\n#\u0026quot;\u0026quot;\u0026quot; Return value\u0026raquo;self. \u0026quot;\u0026quot;\u0026quot;\n__rshift__\n#\u0026quot;\u0026quot;\u0026quot; Return self\u0026raquo;value. \u0026quot;\u0026quot;\u0026quot;\n__rsub__\n#\u0026quot;\u0026quot;\u0026quot; Return value-self. \u0026quot;\u0026quot;\u0026quot;\n__rtruediv__\n#\u0026quot;\u0026quot;\u0026quot; Return value/self. \u0026quot;\u0026quot;\u0026quot;\n__rxor__\n#\u0026quot;\u0026quot;\u0026quot; Return value^self. \u0026quot;\u0026quot;\u0026quot;\n__sizeof__\n#\u0026quot;\u0026quot;\u0026quot; Returns size in memory, in bytes \u0026quot;\u0026quot;\u0026quot;\n__str__\n#\u0026quot;\u0026quot;\u0026quot; Return str(self). \u0026quot;\u0026quot;\u0026quot;\nsub(相减)\n#\u0026quot;\u0026quot;\u0026quot; Return self-value. \u0026quot;\u0026quot;\u0026quot;\n__truediv__（相除）\n#\u0026quot;\u0026quot;\u0026quot; Return self/value. \u0026quot;\u0026quot;\u0026quot;\n__trunc__\n#占位\n__xor__（按位异或，运算符：^）\n#\u0026quot;\u0026quot;\u0026quot; Return self^value. \u0026quot;\u0026quot;\u0026quot;\nbit_length(返回二进制的最小长度)\n\u0026gt;\u0026raquo; bin(37) \u0026lsquo;0b100101\u0026rsquo;\n(37).bit_length() 6\nconjugate\n#占位\nfrom_bytes\n#占位\nto_bytes\n#占位\n","permalink":"https://water711.github.io/posts/2017-03-20-python3int%E6%95%B4%E5%9E%8B/","tags":null,"title":"python3 int（整型）"},{"categories":["python"],"contents":"__add__函数 (在后面追加字符串)\ns1 =\u0026lsquo;Hello\u0026rsquo; s2 = s1.__add__(\u0026rsquo; boy!\u0026rsquo;) print(s2) #输出：Hello boy!\n__contains__（判断是否包含某字符串，包含则返回True）\ns1 = \u0026lsquo;Hello\u0026rsquo; result = s1.__contains__(\u0026lsquo;He\u0026rsquo;) print(result) #输出：True\n__eq__（判断两个字符串是否相同，相同则返回True）\ns1 = \u0026lsquo;Hello\u0026rsquo; s2 = \u0026lsquo;How\u0026rsquo; result = s1.__eq__(s2) print(result) #输出：False\n__format__\n#占位\n__getattribute__\n#占位\n__getitem__\n#占位\n__getnewargs__\n#占位\n__ge__ (大于或等于)\nprint(\u0026lsquo;b\u0026rsquo;.__ge__(\u0026lsquo;a\u0026rsquo;)) #输出：True\n__gt__(大于)\nprint(\u0026lsquo;b\u0026rsquo;.__ge__(\u0026lsquo;a\u0026rsquo;)) #输出：True\n__hash__\n#占位\n__iter__\n#占位\n__len__(返回字符串长度)\nprint(\u0026lsquo;abc\u0026rsquo;.__len__()) #输出：3\n__le__（小于或等于）\nprint(\u0026lsquo;b\u0026rsquo;.__le__(\u0026lsquo;a\u0026rsquo;)) #输出：False\n__lt__（小于）\nprint(\u0026lsquo;b\u0026rsquo;.__lt__(\u0026lsquo;a\u0026rsquo;)) #输出：False\n__mod__\n#占位\n__mul__\n#占位\n__new__\n#占位\n__ne__\n#占位\n__repr__\n#占位\n__rmod__\n#占位\n__rmul__\n#占位\n__sizeof__\n#占位\n__str__(返回自已)\nprint(\u0026lsquo;abc\u0026rsquo;.__str__()) #输出：abc\ncapitalize(首字母大写)\ns = \u0026rsquo;tom\u0026rsquo; print(s.capitalize()) #输出：Tom\ncasefold（大写转换成小写）\ns = \u0026lsquo;TOM\u0026rsquo; print(s.casefold()) #输出：tom\ncenter (指定长度和填充字符，内容居中，填充字符留空则为空格)\ns = \u0026lsquo;Tom\u0026rsquo; print(s.center(20,\u0026rsquo;-\u0026rsquo;)) #输出：\u0026mdash;\u0026mdash;\u0026ndash;Tom\u0026mdash;\u0026mdash;\u0026mdash;\ncount(计算某个字符串出现的个数，第二个参数：起始位置，第三个参数：结束位置)\ns = \u0026lsquo;aabbbcccccdd\u0026rsquo; print(s.count(\u0026lsquo;cc\u0026rsquo;,3,11)) #输出：2\nencode（编码）\ns = \u0026ldquo;中文\u0026rdquo; print(s.encode(\u0026lsquo;gbk\u0026rsquo;)) #输出：b\u0026rsquo;\\xd6\\xd0\\xce\\xc4\u0026rsquo;\nendswith（判断字符串是否以某个字符或字符串结尾的，第二个参数：起始位置，第三个参数：结束位置）\ns = \u0026lsquo;Projects\u0026rsquo; print(s.endswith(\u0026rsquo;ts\u0026rsquo;)) print(s.endswith(\u0026rsquo;e\u0026rsquo;,0,5)) #输出：True # True\nexpandtabs（把1个tab键转换成7个空格）\ns = \u0026lsquo;H\\ti\u0026rsquo; print(s.expandtabs()) #输出：H i\nfind（查找某个字符或字符串的索引位置，第二个参数：起始位置，第三个参数：结束位置）\ns = \u0026lsquo;Hello\u0026rsquo; print(s.find(\u0026lsquo;o\u0026rsquo;)) print(s.find(\u0026lsquo;o\u0026rsquo;,0,3)) #找不到返回-1\n#输出：4 # -1\nformat(字符串格式化/拼接)\nname = \u0026lsquo;Tom\u0026rsquo; age = 18 s = \u0026lsquo;{0}\\\u0026rsquo;s age is {1}\u0026rsquo;.format(name,age) print(s) #或者 str = \u0026lsquo;{name}\\\u0026rsquo;s age is {age}\u0026rsquo; result = str.format(age=18,name=\u0026lsquo;Tom\u0026rsquo;) print(result) #输出：Tom\u0026rsquo;s age is 18\nformat_map\n#占位\nindex（查找某个字符或字符串的索引位置，和find不一样是，如果字符不存在，会报错）\ns = \u0026lsquo;Hello\u0026rsquo; print(s.index(\u0026lsquo;o\u0026rsquo;)) print(s.index(\u0026rsquo;e\u0026rsquo;,0,3)) #输出：4 # 1\nisalnum(是否为字母或数字)\ns = \u0026lsquo;!#\u0026rsquo; print(s.isalnum()) #输出：False\nisalpha(是否为字母)\ns = \u0026lsquo;123\u0026rsquo; print(s.isalpha()) #输出：False\nisdecimal（是否为十进制数）\ns = \u0026lsquo;123\u0026rsquo; print(s.isdecimal()) #输出：True\n#True: Unicode数字，，全角数字（双字节） #False: 罗马数字，汉字数字 #Error: byte数字（单字节）\nisdigit（是否为数字）\ns = \u0026lsquo;123\u0026rsquo; print(s.isdigit()) #输出：True\n#True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字 #False: 汉字数字\nisidentifier（是否为标识符/变量名）\ns = \u0026lsquo;1num\u0026rsquo; print(s.isidentifier()) #输出：False #因为变量名不能以数字开头\nislower（是否全部为小写字母）\ns = \u0026lsquo;Hello\u0026rsquo; print(s.islower()) #输出：False\nisnumeric（是否为数字）\ns = \u0026lsquo;123\u0026rsquo; print(s.isnumeric()) #输出：True\n#True: Unicode数字，全角数字（双字节），罗马数字，汉字数字\nisprintable(是否为可打印字符/能否原样输出)\ns = \u0026lsquo;\\n\u0026rsquo; print(s.isprintable()) #输出：False\nisspace（是否为空格）\nprint(\u0026rsquo; \u0026lsquo;.isspace()) print(\u0026rsquo;\\t\u0026rsquo;.isspace()) #输出：True # True\nistitle（是否为标题/每个单词首字母大写）\nprint(\u0026lsquo;Hello Boy\u0026rsquo;.istitle()) print(\u0026lsquo;hello boy\u0026rsquo;.istitle()) #输出：True # False\nisupper（是否全部为大写字母）\nprint(\u0026lsquo;BOY\u0026rsquo;.isupper()) print(\u0026lsquo;Boy\u0026rsquo;.isupper()) #输出：True # False\njoin(将序列中的元素以指定的字符连接生成一个新的字符串)\ns = [\u0026lsquo;H\u0026rsquo;,\u0026rsquo;e\u0026rsquo;,\u0026rsquo;l\u0026rsquo;,\u0026rsquo;l\u0026rsquo;,\u0026lsquo;o\u0026rsquo;] print(\u0026rsquo;\u0026rsquo;.join(s)) print(\u0026rsquo;-\u0026rsquo;.join(s)) #输出：Hello # H-e-l-l-o\nljust(指定长度和填充字符，内容左对齐，填充字符留空则为空格)\ns = \u0026lsquo;Hello\u0026rsquo; print(s.ljust(10,\u0026rsquo;-\u0026rsquo;)) #输出：Hello\u0026mdash;\u0026ndash;\nlower（字符串全部换成小写）\ns = \u0026lsquo;TOM\u0026rsquo; print(s.lower()) #输出：tom\nlstrip(移除字符串左侧指定的字符，默认为空格)\ns = \u0026rsquo; Tom\u0026rsquo; print(s.lstrip()) #输出：Tom\nmaketrans(创建字符映射的转换表，配合translate函数使用)\nintab = \u0026ldquo;abcde\u0026rdquo; outtab = \u0026ldquo;12345\u0026rdquo; trantab = str.maketrans(intab, outtab)\nstr = \u0026ldquo;Hello abc\u0026rdquo; print (str.translate(trantab)) #输出：H5llo 123\npartition（ 指定分隔符，将字符串进行分割）\ns = \u0026lsquo;IamTom\u0026rsquo; print(s.partition(\u0026lsquo;am\u0026rsquo;)) #输出：(\u0026lsquo;I\u0026rsquo;, \u0026lsquo;am\u0026rsquo;, \u0026lsquo;Tom\u0026rsquo;)\nreplace(把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。)\ns = \u0026lsquo;Tom\u0026rsquo; print(s.replace(\u0026rsquo;m\u0026rsquo;,\u0026lsquo;o\u0026rsquo;)) #输出：Too\nrfind(从右边查找指定字符串出现的位置，如果没有匹配项则返回-1)\ns = \u0026lsquo;one two one\u0026rsquo; print(s.rfind(\u0026lsquo;one\u0026rsquo;)) print(s.rfind(\u0026lsquo;one\u0026rsquo;,0,6)) #指定起始和结束位置\n#输出：8 # 0\nrindex(从右边查找指定字符串出现的位置，如果没有匹配项则报错)\ns = \u0026lsquo;one two one\u0026rsquo; print(s.rindex(\u0026lsquo;one\u0026rsquo;)) print(s.rindex(\u0026lsquo;one\u0026rsquo;,0,6)) #指定起始和结束位置\n#输出：8 # 0\nrjust(指定长度和填充字符，内容右对齐，填充字符留空则为空格)\ns = \u0026lsquo;Hello\u0026rsquo; print(s.rjust(10,\u0026rsquo;-\u0026rsquo;)) #输出：\u0026mdash;\u0026ndash;Hello\nrpartition（ 指定分隔符，从右边开始将字符串进行分割）\ns = \u0026lsquo;IamTom_IamTom\u0026rsquo; print(s.rpartition(\u0026lsquo;am\u0026rsquo;)) #输出：(\u0026lsquo;IamTom_I\u0026rsquo;, \u0026lsquo;am\u0026rsquo;, \u0026lsquo;Tom\u0026rsquo;)\nrsplit(指定分隔符对字符串进行切片，如果指定第二个参数num，则只分隔num次，最后返回一个列表)\ns = \u0026lsquo;a b c d\u0026rsquo; print(s.rsplit()) print(s.rsplit(\u0026rsquo; \u0026lsquo;,2)) #从右边开始，按空格分隔两次\n#输出：[\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026rsquo;d\u0026rsquo;] # [\u0026lsquo;a b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026rsquo;d\u0026rsquo;]\nrstrip(删除字符串末尾的指定字符，默认为空格)\ns = \u0026lsquo;!!! I am Tom !!!\u0026rsquo; print(s.rstrip(\u0026rsquo;!\u0026rsquo;)) #输出：!!! I am Tom\nsplit(指定分隔符对字符串进行切片，如果指定第二个参数num，则只分隔num次，最后返回一个列表)\ns = \u0026lsquo;a b c d\u0026rsquo; print(s.split()) print(s.split(\u0026rsquo; \u0026lsquo;,2)) #从左边开始，按空格分隔两次\n#输出：[\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026rsquo;d\u0026rsquo;] # [\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c d\u0026rsquo;]\nsplitlines(按换行符来分隔字符串，返回一个列表)\ns = \u0026lsquo;a\\nb\\nc\u0026rsquo; print(s.splitlines()) #默认参数为False print(s.splitlines(True)) #指定Ture参数，则保留换行符\n#输出：[\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;] # [\u0026lsquo;a\\n\u0026rsquo;, \u0026lsquo;b\\n\u0026rsquo;, \u0026lsquo;c\u0026rsquo;]\nstartswith（判断字符串是否以某个字符或字符串开头的，第二个参数：起始位置，第三个参数：结束位置）\ns = \u0026lsquo;Projects\u0026rsquo; print(s.startswith(\u0026lsquo;Pr\u0026rsquo;)) print(s.startswith(\u0026rsquo;e\u0026rsquo;,4,8)) #输出：True # True\nstrip(删除字符串前后的指定字符，默认为空格)\ns = \u0026lsquo;!!! I am Tom !!!\u0026rsquo; print(s.strip(\u0026rsquo;!\u0026rsquo;)) #输出： I am Tom\nswapcase（大小写互换）\ns = \u0026lsquo;I am Tom\u0026rsquo; print(s.swapcase()) #输出：i AM tOM\ntitle(转换成标题，就是每个单词首字母大写)\ns = \u0026lsquo;i am tom\u0026rsquo; print(s.title()) #输出：I Am Tom\ntranslate（根据maketrans方法创建的表，进行字符替换）\nintab = \u0026ldquo;abcde\u0026rdquo; outtab = \u0026ldquo;12345\u0026rdquo; trantab = str.maketrans(intab, outtab)\nstr = \u0026ldquo;Hello abc\u0026rdquo; print (str.translate(trantab)) #输出：H5llo 123\nupper(小写转换成大写)\ns = \u0026lsquo;Hello\u0026rsquo; print(s.upper()) #输出：HELLO\nzfill(指定字符串的长度。原字符串右对齐，前面填充0)\ns = \u0026lsquo;Hello\u0026rsquo; print(s.zfill(10)) # 输出：00000Hello\n","permalink":"https://water711.github.io/posts/2017-03-18-python3str%E5%AD%97%E7%AC%A6%E4%B8%B2/","tags":null,"title":"python3 str（字符串）"},{"categories":["python"],"contents":"一、数据类型\n1、数字\nint（整型） long（长整型） float（浮点型） complex（复数） 2、布尔值\nTrue或False 3、字符串\n二、变量\n变量命名规则：\n变量名只能是 字母、数字或下划线的任意组合 变量名的第一个字符不能是数字 变量名不能为关键字（例如：and，or，continue，break，in，else，print 等） ****三、字符串拼接\n1、使用加号（+）\nname = \u0026ldquo;Tom\u0026rdquo; age = 25 print(name + \u0026ldquo;s age is \u0026quot; + str(age)) #输出：Toms age is 25\n2、字符串格式化\nname = \u0026ldquo;Tom\u0026rdquo; age = 25 print(\u0026quot;%s\u0026rsquo;s age is %d\u0026rdquo; % (name,age) ) #输出：Toms age is 25\nps：在python中，使用+号连接字符串，每出现一个+号，就要重新在内存中申请一块空间，有多少个+号，就要申请多少块空间。一般不建设使用+号连接字符串。\n四、列表和元组\n1、列表（list）\n创建列表 str_list = [\u0026lsquo;Tom\u0026rsquo;,\u0026lsquo;Lucy\u0026rsquo;,\u0026lsquo;Mary\u0026rsquo;] 或者 str_list = list([\u0026lsquo;Tom\u0026rsquo;,\u0026lsquo;Lucy\u0026rsquo;,\u0026lsquo;Mary\u0026rsquo;])\n索引（访问列表中某一个值） str_list[0]\n追加（增加元素到末尾） str_list.append(\u0026rsquo;lilei\u0026rsquo;) print(str_list) #输出：[\u0026lsquo;Tom\u0026rsquo;, \u0026lsquo;Lucy\u0026rsquo;, \u0026lsquo;Mary\u0026rsquo;, \u0026rsquo;lilei\u0026rsquo;]\n插入（在指定位置加入元素） str_list.insert(1,\u0026rsquo;lilei\u0026rsquo;) print(str_list) #输出：[\u0026lsquo;Tom\u0026rsquo;, \u0026rsquo;lilei\u0026rsquo;, \u0026lsquo;Lucy\u0026rsquo;, \u0026lsquo;Mary\u0026rsquo;]\n删除（删除指定元素） str_list.remove(\u0026lsquo;Lucy\u0026rsquo;) print(str_list) #输出：[\u0026lsquo;Tom\u0026rsquo;, \u0026lsquo;Mary\u0026rsquo;]\n切片 str_list = [3,4,5,6,7,8,9] new_1 = str_list[1:3] #从索引1开始取，取到索引3 new_2 = str_list[0:6:2] #从索引0开始取，每两位一取，到第6位为止 new_3 = str_list[-2:] # 取后面2个数 new_4 = str_list[:3] # 取前面3个数 new_5 = str_list[::3] #所有数，每3个取一个\nprint(new_1,new_2,new_3,new_4,new_5) #输出：[4, 5] [3, 5, 7] [8, 9] [3, 4, 5] [3, 6, 9]\n2、元组(tuple)\n创建元组 age = (18,25,33) 或者 age = tuple((18,25,33))\n除了不能修改、增加、删除元素，其它操作元组和列表几乎一样。\n五、字典\n使用key-value的存储方式\n创建字典 phone = { \u0026lsquo;张三\u0026rsquo;:\u0026lsquo;13075632152\u0026rsquo;, \u0026lsquo;李四\u0026rsquo;:\u0026lsquo;15732015632\u0026rsquo;, \u0026lsquo;王五\u0026rsquo;:\u0026lsquo;13420321523\u0026rsquo;, }\n获取字典中key的值 print(phone[\u0026lsquo;张三\u0026rsquo;]) #如果key不存在，会报错，key用中括号装 print(phone.get(\u0026lsquo;老黄\u0026rsquo;)) #如果key不存在，返回None,key用小括号装\n#输出：13075632152 # None\n赋值 phone[\u0026lsquo;老黄\u0026rsquo;] = \u0026lsquo;13678623153\u0026rsquo; #新增 phone[\u0026lsquo;张三\u0026rsquo;] = \u0026lsquo;12300055555\u0026rsquo; #修改 print(phone) #输出：{\u0026lsquo;王五\u0026rsquo;: \u0026lsquo;13420321523\u0026rsquo;, \u0026lsquo;老黄\u0026rsquo;: \u0026lsquo;13678623153\u0026rsquo;, \u0026lsquo;张三\u0026rsquo;: \u0026lsquo;12300055555\u0026rsquo;, \u0026lsquo;李四\u0026rsquo;: \u0026lsquo;15732015632\u0026rsquo;}\n#因为字典是无序的，所以每次输出的排列顺序都可能不同\n删除 phone.pop(\u0026lsquo;张三\u0026rsquo;) #第一种方法 del phone[\u0026lsquo;李四\u0026rsquo;] #第二种方法 phone.popitem() #随机删除某一个\n遍历 for key in phone: print(key,phone[key]) #输出： # 王五 13420321523 # 张三 13075632152 # 李四 15732015632\n多级嵌套 phone = { \u0026lsquo;人事部\u0026rsquo;:{\u0026lsquo;老张\u0026rsquo;:\u0026lsquo;13700112233\u0026rsquo;,\u0026lsquo;老李\u0026rsquo;:\u0026lsquo;13432023152\u0026rsquo;}, \u0026lsquo;财务部\u0026rsquo;:{\u0026lsquo;小丽\u0026rsquo;:\u0026lsquo;13230555666\u0026rsquo;,\u0026lsquo;小映\u0026rsquo;:\u0026lsquo;13723688888\u0026rsquo;}, \u0026lsquo;技术部\u0026rsquo;:{\u0026lsquo;老罗\u0026rsquo;:\u0026lsquo;13866666333\u0026rsquo;} } print(phone[\u0026lsquo;人事部\u0026rsquo;][\u0026lsquo;老李\u0026rsquo;]) #输出：13432023152\n六、if语句\n1、if\u0026hellip;else\nage = 16 if age \u0026lt;18: print(\u0026lsquo;你还未成年呢\u0026rsquo;) else: print(\u0026lsquo;你已经成年了\u0026rsquo;)\n2、if\u0026hellip;elif\u0026hellip;.else\nscore = 85 if score \u0026gt; 0 and score\u0026lt; 60: print(\u0026lsquo;你的成绩不及格\u0026rsquo;) elif score \u0026gt;= 60 and score \u0026lt;80: print(\u0026lsquo;你的成绩及格了\u0026rsquo;) elif score\u0026gt;=80 and score\u0026lt;90: print(\u0026lsquo;你的成绩良好\u0026rsquo;) else: print(\u0026lsquo;你的成绩优秀\u0026rsquo;)\n七、while循环\ni=0 num=0 while i\u0026lt;=100: num+=i i+=1 print(\u0026lsquo;1-100累加等于%d\u0026rsquo;%num)\n八、for\u0026hellip;in循环\nnum = [] for i in range(10): num.append(i) print(num) #输出：[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n九、用户交互(input)\nimport getpass username = input(\u0026ldquo;username:\u0026rdquo;) password = getpass.getpass(\u0026ldquo;password:\u0026rdquo;) print(username) print(password)\n十、文件基本操作\n打开文件：f = open(\u0026lsquo;文件路径\u0026rsquo;，\u0026lsquo;模式\u0026rsquo;) 或者 with open(\u0026lsquo;文件路径\u0026rsquo;,\u0026lsquo;模式\u0026rsquo;) as f:\n模式：\nr：以只读方式打开文件 w：打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a：打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 w+：打开一个文件用于读写。(文件一打开就清空了，还能读到东西吗？) a+：打开一个文件用于读写。 读文件：\nread() readlines() readline() 的用法\nf = open(\u0026rsquo;d:/test.txt\u0026rsquo;,\u0026lsquo;r\u0026rsquo;) #以只读方式打开文件\nprint(f.read()) #read()一次读取文件的全部内容\nfor line in f.readlines(): #readlines()读取整个文件，并按行存进列表 print(line.strip(\u0026rsquo;\\n\u0026rsquo;)) #去掉行尾的\u0026rsquo;\\n\u0026rsquo;\nwhile 1: line = f.readline() #readline()每次只读取一行 print(line.strip(\u0026rsquo;\\n\u0026rsquo;)) if not line: break f.close() #关闭文件\n写文件：\nf =open(\u0026rsquo;d:/test.txt\u0026rsquo;,\u0026lsquo;a\u0026rsquo;) f.write(\u0026lsquo;hello,boy!\\n\u0026rsquo;)\nf.close()\n","permalink":"https://water711.github.io/posts/2017-03-17-python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/","tags":null,"title":"python3基础知识梳理"},{"categories":null,"contents":"wamp集成在安装完后默认是没有开启伪静态的，下面是wamp开启rewrite伪静态的方法：\n第一步：打开wamp安装目录里的bin文件夹，找到Apache安装目录下的conf目录中的httpd.conf这个文件\n(例如我的是：D:\\wamp\\bin\\apache\\Apache2.2.11\\conf)\n查找，“LoadModule rewrite_module modules/mod_rewrite.so”，去掉前面的“#”；\n第二步：找到“AllowOverride None”改为“AllowOverride All”，好像有两处；\n第三步：重启apache，完成！\n","permalink":"https://water711.github.io/posts/2015-12-12-wamp%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83%E5%BC%80%E5%90%AF%E4%BC%AA%E9%9D%99%E6%80%81/","tags":null,"title":"wamp集成环境开启伪静态"},{"categories":null,"contents":"这天在街上打电话，无意中听到了母子俩的对话，被妈妈的教育深深感动，教育孩子就该如此。\n“妈妈把你的酸奶喝光了，你委屈吗？”\n“委屈！”小男孩泪眼婆挲。\n“你把麦当劳厕所的厕纸抽光了，麦当劳的经理发现了会责怪搞卫生的阿姨，阿姨还可能被扣薪水，她委屈吗？”\n“委屈！”小男孩的眼睛不敢看妈妈，脸颊已经变红。\n这时妈妈像变魔术一样，从身后拿出了一瓶酸奶，“妈妈不应该没问你就喝光酸奶，妈妈跟你道歉，并给你重新买了一瓶。但是阿姨的委屈怎么办呢？”\n“妈妈，我也不知道怎么办！”孩子不知所措，手指把玩着衣角。\n“妈妈相信你能想到办法，试试看？”\n孩子认真地想了很久，“妈妈，我想到了，我将我最喜欢吃的棒棒糖送给他们好不好？”妈妈的神情有点犹豫，很明显这不是一个合适的道歉方式，可能是出于对孩子的支持，这对母子从便利店买了一大袋的棒棒糖。\n“那么，妈妈在外面等你，如果棒棒糖不行，妈妈可以先帮你赔钱，加油！”孩子点头。\n出于好奇，我跟着孩子进了麦当劳。\n正值晚餐时间，麦当劳的人非常多，服务员也非常忙碌，孩子每说一句话都被人群的声音淹没，举起棒棒糖的小手也始终没人接，孩子着急得大哭起来。孩子的妈妈只是在门外静静地看，也没打算进入帮忙，在她看来，孩子自己的错误要自己承担到底。\n这一哭，反倒让店经理出来了。\n“小朋友，怎么了？”店经理很亲切。\n“叔叔，我刚才把你们厕所的厕纸全都抽光放书包里了。”孩子打开了小书包，里面白花花的竟然有半书包的纸巾！店经理惊讶了，但又不知如何处理。\n“现在我知道错误了，请不要责怪打扫卫生的阿姨，妈妈说她很委屈的。我让妈妈帮忙买了一袋棒棒糖，是我最喜欢的，送给你们道歉可以吗？妈妈说赔钱也可以……”店经理看了看门外的女人，终于明白了。\n他蹲下来说：“好吧，接受你的道歉，我们原谅你了！不过下次不能再拿这么多纸巾了哦！”小男孩如释重负，说了声“谢谢”，然后笑容满脸地找妈妈了：“妈妈，买棒棒糖的钱我出……”\n有句话说的很对，“母亲的素质决定孩子成功与否，母亲的性格决定孩子出不出色”，孩子们在成长的过程中，会遇到各种各样的问题，他们有时会很脆弱，有时会很迷惑，妈妈就是孩子们成长的导师，需要为他们指出正确的方向。\n孩子们做错事时，不少家庭的做法大概只是责骂一下做错事的孩子、让孩子下次不再犯，却忽略了让孩子为自己的错误承担点什么，但往往后半部分才是让孩子养成良好性格和品德的重要一步。\n上面的妈妈给我们做了很好的示范：\n首先让孩子意识到错误，鼓励孩子自己决定弥补错误的方式，然后将弥补错误的责任归还给孩子……\n孩子在这个过程中，不仅学会了改掉了贪小便宜的坏毛病，还懂得了担当，更学会了如何跟陌生人接触，不得不说这是一次超棒的教育！爸妈们学会了吗？\n来源：幼儿教育专家\n","permalink":"https://water711.github.io/posts/2015-12-02-%E5%AD%A9%E5%AD%90%E5%9C%A8%E9%BA%A6%E5%BD%93%E5%8A%B3%E5%81%B7%E7%BA%B8%E5%B7%BE%E5%90%8E%E5%A6%88%E5%A6%88%E9%97%AE%E4%BA%864%E4%B8%AA%E9%97%AE%E9%A2%98/","tags":null,"title":"孩子在麦当劳偷纸巾后，妈妈问了4个问题"},{"categories":null,"contents":"有白帽子在乌云报告了一起钓鱼攻击事件，说起钓鱼各位已经是身经百战了，但乌云君发现此次事件暴露出目前钓鱼团伙的一些流行的套路和技术手段。另外还发现此类站点居然存在一些入门级的web安全漏洞，可能会导致受骗者信息二次、三次、四次、五次。。。泄露，鱼篓子漏了一地。\n漏洞地址：仿冒电信运营商掌上营业厅的大规模钓鱼事件(大量用户银行卡中招CVV2与密码泄露)\n此次钓鱼攻击由三个部分组成：\n短信撒网 返利活动欺诈 控制用户手机 -\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-重现流程\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n“鱼饵”来自一条短信\n这条短信可能会通过伪基站、短信伪造或简单粗暴的直发手段推送到用户的手机上，获取你的信任。\n用户：纳尼？！运营商返现？！终于看到回头钱儿了？？！！\n运营商：你想到美！\n点击那个URL后发现，现在想钓鱼不学点Web前端技术都不好意思钓，这（些）个网站居然还对手机访问进行了适配，专门针对手机用户。可以看出跟以前另存为个页面进行的钓鱼不同了，现在的钓鱼者更注重细节！\n（注：由于钓鱼攻击案例通过乌云报告后，涉及的钓鱼网站被陆续下线，所以截图与短信中的网址不同，但此次事件都是 ＊＊＊189.com综合手机媒体平台 这种格式，请用户认准）\n用户：电信你坑我钱！\n电信：关我毛事啊？\n钓鱼网页没啥稀奇的，还是尽可能的骗取信任，获取你的银行卡消费因素（姓名、手机、卡号、密码、身份证、有效期、CVV2等等）。让白帽子哭笑不得的是，钓鱼团伙没有保护好已到手的数据，竟然存在一个WEB入！门！级！的安全漏洞，导致受害者信息可被二次、三次、四次、五次。。。泄露！\n数千受害者银行卡信息，几乎都可以拿来直接在网上消费。原来，被钓鱼只是噩梦的开始。。。\n用户：钓鱼的，你他么坑我！\n钓鱼者：关我毛事啊？\n然后，乌云白帽子又根据蛛丝马迹发现钓鱼团伙的恶意Android APP，乌云白帽子对其进行了功能性分析（一只android短信控制马的简单分析）。首先安装了恶意APP的手机会向钓鱼者（1550173****） 发送软件已经被安装与激活的信息，最重要的是钓鱼者获取到了你得手机号码。\n然后会提醒用户是否要激活管理设备，注意，一旦选择了激活，该APP就会隐藏在你的手机系统中，并且难以卸载！ 从APP申请的权限来看，是一款攻击用户短信的木马\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_SMS\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.SEND_SMS\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_SMS\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.RECEIVE_SMS\u0026#34;/\u0026gt; 以上权限分别代表“编写短信”、“发送短信”、“网络权限”、“读取本地短信（历史收到的）”、“实时接收短信广播（这个比较狠，可以获取刚刚到达的短信并截断）”。\n程序总共发了7条短信6条是发给 1550173**** 大多是 安装成功，激活成功，发送成功这类消息用来判断受害者状态。只有一条短信是根据钓鱼者发送的短信提取出号码以及内容再发送。就是说黑客可以用短信控制你发送指定短信到指定号码。难道是要。。。\n用户：手机制造商、运营商、钓鱼的、黑客们，你们妹啊！！\n手机制造商、运营商、钓鱼者、黑客们：你自己愿意上当关我们毛事？\n上面戏说了下现在的主流移动端钓鱼手段，简单伪造页面的钓鱼早已是昨日往事。钓鱼者们也是在与时俱进，积极的学习中，整的现在傻子都不够用了。\n钓鱼者的上进特别体现在对钓鱼APP的反逆向与自我保护上，比现在很多企业的技术都要强！而且一些天天吹嘘自己手机查毒多牛的产品也纷纷拜倒在渔夫脚下。。。\n用户：乌云君，救我。。。\n乌云君：报告中涉及的钓鱼站点已经陆续被封杀下线，有过上述经历的朋友们注意自己的银行消费行为。另外昨天有伙疯狂的人对乌云持续了整整一天的DDOS攻击，不知是不是这伙愤怒的渔夫。。。\n好了，看热闹的都散了，祝大家周末愉快。\n原文来自 wooyun@知乎\n","permalink":"https://water711.github.io/posts/2015-11-17-%E4%BB%BF%E5%86%92%E7%94%B5%E4%BF%A1%E8%BF%90%E8%90%A5%E5%95%86%E6%89%8B%E6%9C%BA%E8%90%A5%E4%B8%9A%E5%8E%85%E7%9A%84%E5%A4%A7%E8%A7%84%E6%A8%A1%E9%92%93%E9%B1%BC%E4%BA%8B%E4%BB%B6/","tags":null,"title":"仿冒电信运营商手机营业厅的大规模钓鱼事件"},{"categories":null,"contents":"一般我们准备做一个博客网站之前，大概都是什么样的状态呢？嗯……让我猜猜，你大概是兴奋 ！其实这不单是你，很多博主在建立自己域名的独立博客之前都是一样的状态。 现在的互联网主机市场，到处都是“顶级虚拟主机”的网站（这些基本的都是个人网站，要么是代理，要么是自己租用别人的，要么是自己随便整两个机子），便宜的价格，无限制的空间，各种优惠…等等都会吸引你去购买他们的相对“便宜和最好的”虚拟主机。\n错误1：搜索“顶级虚拟主机’ 在互联网上，最不幸就是好和坏都是共存的，主机服务也是一样。还有很多人希望随便做点事情就可以赚一些钱。 各种所谓的“顶级虚拟主机的网站管理员”大概就属于这一类。 他们卖出去的大部分所谓的“顶级虚拟主机（通常是共享主机）”中，很多是根据客户下单的金额多少来订购相应的主机配置。 很明显，很多在这些网站上的主机质量数据是都是假的。\n现在有很多假的主机评测网站，当然也有很多假的评论在里面。选择一个真正的虚拟主机评测网站或论坛也是很重要的。国内的主机评测网站，暂时还没有一个像样的，至少我个人觉得是这样。不管是主机之家，主机评测网还是虚拟主机评测网，都差不多。国外主机评测论坛推荐一个WebHostingTalk，做的不错。\n错误2：寻找各种“无限”的虚拟主机 很多人刚开始建站的时候，就在寻找“无限”的虚拟主机。好像都认为，那些idc提供的所谓“无限”，都是最好的主机。但是一般的博客或者企业网站在刚开始的时候根本不需要什么无限的空间，无限的流量。这些多余的东西一点用都没有。最重要的还是稳定和速度。\n看着上面的图片是不是很眼熟啊。淘宝一搜一大把这样的广告图片。又高速，有稳定，还在美国，你信么？\n事实上，没有一个idc会提供“无限”的服务，至少虚拟主机这个行业不会有。什么无限制空间，无限制域名绑定，无限制转发，无限制流量…那都是浮云。这些都是不可能的，有脑子的人都会知道，哪个逗比会让客户在主机上托管一个无限的帐户，更不用说为他们提供无限的存储和带宽。\n错误3：价格比什么都重要 在第一次选择购买虚拟主机的时候，不要让价格成为决定购买哪台主机的唯一因素。 当然，便宜的主机看起来总是很受欢迎的，但不要忘了“便宜”和“买得起”的差别。没钱的时候，再便宜的主机在你面前也是高价。\n我之前购买过一个景安的Linux主机，从代理那边淘宝购买的，180一年，空间整体配置和流量额都相当不错。第一年服务都还可以（毕竟是景安的），第二年不知道搞什么，直接代理网站挂了，然后贴了一个公告，说公司内部原因，所有的主机业务都放弃了。我的空间也这样不了了之了，ftp账户权限被封，只能下载，不能上传。没多久这个网店都变成了卖鞋子衣服什么的了，人也联系不到。可惜我的一年主机只用了三四个月。\n顺便曝光一下这家垃圾的IDC代理公司：卓亿网络。大家以后别相信他们。\n一个好的虚拟主机所能提供像样的服务和客户的付出是对等的。如果一个IDC提供各种高端配置服务，但是他们的价格又很便宜，那么这家公司不是骗子就是逗比。\n因为有句老话说的好： 一分价钱一分货。虚机主机也是一样！\n错误4：被忽略的服务条款 大多数人不关心idc提供的服务类型和有关邮件系统的一系列说明。事实上是，如果你不读你购买签约的主机服务条款，你的网站出麻烦那是迟早的事。 出事的概率比你去找那些“无限”的虚机主机还要高，因为很多IDC试图通过他们的服务类型来限制你的资源使用情况。包括邮件系统账户的各种限制，比如有多少邮件账户，您可以每小时发送多少封邮件等等。\n服务类型通常还包括主机的退款政策。 不要相信那些什么“30天无忧退款”、“7天不满意全额退款”之类的标语。 好好看看你的idc提供的退款政策是和你认为的是实际相符的，绝对有益。\n错误5：选择“最便宜”的虚机主机 当你看了很多idc广告和网站之后终于决定要购买一个虚拟主机的时候，买一个最便宜的主机并不是最适合你的。虚拟主机的空间配置和价格从始至终都是相关联的。如果想要得到应有的服务，那么就要付出相应的金额。\n最好的一个例子就是一些idc的免费活动。下面以景安IDC（绝对不是帮人打广告，骂娘的滚一边去）为例子。\n看见上面的免费空间的配置了么。看起来还是挺诱人的。但是别忘了页面底部下面的一些注意事项：网站需要备案，而且有类型限制，而且首页必须加上景安的logo连接，不能使用js跳转等等，不然就给你来个无理由删除。\n为什么有些主机商同时提供免费和收费两种服务呢？\n答案是： 免费的服务提供支持较差，不保证对服务器的稳定性和正常运行。此外，一旦你的网站所占空间和流量增大了，你绝对会受到某一个资源的限制或者是其他限制，这点估计在他们的服务条款中也会提到这样的约束，有没有仔细看那就是你的事情了。\n错误6：对新主机还不是很了解就购买一年时间 如果你没有什么购买使用虚拟主机的经验，那么建议不要一下子购买一年或一年以上。因为大多数情况下，你很难拿回在别人口袋里但是是属于自己的钱（包括那些号称各种包退的），你买的时间越长，浪费的也有可能越多。\n就像我现在用的阿里云主机，我是试用过一些时间才决定购买的。当然，有些主机是不提供试用的，那么你可以选择购买一个月，或者更短的一个试用周期，看看具体的使用效果。好的话可以直接续费一年，不行就再换一个（如果你忍受不了折腾，又或者你是个土豪，那就另说了）。\n任何主机测评网站的评论都没有比自己去试用更知道他们的服务质量。\n总结： 当你开始建自己博客网站准备购买虚拟主机时，请记住这6个失误。大家通常在犯的错误，你就不要再犯了。选择了一个好的虚拟主机，对你的网站运行和后期的推广运营都会起到相当大的作用。 当然，如果你不在乎那点小钱，你可以直接选择一些大的虚拟主机提供商，理由就不再赘述了。\n如果你碰巧也犯了上面的这些错误，欢迎在下面吐槽交流。\n原文来自欲思博客\n","permalink":"https://water711.github.io/posts/2015-11-16-%E9%80%89%E6%8B%A9%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E5%B8%B8%E7%8A%AF%E7%9A%846%E4%B8%AA%E9%94%99%E8%AF%AF/","tags":null,"title":"选择虚拟主机常犯的6个错误"},{"categories":null,"contents":"搜索引擎的一些高级搜索指令，帮助你更快的找到想要的信息，更是seo人员必备的技巧. 1、双引号显示完整信息：双引号代表完全匹配，现在百度和Google都支持该指令。在搜索时把关键词加上双引号就能返回包括整个完整的词的搜索结果。比如我们搜索“糖半甜饮品”这个关键词，如果加上双引号的话，那么返回的结果只显示那些完整出现糖半甜饮品的网页，单独出现糖半甜和单独出现饮品，以及糖半甜饮品没有完整连续出现的页面将不显示。这样在做SEO的时候就能一步到位的准确查找指定的竞争对手。\n2、减号结果更精准：有时候我们搜索一个词的时候却返回了很多不想要的结果，搜索引擎认为很多词和你搜索的词有一定的相关性就全部返回了搜索结果，这样就会给我们找到目标页面带来很大的影响。这时就能使用减号这个高级指令，比如搜索“糖半甜 -饮品”，返回的结果如下图所示，需要注意的是在减号前面一定要有空格，减号后边紧跟要排除的词。\n3、星号适用Google：现在百度、soso和搜狗三个搜索引擎不支持星号，而Goolge支持，喜欢Goolge的朋友要注意星号的使用。星号是一个通配符，能匹配所有的字符，在一些特殊的情况下可以使用星号进行搜索。比如在Goolge中输入“搜索*擎”，那么会显示包括搜索影擎之类的结果。\n4、inurl包含网址：inurl是我个人最常用的高级搜索指令之一，十分强大，支持百度、Google都主流的搜索引擎。inurl从字面的意思可以看出就是网址中包含的意思，比如你搜索一篇文章时候，想快速知道某个网站是否收录了这篇文章，就能使用inurl这个指令，具体的用法是inurl：adc或者abc inurl:efg，前者只是搜索网址中包含abc的结果，后者是网址中包含efg并且内容包含abc。这个指令建议大家好好练习多使用，很有用。\n5、inanchor主要检查锚文本：这个指令可以返回导入锚文本中包含搜索词的页面，比如一个锚文字是A，链接的网址是B，那么用inanchor在搜索A这个关键词时，显示的结果为B，因为A有指向B的锚文本链接。但遗憾的是百度目前不支持这个指令。我们可以使用Google来查询竞争对手都做了哪些外部链接，这一点在优化的过程中十分有用。\n6、intitle查看标题关键词：intitle顾名思义包含在title中的意思，当我们使用intitle这个搜索指令时，就会返回标题中包含该关键词的网页，这样就能返回更加准确的结果。比如我们研究某个关键词的竞争程度，可以在搜索引擎中使用intitle指令，这样就能看到以该关键词为目标的全部竞争对手，能很好的帮助我们筛选最主要的竞争对手。普通用户也可以使用这个指令，能找到更加符合的信息，相当于一个过滤作用。\n7、allintitle词串：这个指令指的是返回的页面标题中包含多组关键词的文件，比如我们搜索SEO和搜索引擎优化，使用这个指令应该是allintitle：SEO 搜索引擎优化，其作用相当于intitle:SEO intitle:搜索引擎优化。只不过这个指令有些不好记，单词过长，一般情况下使用intitle还是比较多的。但如果能记住这个词的话，有时候还是能用的上。\n8、allinurl组结果：这个指令类似于inurl，指返回url中包含所有搜索关键词的相关结果。但是使用inurl一次只能搜索一个词，而使用这个一次能搜索一个词组。大家感觉这个词不要记的话可以进行拆分，分别拆成三个单词，all、in和url，这样all是全部的意思，in是里边，包含的意思，url指的是中文网址。那以后在搜索的时候就可以使用这个指令。\n9、filetype特定文件：这个指令还是很有用处，比如我们想搜索电子书或者是doc、txt、pdf文档时，就能利用这个方法，主要的作用就是返回搜索类型相匹配的文件。现在百度和Google都支持这个指令。但并不是所有的格式百度都会支持，现在百度支持的格式有pdf、doc、xls、all、ppt、rtf，其中的all表示搜索所有百度支持的文件，这样返回的结果就会更多。\n10、site查询收录：site大家可能再熟悉不过了，是SEO中最常用的指令，用来查看搜索引擎对某个域名下的所有收录文件。seo人员每天都会查看自己网站的收录数量，但是site不是完全准确，只是一个大概的数据，尤其对于Google，使用site时经常有大幅度的波动，只是大家可以参考的数据。但一般的收录查询用这个就完全可以了。因为搜索引擎的数据在实时的进行变化，所以我们也不需要完全的收录数据，现实中也不可能得到。\n11、link查询链接：link是SEO中比较常用的一个高级指令，主要搜索某个网站url的内部链接和外部链接，但这个指令并不是对每个搜索引擎都很准，尤其是Google，它只会返回索引库中的一部分，并且是随机的一部分，而百度则不支持这个指令。但好的是雅虎全面支持，而且查询的比较准确，一般我们查看网站的链接都以雅虎为准，现在很多站长工具，不论是网页的也好还是软件的，一般都是提供的雅虎数据。\n12、linkdomain查询反向链接：反向链接在SEO中的作用我想每个优化人员都知道，一个网站反向链接的多少能直接影响该网站的整体权重，所以常常查询网站的反向链接时，就要使用这个linkdomain命令。和link类似，百度和Google都不支持，所以以雅虎为准。比如查询一个域名http://www.bft888.com的反向链接，那么就可以再地址栏中输入：linkdomain:http://www.bft888.com -site:http://www.bft888.com，这样查询的数据就比较准确，已经排除了自身的内部链接。使用这个命令不但对自己有很大帮助，更能迅速的找到合适的竞争对手都做了哪些外部链接，能为我们省去不少的时间。因此对于站长朋友，一定要记着这个强大易用的指令。\n13、related查相关页面：这个指令和前边唯一相似的地方在于只是用一个搜索引擎，这个使用于Google。他的作用是返回与搜索结果想关联的页面。我们使用related可以查询自己的网站和哪些网站有关联。这是个很有趣的命令，但是Google官方并没有正式说明有关联具体都指什么地方。根据我们搜索时发现，一般都会显示与你网站有相同外部链接的网站。例如搜索A这个站点，会返回B、C、D等一些列站点，这些站点通常都有有相同的外部链接。所以，这个命令的实用性价值没有linkdomain高，但也能从一定程度上分析竞争对手在外部链接上和我们都做了哪些相同的工作。\n","permalink":"https://water711.github.io/posts/2015-11-15-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8C%87%E4%BB%A4/","tags":null,"title":"搜索引擎之高级搜索指令"},{"categories":null,"contents":"\n昨日乌云君的朋友圈还是几只队伍在疯狂刷屏：\n白金队 黑蓝队 撕港澳通行证队 跑出手机的3D二逼熊队 duang~duang~队\u0026hellip; 以为这些队伍的节奏会保持几天，结果就在当晚一张模糊的“江苏省公安厅电文”内容造就了今天的新队伍——“海康威视队”（话说这么重要的电文咋这么容易就被传到网上呢？这也太不小心了）\n如今的用户对安全的敏感与警觉性有了很大的提升，视频监控设备漏洞对咱普通百姓有啥影响呢？还是从乌云君擅长，并能够解答的技术部分给大家聊影响，其他不了解的内容就不去下定论。\n关于这家监控系统弱口令的问题，在 2013年的6月份 就已经有白帽子提醒了 海康威视监控后台99%存在弱口令 。但直至今日仍有大量的机构存在弱口令，可随意接入甚至控制设备（注：弱口令是指设备出厂后，系统设置了非常简单的管理员密码，如“12345”这种）。重要的是，早已有黑客盯上了此类系统。\n原文地址：Hackers are using Internet-connected appliances to mine Bitcoins 咱们先把场景切换到韩国，这个漏洞报告很有趣，有白帽发现一些海康威视出口设备的弱口令，韩国用户也没修改。。。而且监控设备似乎还被装在了奇怪的地方。\n漏洞地址：韩国某视频监控网站大量海康威视监控后台弱口令\n这个，这个角度装的真是赞啊。。。视频监控设备最直接的影响就是泄漏监控场所的实时情况，甚至不该看的地方与行为。\n它安装的场所还有可能是更敏感的，如：银行、公安、司法、交通、能源、监狱等场所。而且面临安全问题的监控设备并非海康威视，还有很多品牌的产品甚至已经入驻到我们家里，比如： 某省电信天翼看家视频监控运营商管理系统后台登录,可查看用户摄像头(\u0026lsquo;看\u0026rsquo;家,你懂的)\n某教育监考系统存在弱口令漏洞可劫持视频监控\n所以各位在任何场所在看到监控摄像头时，请保持微笑（除了这还能做啥？）\n现在场景在切回国内，有白帽子发现有黑客制作了利用物联网设备弱口令传播攻击的蠕虫病毒，这种病毒可以自动寻找目标并且植入后门控制设备，然后利用设备资源进行——比特币挖矿（生财有道），或者作为僵尸节点继续攻击其他物联网设备！ 报告地址：如何实现物联网设备批量开采比特币？（蠕虫实现剖析）\u0026mdash;物联网安全\n蠕虫使用的弱口令中，admin/12345 root/12345 对海康威视设备有着较高的命中率，这些设备也就自然成为了蠕虫滋生的温床。另外蠕虫还对linksys、D-link等设备的漏洞进行多种漏洞利用的探测，简直就是人造的孽障啊！以后的人工智能是不是就这样干掉人类的？通过恶意代码来近距离接触下。\n僵尸后门的下载源头来自国外，乌云上还有个对本国蠕虫的分析 海康威视等监控和物联网设备被用于僵尸网络的实例，有恋虫癖的朋友可以mark下。\nPS:上图为某实体设备中控指纹系统，也存在默认口令（估计还未受到重视）。希望更多的设备厂商以此为戒，提前做好设计，否则以后影响的可能不仅仅是视频监控了。还未直接过招，就败给自动化的攻击代码，很可悲。视频监控、路由等等设备已经成为了安全重灾区。希望相关的企业不要等到事情难以控制已经造成影响的时候才重视，安全是态度与平时的积累，不是临时冲刺就能解决的。\n昨天最先报告海康威视事件的都是些财经相关网站，这是因为啥呢？ 乌云君好像悟到了：）\n原文来自 wooyun@知乎\n","permalink":"https://water711.github.io/posts/2015-11-14-%E6%B3%A8%E6%84%8F%E9%9D%A2%E5%AF%B9%E5%90%84%E7%A7%8D%E7%9B%91%E6%8E%A7%E6%91%84%E5%83%8F%E5%A4%B4%E8%AF%B7%E4%BF%9D%E6%8C%81%E4%BD%A0-duangduang%E7%9A%84%E5%BE%AE%E7%AC%91-/","tags":null,"title":"注意！面对各种监控摄像头请保持你 duang~duang~的微笑 ：）"},{"categories":null,"contents":"****\n我不算一个合格的程序员，我仅仅在两三年前自学过一点 PHP，然后大一和大二这学期在课堂上照本宣科的学习了C，C++和 JAVA，除了 PHP 外，其它的语言也就达到一个写个计算器的程度。\n虽然如此，可是我还是要说，我深深的为神奇的程序世界所着迷，我的智力和精力都有限，可是程序世界的可能性是无限的，其魅力也是无限的。\n我知道很多非常非常牛逼的程序员，在他们的世界里面，没有『不能实现』这个词，在程序的世界里面，他们就是神。\n我也相信很多程序员在最早的时刻，早到他们还没有被称之为大神的时候，早到他们在技术社区还默默无闻的时候，早到一个 helloworld 就让他们欣喜若狂的时候，他们都拥有一颗程序员的初心，就如同被称之为『魔咒』的『hello world』一样，都寄予着所有程序员对这个美好世界的热爱和希望。\n时过境迁，光阴流 转，当年稚嫩的小白已经成长为被各大公司争抢的牛逼存在，写出的代码也不再仅仅放在自己的小服务器上面自娱自乐，而是服务于成千上万的用户了。再然后，程 序员升职加薪，当上总经理，出任 CEO，迎娶白富美，完成了光鲜亮丽的人生，这个时候，当初的那颗『程序员的初心』可能就渐渐泯灭了。\n年轻而贫穷的程序员可能为了心中那个关于『创造和改变』的理想而前赴后继。而声誉与身价渐长的老手们则会有越来越多的顾虑——这是人之常情。可是总有一个时刻，所有程序员的心中都会浮现出那个和 hello world 一起的，创造更美好世界的初心。\n无论有多高的身价，无论有多大的名声，也无论有多高的技术，程序员总或多或少的保持着当初那颗编程的初心。走的时候不要太急，有时间要停下来想一想当初为什么而走，这样，才会走的更稳，走的更明白\n原文来自HTML5中国\n","permalink":"https://water711.github.io/posts/2015-11-14-%E7%BC%96%E7%A8%8B%E7%9A%84%E5%88%9D%E5%BF%83/","tags":null,"title":"编程的初心"},{"categories":null,"contents":"作为办公设备的打印机，如今已经成为各级党政机关、单位不可或缺的办公工具。这些设备在给工作带来便利的同时，也对信息安全构成了潜在威胁。\n大家都应该知道，凡事涉及“保密承诺”的文件，涉密双方都应该积极的保证文件或项目信息的安全。但是！当我们做好了一切保密工作后，很可能还会栽在这个地方……\n看到这个东西第一印象会觉得他是个网站。没错，不过别小瞧它，就是这个“网站”，导致泄露了移动某省分公司的4G业务、资源分析报告，工作计划甚至是某公司与移动签署的保密协议。乌云该漏洞报告地址：中国移动某省公司打印机未授权访问已成功下载移动内部资料（保密承诺书？）\n那它究竟是谁建立的？白帽子又仔细看了会儿，发现它原来竟然是一台打印机，这么半天原来一直在上一台打印机！\n用第一张图中显示的型号搜索了下，发现打印机价值个几万块钱，怪不得还有_个人主页_功能（其实低端版的打印机也有，但很low）。那既然是打印机，就一定要翻翻曾经打印过的文档有哪些，这一翻可了不得。\n一份加盖了公章的“4G业务质量与资源分析报告”就泄露了，还包括下一步的工作计划，不知道联通电信的伙伴怎么看。除了这个，还有一份需要打印的“保密承诺书”。\n说好了保密的呢？\n乌云君找了一台“大哥牌”打印机，由于比较low，没找到扫描件存储功能（移动那台确实比较壕华）。但不管多low，这玩意都是有设置管理密码功能的，只是一般的管理员不知道打印机还这么调皮自己搞了个人主页，还开在公网了。\n以后使用打印也要注意姿势！\n原文来自知乎日报\n","permalink":"https://water711.github.io/posts/2015-11-13-%E6%B2%A1%E6%83%B3%E5%88%B0%E6%89%93%E5%8D%B0%E6%9C%BA%E4%B9%9F%E4%BC%9A%E6%B3%84%E5%AF%86/","tags":null,"title":"没想到，打印机也会泄密？？？"},{"categories":null,"contents":"****\n今天是一年一度的电商“双11”购物狂欢节。相信不少“剁手党”已经开始血拼了，购物的同时，你们也要小心订单信息的泄露哦。\n相信很多人都曾面临过自己的订单信息泄露引起的诈骗或者骚扰电话、典型的机票改签骗局、订单退款骗局等等。每次大家都很愤怒的认为电商平台在出卖自己的信息，然而事实上是怎样，我想从我负责订单信息泄露两年的实际经历来谈谈我的看法。\n要了解订单究竟从哪里泄露的，要看整个产业的流转情况。我们下单买一个东西，大体上要经过商家、电商平台、物流、最后到达用户手中，所以这四个环节都有可能产生订单信息泄露的问题。我从自己的事件库里拉出来我们自己的一个分析，每家情况可能不一样，仅作参考。\n一、商家环节\n商家和电商平台在有些时候是一个，但在中国是有很多第三方卖家的。例如你在某宝买充气女朋友，某宝是平台，而卖家可能是福建一个批发街上的小铺子。也就是自营和第三方商家的区别，一般来说我们认为自营的安全性比较高，而第三方商家则参差不齐，存在较大的风险。\n在实际工作中，我们也统计过案例，实际上看到的数据，商家确实是订单泄露最主要的原因。但这只是基于我们自己的数据来看。商家信息泄露表现比较突出的有五种原因：\n**1、内部倒卖。**内部员工倒卖订单数据分为两种情况，一种是内部员工行为，另一种则是黑产打入的行为。先说内部员工行为，一个小型商家对员工的录用，大家可想而之是个什么情况。不在乎学历，不在乎背景，只要有点经验即可，而且待遇也比较低，员工流动也大，因此面对一些诱惑，很容易去倒卖数据，卖了几批数据后就跑路换个其他公司接着做。还有一种是黑产打入，黑产直接派一些人去应聘，然后拿数据，也是干一阵就跑。\n对付这种倒卖行为，要求商家去加强员工入职管理和权限管理，但对于这么小的商家，可能只有三五个人的商家，很难谈得上什么管理，更谈不上所谓的权限控制。一个大的平台，可能会有几百上千万大大小小的商家，这个管理难度不亚于治理一个国家了。一个稍微可行的办法是，要求所有商家的员工入职前统一上传身份证照片，然后建一个库，对发现这种行为的打上标记，禁止进入，只不过，这仍然取决与商家的管理水平，你可以想象得到，商家会随便应付一下。但至少比没有要好一些，能形成一些震慑力。\n**2、木马病毒。**商家的员工有时候会接待一些声称有大订单的人物，订单包括多种需求，所以会需要员工接收订单文件，又或者发给员工一个链接，而木马病毒就在这里了。木马和病毒会潜伏下来监控员工电脑操作，获取订单软件系统信息的帐号密码。之前我们也反复教育过商户，不要使用QQ、邮箱之类的接收来历不明的文件，但是面对这个群体，你能想到这种教育的效果。我们也曾经考虑过，给商户的电脑统一安装我们自己开发的杀毒软件，但这是一个很大的工程，木马病毒又会不断变形产生对抗，等于要成立个防毒软件公司了，。\n**3、三方工具后门。**在线销售会需要一些系统的支撑，比如仓库管理、订单管理、面单打印等，市面上也有各种公司提供这一类软件，这种软件水平也参差不齐。有的直接就是黑产这种人开发的，目的就是窃取订单信息。还有的属于安全能力薄弱，有一些漏洞可以被利用，但是单一的某个软件漏洞还不够可怕，现在很多公司为商家提供一揽子服务，订单系统的服务器都在云上，一旦突破就是一个大群体订单泄露。所以针对这个情况，我们做了两件事，一是要求所有的软件系统都必须经过我们的安全测试，否则不给接口，在这一关做一层控制，但这也还不够，因为有些比如快递打印系统，是不需要直接调用我们的接口的，另外即使做了代码的检查，也仅仅是软件级的，出现事件后无法追溯到底哪个环节出了问题。所以我们又建了个云服务器区，建议商家和软件提供商迁移到这里来，这样一旦出了状况，我们能通过日志分析查找根源。\n例如曾经有段时间比较流行的某订单打印软件，按正常功能，应该是能够同步我们的平台和物流公司。但在出问题的那几周，物流公司反馈无法同步到订单打印信息，而欺诈分子就会利用这个时间进行电话欺诈。根据这个疑点，我们停用订单打印软件后，这家店铺的客户订单欺诈明显消失。\n**4、弱口令。**我们会给商户提供一个在线的订单管理平台，再加上商户自己用的平台，都会存在弱口令问题。所谓弱口令并非是指123456这种，而是由于商户员工的流动性，离职后密码没有修改造成订单信息被窃取。我们也曾考虑过做短信校验，但短信校验码就需要绑定手机，给一个公司的人绑定手机存在着实际的操作困难。后来我们采用了证书机制。但这也只是解决了自有平台的问题，商户自用平台还是存在口令泄漏。在排除法上，一旦出现订单信息泄露反馈，立刻修改密码，由此来判断是否是由于口令问题引起。\n**5、无线与监听问题。**很多公司都用的是小型家用无线路由器，这种路由器一是默认密码不修改，二是自身有漏洞。这样黑客就可以采用DNS中间人、网络监听流量等手段获取网络流量信息。这种情况下，改系统密码、上云服务其实都没有用处，但最重要的问题是难以发现。商户完全不具备这种被攻击的发现能力，除非我们做一款硬件安全路由分发给商户。\n商户这端的风险，主要是由于商户IT水平、管理水平较低造成，另外分散在全国甚至海外。所以如果要完全解决商户端的风险，就几乎意味着我们要替商户包办一切，从软件系统到杀毒软件，从无线路由再到人员管理，事实上对于一家电商公司来说，是几乎不可能完成的任务。\n二、用户环节\n用户自身的问题属于第二个比较突出的问题。能在这里看这篇文章的，对自身的安全都有防范意识，但对于小白用户，这就是一个比较突出的问题。而且订单信息泄露最终的受害者也是用户，如果安抚不好处理不当，就会吃官司。\n用户这里比较突出的是问题：账号被盗、木马病毒、钓鱼、无线。\n**1、 账号被盗。**这个很容易理解，不解释了，值得一提的是目前主要是撞库。撞库这个事情，稍微有点技术实力的电商都会用各种手段来防御，比如设备指纹、IP判定等防扫号。\n**2、 木马病毒。**主要是手机端的比较突出，去年下半年一段时间，我们发现接近70%的订单信息泄露是手机用户。我们密集调研了受害用户，发现在手机上确实存在安卓远控类软件，但种类十分繁多。所以我们在APP上增加了一些安全的功能，对其中一些数据做了特殊加密，对启动环境进行了判断。\n**3、 钓鱼，伪基站钓鱼是一种。**另外是社工类的钓鱼，冒充客服打电话、兼职招聘收集用户信息等，其目的也主要是为了得到账号。\n4、 无线，主要是伪热点收集信息。\n用户这的问题都比较容易理解，但对用户端问题的解决则是一个很大的工程。这些问题的解决分为我们可以掌控的和不能掌控的。对于账号被盗、木马病毒，基本上我们还可以提供对应的解决方案。但对于钓鱼问题，整体上已经完全绕过了我们的平台，钓鱼问题的打击，又可以专门写一篇文章来说了，一般是快速发现、合作关闭、宣传教育。\n但是，通常用户不会理解这里的问题，总是将责任归于电商平台。会产生投诉，甚者会产生司法纠纷。所以对用户的投诉处理要慎重对待，某些特殊用户可能要先行赔偿，出现危机要有公关处理。\n三、物流环节\n物流端其实也和商户一样，但是结构上会简单一些。主要风险两个：\n**1、 内部倒卖。**有倒卖系统数据的，但更多的是倒卖物流面单，倒卖物流订单的特点是地域化比较集中，通常是某个门店，所以很容易归类发现。而且主要集中在一些代理加盟的物流点，管理比较松散。\n**2、 系统漏洞。**关于系统漏洞大家见得就多了，我印象中几个大的物流公司都有出过问题，攻击者可以直接从系统上捞取物流信息。\n对物流公司的泄露，一是宣传教育，二是专项打击，配合公安几轮打下来，他们就会引以为鉴。这里有一个判断因子，有些情况下，订单还没有到物流侧，用户就接到了诈骗电话，所以在调查的时候要问清楚。\n四、电商平台\n从电商自己来说，泄露订单完全没有意义—我是指正规电商，不是那种骗了钱就跑的。买卖这些订单其实赚不了什么钱，还会对形象造成重大打击，带来无穷的麻烦和官司，完全得不偿失。所以从根本上就不会想通过这种方法赚钱。\n平台端我碰到的问题主要分为两类，内鬼和系统漏洞。但内鬼里面最突出的问题是外包，所以我单拿出来说这种问题。\n**1、 内部员工作案。**一个电商的业务系统，能够接触到用户订单的人实在太多，从客服到技术，到数据平台，前端等都有机会接触。内部员工的管控相对比较容易，一个是匿名化处理，所谓匿名化处理，就是对关键用户信息进行匿名或模糊处理，即使员工接触到也无法联系对方，或必须通过系统联系对方。再一个是操作监控，如果要偷拿订单信息，必然是批量化，而不是个别单一订单，从统计上就可以做一些规则预警。还有一个是加强警示教育，一旦发现，从重处理绝不姑息。内部员工作案的几率比较低，但一旦出事就是大事，所以这部分能够在自己掌控的地方要处理好。\n**2、 外包员工。**外包员工的作案大家在媒体上也屡见不鲜，外包的应用系统开发、基础架构的维护、客服是这里需要重点看的问题。安全部门要介入外包管理，从最开始的立项就要保证外包无法接触到敏感数据。我们对外包除了在立项阶段，还进行现场调研，确定外包公司的环境能够满足我们对安全的要求，并且不定期抽查，抽查一定会让你有惊喜。\n**3、 自身的系统漏洞。**这里我要提的几个点，一是主要漏洞：防扫号、SQL注入、越权/遍历问题、搜索引擎爬取，对这一类漏洞的防范，就看企业的基本功了，生产新上线的系统有没有经过代码审计、渗透和扫描。另一个要说的是，其实主站问题大家都比较重视，但有很多后台支撑系统，各种问题五花八门，当企业做大以后，后台支撑系统出的问题不比主站少，这就要清理回收支撑系统，该放在内网的收到内网，该关的关，该改的改。\n总结\n1、 订单信息泄露的渠道多样，有很多渠道不在电商安全人员的掌控之内，原则上是自己能够把控的环境，一定要控制好。\n2、 控制不到的地方，要想办法延伸服务，国内三方商家的发展也刚刚开始，不可能做到十分规范化的操作。这时候安全人员要从技术上做一些辅助工具来协助三方商家，而不是一味地指责。在这种延伸过程中，可以壮大安全部门，提高安全人员的能力，做得好，还有可能赚一些服务费。\n3、 重视日志、环境数据的收集。在应急的时候，日志是泄露量判断的主要来源，也是攻击手法判断的主要来源，没有这个，丢人都不知道丢多大。再一个环境数据是指用户侧、三方商家侧，用了哪些软件、地域信息、商品类目、与谁合作都需要纳入，因为很多事件不是在短期内能够判断清楚的，把一定量的用户或商家订单泄露归并起来，就能从环境数据上找到共同点，从而重点突破。\n4、 排除法。短期内要判断问题，可以从排除法下手，一个软件一个软件的停，然后看效果。\n5、 综合解决方案。所有的订单信息泄露引起的诈骗，有一个点至关重要，就是用户的联系方式，没有联系方式诈骗就无法进行。但在商家、物流与客户的交易中，联系方式又至关重要。去年看到某电商对联系方式做了匿名化处理，我个人觉得是一个比较好的切入方式，当然工程量也很庞大，需要打通上下游一堆环节。但如果能够彻底实现，黑市的订单信息价格就会一落千丈。\n原来本自REEBUF.com\n","permalink":"https://water711.github.io/posts/2015-11-12-%E5%8F%8C11%E7%BD%91%E8%B4%AD%E4%BD%A0%E4%B9%B0%E4%BA%86%E5%90%97%E7%BD%91%E8%B4%AD%E8%AE%A2%E5%8D%95%E4%BF%A1%E6%81%AF%E5%B0%8F%E5%BF%83%E6%B3%84%E9%9C%B2/","tags":null,"title":"双11网购，你买了吗？网购订单信息小心泄露！"},{"categories":null,"contents":"不知道你有没有遇到过这种情况，明明杀软也查不出病毒，但是你经常会打开任一网址就自动跳转到广告页面，不停弹出莫名其妙的新窗口，主页被锁定无法修改，强制访问某些网站。至少我就遇到过好几次。这种情况便是“流量劫持”。\n昨日，上海浦东法院首次在司法层面将流量劫持认定为犯罪，该院判决了全国首起流量劫持刑案，两名被告人被判有期徒刑3年，缓刑3年；扣押在案的作案工具以及退缴在案的违法所得予以没收。\n从2013年底到2014年10月，付某、黄某等人租赁多台服务器，使用恶意代码修改互联网用户路由器的DNS设置，进而使用户登录“2345.com”等导航网站时，跳转到其设置的“5w.com”导航网站。两人再将获取的互联网用户流量出售给“5w.com”导航网站所有者——杭州久尚科技有限公司。\n“2345.com”网站察觉后向警方报案，上海警方于2014年10月份立案。2014年11月17日，付某接到民警电话通知后自动至公安机关，到案后如实供述了犯罪事实。后被告人付某让其母亲熊某打电话劝黄某投案。2014年11月17日，被告人黄某主动投案，并如实供述了自己的犯罪事实。\n经查，两名被告人短时间内违法所得就高达75.47万余元。\n浦东法院在审理后认为，被告人付某、黄某违反国家规定，对计算机信息系统中存储的数据进行修改，后果特别严重，依照《中华人民共和国刑法》第二百八十六条、第二十五条第一款的规定，均已构成破坏计算机信息系统罪，分别应处五年以上有期徒刑。被告人付某、黄某具有自首情节，可以减轻处罚；被告人付某让其母亲劝说被告人黄某投案，可以酌情从轻处罚。依照刑法第七十二条第一款和第七十三条第二款、第三款的规定，对被告人付某、黄某均可以宣告缓刑。\n据此，法院作出了上述判决。\n“流量劫持”分为很多种，比如CDN入侵，蜜罐代理，WLAN伪基站等等，我们最常见最容易感知的是DNS劫持，此次案件中的也是DNS劫持。DNS 负责将域名解析成 IP 地址。作为网络层的服务，面对的用户更广泛，面临的风险也大的多。比如你原本想访问A网站，但是有人偷偷做了手脚，让你实际上打开的是B网站。DNS 服务一旦被黑客控制，用户发起的各种域名解析，都将被暗中操控。将正常网站解析成黑客服务器的 IP，并事先开启了 HTTP 代理，用户上网时几乎看不出任何破绽；而黑客则获取到所有访问流量，各种网站账号信息都将一览无余。\n我们大多数人遇到的都是运营商劫持，实际上危害还只是停留在让你不厌其烦的程度。如果是黑客劫持，那很可能就会引导你不知不觉泄露个人密码信息财产等更大的危害了。\n为什么都喜欢劫持网页呢，实际上这和一个叫HTTP的底层协议分不开，在HTTP下一切都是明文传输的，流量中的通信数据，程序界面，代码在途中都可被轻易劫持。相信大部分为了方便都是保持登录状态的。而HTTP 是无状态的，而各种账号的登录状态，只能依靠浏览器的 Cookie 来实现。因此，只要有了的 Cookie 也就获得了用户账号的使用权。黑客得到 Cookie，即可在自己浏览器里还原出登录状态。尽管你只是被劫持浏览网页没有进行登录操作，但足够黑客控制你的账号，虽然不能获取密码。但是如果你自动记录密码网页自动填表，那可能会更糟，黑客可以很轻松的还原出你的密码，甚至拿到社工库里去试，最后套出你的所有信息。\n这也是为什么越来越多的网站采用相对较为安全的HTTPS协议的原因。HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。但由于SSL证书需要钱，连接服务器端资源占用也比较高等原因，很多网站目前依然使用的是HTTP协议，DNS劫持依然有很大生存空间。然而也是相对较为安全，比如现在很多浏览器，即使是IE浏览器都会提醒你不要继续浏览某个安全证书有问题的站点。\nDNS劫持问题重提，虽然很多人都抱着死猪不怕开水烫的态度，反正自己的信息也泄露的差不多了，但是那些完全掌握你信息的人都是打算玩数据闷声赚大钱的，不会轻易去暴露。所以请不要随便点来路不明的链接，浏览奇怪的网站，遇到自动弹出来的奇怪广告页面也要警觉，不要浏览安全证书有问题的网站，保不准哪天你的手机银行短信就会“叮”，扣费10w，当然，前提是你确实有10w。不论如何，现在“流量劫持”已经算违法了，下次你再被运营商将劫持便可以告他上法院了。也算是个好的开始。\n原文来自 PingWest品玩\n","permalink":"https://water711.github.io/posts/2015-11-11-%E6%B5%81%E9%87%8F%E5%8A%AB%E6%8C%81%E9%A6%96%E5%88%A4%E7%8A%AF%E7%BD%AA%E4%BB%8A%E5%90%8E%E8%BF%90%E8%90%A5%E5%95%86%E8%BF%98%E6%95%A2%E9%9A%8F%E4%BE%BF%E5%8A%AB%E6%8C%81%E4%B9%88/","tags":null,"title":"流量劫持首判犯罪，今后运营商还敢随便劫持么？"},{"categories":null,"contents":"本文原创作者：敏争\n“伪基站”目前已经成为广告、诈骗等垃圾短信的重要实施手段。在经过一轮打击销声匿迹一段时间之后，现在又有抬头之势，有的犯罪集团通过生产、销售“伪基站”设备，年获利可达到几百万。\n一、伪基站及其危害\n伪基站，是一套非法无线电发射装置，由一台笔记本电脑、一台发射器、一根天线、一部手机、一组电瓶组成。其中手机是用来探测伪基站可用的工作信道，到了某个区域后，用这个改造过的手机就可以测定出这个区域基站的信道，然后伪基站开始广播控制信道，由于信号的强度优势，诱使周围的手机连接伪基站，最后向连接上来的手机发送垃圾短信。从攻击角色上看，伪基站也是一种中间人攻击。\n通过伪基站发送的短信一般是两类：\n1、广告类。比如“xxx盛大开业，开业钜惠，光顾即送VIP至尊卡一张……”； 2、诈骗类。比如“我是房东，我在外地，请把房租打到我爱人账号xxx”；更有甚者，伪造10086或者95xxx的发送号码，诱骗用户访问木马链接，植入木马App，实现对用户的永久控制。通讯录、短信、照片等隐私信息都会被盗取。\n二、GSM基本原理\n整个GSM网络中，在手机终端侧，最重要的两个标识是IMSI和MSISDN。而运营商网络侧，核心是一个控制器（MSC）和三个数据库（HLR、VLR、AUC）。中间是基站系统。下面对几个关键概念分别做出解释：\n1、 概念解析\nIMSI\nIMSI是SIM卡的唯一ID，类似居民身份证号，全世界唯一。每次登记、位置更新、呼叫建立的尝试，都是以IMSI作为用户标识。\nMSISDN\n用户的电话号码，相当于姓名或者QQ昵称，即便重复了也不会影响正常的通信过程。IMSI和MSISDN的对应关系，存储在运营商的HLR中。\nMSC\n移动业务交换中心（mobile switching center），是GSM网络的核心，它提供交换功能以及面向系统其他实体的功能。MSC可以从三种数据库（HLR、VLR、AUC）获取处理用户位置登记和呼叫请求所需的全部数据。反之，MSC也根据其最新获取的信息请求更新数据库的部分数据。MSC具有号码储存译码、呼叫处理、路由选择、回波抵消、超负荷控制等功能；MSC能支持位置登记、越区切换和自动漫游等移动管理功能；MSC支持信道管理、数据传输，以及包括鉴权、信息加密、移动台设备识别等安全保密功能。\nHLR\n归属位置数据库,负责移动用户管理的数据库，永久存储和记录所辖区域内用户的签约数据，并动态地更新用户的位置信息，以便在呼叫业务中提供被呼叫用户的网络信息。\nVLR\n拜访位置数据库，它是一个动态数据库，服务于其控制区域内移动用户的，存储着进入其控制区域内已登记的移动用户相关信息，为已登记的移动用户提供建立呼叫连接的必要条件。VLR从该移动用户的归属用户位置寄存器(HLR)出获取并储存必要的数据。一旦移动用户离开该VLR的控制区域，则重新在另一个VLR登记，原VLR将取消临时记录的该移动用户数据。\nAUC\n鉴权中心，是GSM系统中的安全管理单元。存储鉴权算法和密钥，保证各种保密参数的安全性，向HLR提供鉴权参数（鉴权三参组，RAND、SRES、KC）。AUC鉴权中心通过伪随机码发生器产生128位随机数RAND，RAND和KI经过A3算法产生SRES，RAND和KI经过A8算法产生KC。\nBSS\n基站子系统，包括BTS（基站收发台）和BSC（基站控制器），是GSM系统与无线蜂窝方面最基本的组成部分。它通过无线电通信直接和手机相接，负责无线发送接收和无线资源管理。另一方面，基站子系统与网路子系统（NSS）中的移动业务交换中心（MSC）相连，实现移动用户间或移动用户与固定网路用户之间的通信连接，传送系统信号和用户信息等。\n2、GSM通信信道\n**其中BCCH向手机广播本小区频率和LAC（区域位置识别码），**这个对于实现伪基站至关重要。\n3、 GSM用户鉴权\n在GSM网络中，SIM卡和运营商配合完成用户鉴权，以此防止未经授权的接入，保护运营商和合法用户双方的利益。\n每个用户在GSM网中注册登记时，被分配给一个客户电话号码（MSISDN，就是通常的手机号）和客户身份识别码（IMSI）。IMSI通过SIM写卡机写入客户的SIM卡中，同时在写卡机中又产生了一个对应此IMSI的唯一客户鉴权密钥Ki，它被分别存储在客户的SIM卡和网络侧AUC中。在AUC中还有个伪随机码发生器，用于产生一个伪随机数RAND。在GSM规范中还定义了A3、A8和A5算法，分别用于鉴权和加密过程。\nGSM的鉴权流程如下：\n1、 GSM网络侧和SIM卡上存储相同的用户密钥Ki，用户开机准备接入网络，移动终端发送IMSI给MSC/VLR； 2、 VLR将首先查看在数据库中该MS是否有鉴权三参组，如果有，将直接向MSC下发鉴权命令，否则，向相应的HLR/AUC请求鉴权参数，从HLR/AUC得到三参组，然后再向MSC下发鉴权命令； 3、 MSC收到VLR发送的鉴权命令后，通过基站子系统向移动终端下发鉴权挑战请求； 4、 移动终端收到鉴权挑战请求后，利用SIM卡通过A3、A8算法计算出SRES和加密密钥KC，通过鉴权响应消息送达MSC； 5、 MSC将鉴权结果回送VLR，由VLR核对MS上报的鉴权结果和从HLR取得的鉴权参数中的结果，如果二者一致，则允许接入，否则拒绝此次接入请求。 6、GSM安全性\n从整个鉴权流程可以看出，在GSM网络中，SIM卡接入网络的鉴权方式是单向鉴权：只能网络对卡鉴权，卡无法鉴权网络。因此无法对抗主动攻击，如伪基站，非法设备可以伪装成合法的网络设备，实现欺骗。\n三、伪基站\n伪基站的整体工作流程：\n1、监听与伪装\n（1）使用修改过固件的手机获取邻小区BCCH频率；\n（2）选定BCCH信号最弱的小区频率；\n（3）发射伪装后的BCCH信号；\n2、吸引手机接入\n（1）手机发现LAC（位置区识别码）变化，要重选接入小区，伪基站要求手机鉴权，手机发送鉴权应答信息，伪基站直接确认成功；\n（2）手机发现接入小区变化，触发位置更新请求；\n（3）伪基站向手机发起识别请求，获取到IMSI、IMEI；\n3、发送短信\n伪基站设定任意主叫号码，于独立控制信道发送任意数量短信。\n4、踢出手机\n1、 伪基站更新LAC并广播； 2、 手机发现LAC变化，重新发起位置更新请求； 3、 伪基站拒绝位置更新； 4、 手机重选小区，接入正常基站；\n四、解决的可能性\n1、3G、4G网络实现了双向鉴权，通信过程使用了更强壮的加密算法和完整性算法，因此安全性更高，解决了伪基站问题；\n2、可以统计手机的LAC位置更新频次，过频（几秒到几十秒）意味着出现异常；\n3、短信和语音通信使用端到端加密。\n","permalink":"https://water711.github.io/posts/2015-11-11-%E8%B5%B0%E8%BF%91%E7%A7%91%E5%AD%A6%E6%8F%AD%E5%BC%80%E4%BC%AA%E5%9F%BA%E7%AB%99%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/","tags":null,"title":"走近科学：揭开伪基站的神秘面纱"},{"categories":null,"contents":"摘要: 屌丝程序员的逆袭一般分两步: 让自己变得牛逼, 让别人知道你牛逼. 我通过写博客来让自己更擅长归纳和抽象, 也通过写博客来让别人知道我能胜任某份工作.\n牛人都这么干 时间: 2011年\n人物: 初出茅庐的臭小子, 臭石头一般坚硬的相信我将来一定会成为富二代他爹.\n我来到一个大型互联网公司, 同事很nice, 管理很自由, 在这里开始了我的码农生涯.\n我很敬重部门老大, 但更相信我将来一定比他强. 我看到30岁左右的公司前辈们, 为了家庭奔波, 为了孩子操劳, 心里或许拂过一丝轻谑. ( 当我写这句话, 我是在对自己幼稚的轻谑 )\n当然我并不是毫无基础的就有了这些脆弱的自信. 我一直相信, 只要我每一天都在进步, 总会有到达成功的那一天. 所以, 每次游戏碰到大家都不熟悉的领域, 我都自告奋勇去领命, 然后在前辈们都回家 陪老婆孩子的时候, 我却在钻研这些小众歪门的技术, 自以为这是能力的体现. 事实也证明了它的确代表了我的一部分能力, 也让它在上级面前得到了彰显, 但远没有我想象的那么重要. 因为, 如果真的有那么重要, 为什么旁边独立办公室里没有我.\n那时天真的以为月入N万, 能在北京好好生存, 便是成功. 于是我很开心, 因为那”成功”是如此的可以触摸, 就在眼前. 我随便搞搞5,6年也就达到了, 稍微使点劲儿也许就3,4年. 而在那之后, 我就可以放心的做很多自己想做的事情, 旅游, 摄影, 吃喝玩乐之类.\n而现在, 我缺找不到对”成功”的定义了. 人生最大的无耐就在于, 当马上就达到终点却发现自己看走了眼. 让我开始怀疑它的因素有很多: 比如发现即使月入2N万也没法过得上我上面提到的体面的生活, 比如北京的空气和气候总是把出门散心的想法扼杀在摇篮里, 再比如北京复杂的生存环境.\n一方面,我对新的社会各种无知; 另一方面却坚定不移的相信努力就会比别人强. 我见过很多牛人写博客, 就以为这是牛人谓之牛人的原因. 我如果坚持照做, 就会成为牛人. 说白了, 这从头至尾就是一种低级的模仿, 不明所以的跟随.\n写一年后还能看懂的博客 尝试和接触的知识一多, 便发现自己的脑袋跟硬盘相比, 速度和精准度上都差得不止一星半点. 事情越来越多, 且没有交集, 所有的知识点都零散的分布在脑袋的不同次元, 想要回忆起来特别困难. 一度让我觉得, 学越来越多的东西根本就是一个错误, 正确的方式应该是瞅准一个东西, 精益求精. 虽然这么想, 但是工作不是你想不做就不做的.\n于是我有了两个转变:\n一是, 我不再那么乐于去学新的注定不会成为体系的东西了, 因为它除了能展示一下小聪明, 时间回报率特别小. 二是, 如果我决定去深究一个东西, 我一定要完全搞懂, 并认真总结一篇博客让我以后能在短时间拾起来 ( 因为不搞懂你很难写一篇半年后还能理解的博客 ). 我并不百分百的确定这些转变都是好的, 因为在这种问题上时间已经打过我很多次脸了.所以我会想, “转变一”是不是跟我”追求不断进步”的想法冲突. 直到我看到另一句话, “三十岁之前, 想学啥就学啥, 三十岁之后请用金钱解决你不擅长的问题”, 给了我一些安慰. 但这句话又丢给我更大的问号: 怎么界定”擅长”与否, 怎么界定”时间”. Anyway, 并不是所有问题都有合理答案, 但你开始意识到这个问题, 就有不一样的收获.\n把经验变成不可替代性 到现在, 我经历了三个公司, 四个项目, 两个由我负责.\n从产品角度讲, 我出色的完成了策划(/产品)的需求; 在共事过的同事上司面前, 我为自己留下了最真实的, 品质不错的, 名片.\n从技术角度讲, 它们并没有太大的难度. 大学\u0026lt;自动机理论\u0026gt;的老师向我们提供了一种衡量人生价值(/或意义)的方式: 你的不可替代性. 若依这个理论, 近三年的工作是没有什么意义可言的. 这让我如鲠在喉: 我的努力怎么就变成了没有意义.\n我先后写 AS3(+Flex), iOS(用UIKit做应用) 和 cocos2dx, 他们看起来相差万里, 但本质上都是图像显示引擎和通用UI逻辑组成的工具库.\n图像显示引擎, 提供最基础的图像绘制, 常见的图像显示引擎都大同小异, 都包括绘制点, 线, 形状, 照片, 文字等基本绘制接口. 通用UI逻辑, 虽各个平台功能千差万别, 但理论上都是为了让常用的交互或布局组件被更高效遍历的应用, 而对底层图像显示引擎的封装. 接触新框架的时间成本越来越小, 我也渐渐发现: 基础工作的长期积累会自动的帮你总结这些事物的共有原理. 本来, 我做的四件事情, 任何一件都有1万个人可以替代我. 但是它们给我带来的经验和理论的升华, 让我可以hold住那些只有一千个人能hold住的事情. 也就是, 我的不可替代性增加了.\n收入不受时间限制的职业 最近在看《黑天鹅-如何应对不可知的未来》, 不妨简单的罗列一下作者的观点:\n世界上的事情可简单的分为两种: 平均斯坦和极端斯坦. 平均斯坦里，个体对结果的影响不大，只有大量的个体才对结果有影响。极端斯坦里，个体能够对整体产生不可思议的影响。 举两个例子：随机取一百个人，得到平均身高，这个数不会因为某一两个人而出现大的变动，这属于平均斯坦；如果把身高换成财富，结果就大不相同了，可能因为比尔盖茨的加入而使得平均数成万倍的增长，这属于极端斯坦。 绝大多数社会问题属于极端斯坦，换句话说社会变量是信息化的，不是物理的。 有一位朋友建议我，寻找一份报酬不受时间限制的工作。面包师必须不断的烘烤面包才能得到更多的收入; 而 J.K.罗琳 不用在每次读者购买哈利波特的时候再写一遍。这也是脑力劳动与体力劳动的分界线。 按照这个理论, Coder也分为两种: 幸苦搬砖型和一劳永逸型. 对号入座的事情我就不做了, 显然我属于前者.\n程序员的抽象化修养 一般来说, 程序员的思维总是抽象化的思维, 善于从事物中总结规律, 同时特别特别特别讨厌特例. ( 想象一下产品让你为新手用户添加不一样的行为规范的时候你的心情吧. ) 抽象化的能力也决定了在程序员这一行当里的高度: 更擅长归纳事物本质的程序员渐渐都成了构架师, 而剩下的人完成了项目80%的工作却领到20%的报酬.\n程序员的名片 前面我提到自己在前同事上司那里留下的名片, 它同时也是一张可以预支的信用卡.\n在程序员跳槽的代价里, 标价最高的一条便是: 你需要重新证明自己. 每次初到一个环境, 不管ceo是你的同学还是以前的老板, 你必须在短时间里证明自己的能力, 因为第一印象决定了很多. 不管在上级,下级,还是平级同事里, 它都影响着你的工作或收入.\n从金钱上讲, 试用期你是拿不到全额薪水的. 老板必须先看到你的能力, 才会涨你的薪水, 也就是说证明自己的过程越短, 能越早拿到与你能力相配的薪水. 从工作上讲, 证明自己的过程, 你不能完全按照自己最擅长的方式去做事情, 完成同样的工作你需要花费更多的时间. 诚然, 你在前同事那里得到的信用额度比较大, 他们在后来的工作中能经常记起你, 不用面试和试用便可给你不错的报酬和职位. 但是, . 如果你需要更多公司的承认, 便要在这家公司证明. 听起来像是面包师的工作, 对吧? 于是, 我写博客.\n总结 屌丝 程序员 的逆袭一般分两步: 让自己变得牛逼, 让别人知道你牛逼. 我通过写博客来让自己更擅长归纳和抽象, 也通过写博客来让别人知道我能胜任一工作.\n注：原文来自 知明所以 的博客 http://www.cnblogs.com/jhzhu/p/3893297.html\n","permalink":"https://water711.github.io/posts/2015-11-10-%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E7%99%BD%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/","tags":null,"title":"一个码农的自白：我为什么写博客"},{"categories":null,"contents":"\n有几个人曾经问我，有哪些最有用或最好的编程语言适宜学习？\nHTML/CSS不谈，我认为答案取决于你想通过编程来做什么。\n几种编程语言简述 对只用一种语言来构建某个项目的情况而言，Javascript和它的框架是非常有用的。 Angular.js可以控制展示给用户的网站前端。 Node.js将作为管理网站所有内容的网络服务器。 Express.js在前端和服务器两者之间运行，对信息的来去进行导向。 MongoDB作为存储中心，用于存储从用户处获取的数据。MEAN（Mongo/Express/Angular/Node）——一个有助于构建你在一个Web应用中所需要的一切东西的结构化框架——是一套目前被大量初创公司所喜好的编程语言。这是一个完备的组件，它包含了基于单一语言来Web化地构建所有事物的技术。\n我一直在用Egghead.io和Scotch.io来及时更新我的Angular.js和MEAN技术。Egghead的网站内容主要集中于有序地组织的教学视频。Scotch有一些关于构建Web应用的整个流程的很棒的图表，包括下面这张解释MEAN的图表：\n它们都有很棒的教学视频，教你如何构建精巧的应用，例如基本的搜索引擎和新的表单验证方式（以确保若你创建输入表单，人们的实际输入将是有效标准下的值）。通过使用Angular.js，你可以使一个网站动画化并使它“动”起来，而不需要过多的设置。这是非常精巧的一种方式。\nPython可读性和灵活性都非常好，最近它成为大学院校在教授计算机专业时选择的入门语言之一。\n对于玩转数据以及用它的共通模块来完成各种你以前认为不可能的精巧工作来说——例如抓取完整的网页和进行高级科学计算，Python都是绝佳的。我是在Learn Python上开始学习Python的，它非常符合我“ 边做边学”的学习风格。\nJava（以及其他更紧密地与计算机硬件交互的语言）对人类理解来说会稍难一些，尽管对于帮助你理解“代码的实际运行过程”和“程序员与计算机的交互过程”的绝大部分知识而言，它们是很棒的。\nJava也用于在安卓系统上的移动应用开发，而这将会是一直有需求的领域。\n如果我们想简捷地将知识转换成金钱，那么，我曾见到业界对IOS开发者有着大量需求，而开发IOS应用所使用的Objective-C和Swift也并不那么难学习。\nRuby——尤其是当它与Rails一起使用时——是一种因其并不陡峭的学习曲线而被大量初创公司在初创时所用的语言（事实上，有一本叫Children’s Bookfor Ruby的书）。\n我自己正在学习Python以处理数据；学习Javascript和MEAN以创建Web应用；以及学习Java以对计算机科学有更深入的理解与构建移动应用。我认为这是一个可用的平衡良好的编程语言组合。\n我已经有了一组学习清单和资源，用来帮助你我学习构建杰出作品所需要的东西。但实际上，这些都不是最好的编程语言。\n最值得学习的编程语言——以及如何着手去学习它 学习如何像一个程序员那样思考——学习如何通过简洁的代码来用数学解决问题，绝对是最适宜学习的东西。编程语言会演进，它们会改变，它们会衰落并不再受欢迎；一个编程语言社群会变化成另外一个。\n现在伟大的Web应用可能会在几十年后被淘汰。不会改变的是对人们的逻辑思考和问题解决能力的需求——以及将它们变成在机器上运作的一个更简单的自动化流程的需求。\n你可以寄希望于一个事实，那就是随着时代不断发展，如果你训练解决问题的技能，你将能够找到最适合你的语言，以及获得你建立伟大事业所需要的知识与金钱。\n我已经开通了Project Euler，它提供一系列与数学和逻辑相关的编程问题。我在Codecademy workspace上尝试用Python构造整洁的代码来解决这些问题。这是一名Google招聘官所提到过的“一个学习编程的很好的训练步骤”，而我并不怀疑这一点。我感到我的大脑更敏锐了，并对我的能力更充满自信——不仅仅是编程能力，还有思考能力。\n最适宜学习的编程语言最终还是位于编程核心的逻辑，数学和问题解决能力。“什么是最适宜学习的 编程语言 ”这个问题并无对错，只要你理解编程的基础价值何在。\n本文属翻译作品，英文原文是：The best programming language for you to learn.\n译者： KayaWai 原作者：Roger Huang。最初发表在译言网。\n","permalink":"https://water711.github.io/posts/2015-11-10-%E5%AF%B9%E4%BA%8E%E5%B0%8F%E7%99%BD-%E5%93%AA%E5%87%A0%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%9C%80%E5%80%BC%E5%BE%97%E4%BD%A0%E5%8E%BB%E5%AD%A6%E4%B9%A0/","tags":null,"title":"对于小白 还在考虑学习哪几种编程语言吗"},{"categories":null,"contents":"\n为什么只有SSD才能喂饱你的电脑 曹一聪 · 4 个月前\n首先，这篇文章只是二葱学习Windows 系统的笔记，真不是讲怎么优化系统的，真没讨论要不要上SSD 啊，该上还是得上啊，表打我，逃（不知从什么时候开始，SSD渐渐成为解决电脑卡顿的第一解决方案。甚至关于MacBook与Windows笔记本的流畅度之争的核心，也是围绕是否标配PCI-E接口的SSD。而且大家纷纷换上SSD之后，也确实感觉到了系统运行速度的质的变化。似乎大家都忘了，若干年前大家刚装好的XP系统，也能做到一分钟内开机，打开Word文档似乎也是看个过场动画就打开了。那么究竟是什么导致现在电脑对SSD这么饥渴的需求呢？我们先来看一张截图：这是二葱自己电脑的启动项的截图，可能很多人都在各种系统优化技巧里读到过，禁用其中的一部分启动项可以提升系统的启动速度。然而事实是，经常见到安装了国产流氓软件套装的电脑，即便是把这些启动项都禁掉（所谓一键优化），依然需要花费数分钟的时间才能进入系统，好容易到了桌面了，还要失去响应好长时间。讽刺的是，二葱把这些启动项都打开，依然可以做到在一个微信小视频的时间内开机进入桌面。\n要想弄清楚这个问题，必须先弄清楚_Windows的启动流程_。\n（图片来自：http://hugo.caizhenwei.top//11341.the-windows-7-boot-process-sbsl.aspx）\nMBR阶段（16位实模式）：BIOS在完成通电自检后，将控制权移交给位于硬盘前63个扇区的MBR（Master Boot Record），MBR将自己的镜像加载到内存，然后执行对分区表的搜索，然后将控制权转移给第一个活动分区的PBR（Partition Boot Record）； PBR阶段（16位实模式）：PBR是因操作系统而异的分区引导记录，它将自身加载到内存并加载基本的磁盘驱动，通过BIOS INT中断的方式查找此分区上的引导文件，也就是我们的Bootmgr，并将其加载到内存； Bootmgr阶段（16位实模式和32位无分页内存）：读取BCD信息，显示启动菜单，如果安装有多个版本的Windows引导记录，能在这里选择要启动的系统，或者执行内存测试等操作，在选定操作系统后，将Windows BootLoader——Winload.exe加载到内存； Winload.exe阶段（32位或64位 保护模式，有内存分页）：加载Windows内核 Ntoskrnl.exe和它的依赖项Kdcom.dll（Kernel Debugger），Ci.dll，Clfs.sys，Pshed.dll，HAL.dll（硬件抽象层，其实就是主板驱动），并将注册表中HKLM\\SYSTEM子键内容加载到内存，如果检测到页面文件Hiberfil.sys则启动Winresume.exe恢复休眠文件； Ntoskrnl.exe阶段（保护模式）：初始化Windows执行体并一一加载注册在HKLM\\SYSTEM\\CurrentControlSet\\Services下标记为System的系统驱动程序，运行会话管理器smss.exe，准备运行native code所需的环境； Smss.exe阶段（Native程序）：初始化环境变量和Windows图形子系统（Win32k.sys），初始化Windows API（csrss.exe）和Windows初始化进程（WinInit.exe）和登陆进程（WinLogon.exe）； WinInit.exe阶段（Windows程序）：初始化服务管理器（SCM），本地安全鉴定进程（LSASS）和本地会话管理器（LSM），初始化剩余的注册表中的启动项内容，以用户态运行启动项任务； Winlogon.exe阶段：显示登陆画面，处理与用户登录相关的安全鉴定任务； Services.exe阶段：完成加载在HKLM\\SYSTEM\\CurrentControlSet\\Services下标记为AutoStart的驱动程序和Windows服务； Explorer.exe阶段：在创建Windows Shell（Explorer.exe）时，初始化桌面窗口管理器（DWM）进程，Explorer.exe加载自身和相关启动项。 自此Windows的启动流程才算基本结束。下图是二葱在虚拟机里安装的基本纯净的Win 7系统完成启动后的所有进程：\n图中可以看出进程的父子关系，其中粉色标注的是系统服务，淡蓝色的是用户进程。之前提到，以高完整性级别运行某个程序，需要UAC提权，而且以管理员账户是不能以SYSTEM的身份创建进程的。那么图中以SYSTEM运行的电脑管家、甚至是Bing输入法的更新程序，还有以High级别运行的子进程是如何创建的呢？\n答案就藏在HKLM\\SYSTEM\\CurrentControlSet\\Services中，读到这里大家不妨运行regedit亲自查看一下自己电脑里的注册表项，这是大部分在启动时加载或延时加载的Windows服务和相关驱动。刚才文章开头从任务管理器里看到的启动项，把它们都加起来，应该都没有这个子键下的启动项要多，甚至都不在一个数量级上。每个子键下，Start的值都表示着这个启动项的触发时间：\n0：由BootLoader加载，比系统内核启动的时间还要早，标为0的多是底层ATA驱动； 1：由Ntoskrnl加载，比如各类常规硬件驱动、过滤型驱动，还有各路安全卫士的程序本体、QQ的窗体保护驱动等； 2：由WinInit加载或特定事件触发，在基本的GDI图形初始化完成后才加载的程序，如果装的程序多的话，也会占用不少启动时间； 3：手动加载； 4：该项被禁用。 其中Start值为0和1的启动项，是以高权限加载的，即上图中标注为粉色的进程。\n现在事实的真相已经浮出水面了，如果你觉得自己的电脑启动时间过长——甚至SSD也没有带来改善的话，可以去看一下注册表的HKLM\\SYSTEM\\CurrentControlSet\\Services这里，是不是有上百个加载项。二葱在舍友的电脑上试了下，发现早就被他卸载的xx日历、xx视频、xx助手各类软件一个不少，一共五百多项，这样的电脑恐怕连SSD都无法拯救吧。\n（如果需要对这里面的启动项进行删减，请一定一定不要直接删除所怀疑的子键，就不说三遍了，记住如果想禁用一个Services里的启动项，先手动把Start的值改为“3”或“4”，如果重启之后使用一段时间确实不会产生负面影响的话，再考虑删掉这个子键。对于普通用户，更是不建议手动对注册表做任何改动，因为HKEY_LOCAL_MACHINE下的子键涉及系统全局配置，修改不善会造成整个系统的不稳定）\n这还没完，在加载完驱动和服务之后，WinInit还要继续加载这里的用户态启动项：\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\Load HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\Run HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce %ALLUSERSPROFILE%\\Start Menu\\Programs\\Startup\\ %USERPROFILE%\\Start Menu\\Programs\\Startup\\ 对于详细的Windows启动流程大家可以参考：The Birth of Windows Desktop ，更加详细的信息可以查阅Windows Internals Book 一书的第13章：启动和关机。\n这里向大家推荐一个检测系统启动项的工具：Autoruns，在Sysinternals Suite中可以找到。它能检测系统中存在的所有类型的启动项，包括由WinInit加载的用户启动项、由系统加载的驱动启动项，还有跟Explorer.exe相关的启动项（比如右键关联菜单等）。\n通过取消勾选就能干掉启动项，甚至能离线检测其他硬盘上的操作系统——如果它们损坏不能启动的话——通过禁掉可疑驱动的方式修复系统。这货还能导出刚配置好系统时的启动项记录，并在以后随时与之比较，找出新增的启动项。\n通过“Description”和“Publisher”可以基本确定一个启动项的作用和发布者，如果在这里看到不希望被自动加载的条目，可以直接取消勾选。通常不建议大家直接通过注册表编辑器直接改动HKLM\\SYSTEM\\CurrentControlSet\\Services里面的内容，但如果大家对系统机制有所了解，可以通过Autoruns可以基本确定非必需的启动项，然后手动干掉它。\n回想起来，之前面试被问到系统启动项都有哪些的时候，才知道自己的回答有多么幼稚。好在知之甚少不可怕，只要做到比昨天知道的更多就好。像这种经常被大家忽视的真相，就一定要让更多人知道。所以如果看完你觉得大彻大悟，原来自己被耍这么久，请不要忘记分享到朋友圈：）\n最后再提一下Windows 8引入的快速启动功能，如下图所示，多数电脑都会默认开启这个选项：\n打开了 “快速启动”的电脑，在关机时不会像以前那样依次结束进程然后关闭电源，而是在关闭了用户态的进程后，将Session 0的内核会话压缩到Hibernate文件中，在下次开机时并不会重新一一载入所有的设备驱动，而是直接将内核会话的休眠文件释放到内存，然后重新初始化它们。\n据说这项技术最大能减少 70% 的启动时间。\n另外，对于支持UEFI启动的电脑，通电自检时不再会像以前BIOS那样依次检测硬件设备的完好性，而是并行检测，也可以缩短1~2秒的启动时间。\n所以说，如果你也时常向你的朋友表演开机，那么包括SSD，UEFI、Windows的快速启动、Prefetch预读取这些技术都功不可没，虽然SSD能让系统运转如飞，但许多系统卡顿的原因可能并不是因为没有SSD，而是因为用久了长出了许多流氓启动项。而且，别忘了向他们展示你的HKLM\\SYSTEM\\CurrentControlSet\\Services，告诫他们合理安装国产软件，兴许号称帮你清理启动项的卫士本身，才是占据启动时间的大头：）\n发自知乎专栏「二葱写字的地方」\n","permalink":"https://water711.github.io/posts/2015-11-10-%E7%94%B5%E8%84%91%E5%8D%A1%E5%8D%A1%E5%8D%A1%E4%BD%86%E4%BD%A0%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81-ssd-%E5%90%97/","tags":null,"title":"电脑越用越卡，但你真的需要 换SSD吗？"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","permalink":"https://water711.github.io/posts/search/","tags":null,"title":"Search Results"}]